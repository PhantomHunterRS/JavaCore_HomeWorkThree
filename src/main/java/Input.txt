Java8
Полностью обновлено с учетом
версии Java SE 8 (JDK 8)
Java
Руководство для начинающих
Шестое издание
Современные методы создания,
компиляции и выполнения программ на Java
Герберт Шилдт
Oracle
Press
Java™
А Beginner's Guide
Sixth Edition
Herbert Schildt
New York • Chicago • San Francisco • Athens • London • Madrid
Mexico City • Milan • New Delhi • Singapore • Sydney • Toronto
Java8
Руководство для начинающих
Шестое издание
Герберт Шилдт
•
Издательский дом "Вильяме"
Москва • Санкт-Петербург • Киев
2015
ББК 32.973.26-018.2.75
Ш57
УДК 681.3.07
Издательский дом "Вильяме"
Главный редактор С.Н. Тригуб
Зав. редакцией В.Р. Гинзбург
Перевод с английского и редакция канд. хим. наук А.Г. Гузикевича
По общим вопросам обращайтесь в Издательский дом "Вильяме" по адресу:
info@williamspuЫishing.com, http://www.williamspuЬlishing.com
Ши;щт, Герберт.
Ш57 Java 8: руководство для начинающих, 6-е изд. : Пер. с англ. - М.
ООО "И.Д. Вильяме", 2015. - 720 с.: ил. - Парал. тит. англ.
ISBN 978-5-8459-1955-7 (рус.)
ББК 32.973.26-018.2. 75
Все названия программных продуктов являются зарегистрированными торговыми марками соответствующих
фирм.
Никакая часть настоящего издания ни в каких целях не может быть воспроизведена в какой
бы то ни было форме и какими бы то ни было средствами, будь то электронные или механические,
включая фотокопирование и запись на магнитный носитель, если на это нет письменного разрешения
издательства McGraw-Hill Education.
Authorized Russian translation of the English edition of Java: А Beginners Guide, бth Edition, © 2014 Ьу
McGraw-Hill Education (ISBN 978-0-07-180925-2).
This translation is puЫished and sold Ьу perrnission of McGraw-Hill Education, which owns or controls all
rights to puЫish and sell the same.
АН rights reserved. No part of this book may Ье reproduced or transmitted in any form or Ьу any means,
electronic ог mechanical, including photocopying, recording, or Ьу any inforrnation storage or retrieval system,
without the prior written perrnission of the copyright owner and the PuЫisher.
Научно-популярное издание
Герберт Шилдт
Java 8: руководС1Во для начинающих, 6-е издание
Литературный редактор
Верстка
Художественный редактор
Корректор
И.А. Попова
Л.В. Чернокозинская
Е.П. Дынник
Л.А. Гордиенко
Подписано в печать 15.04.2015. Формат 70х!ОО/16
Гарнитура Тimes.
Усл. печ. л. 58,05. У ч.-изд. л. 35
Тираж 500 экз. Заказ № 1908.
Оrпечатано способом ролевой струйной печати
в АО «Первая Образцовая типография»
Филиал «Чеховский Печатный Двор»
142300, Московская область, г. Чехов, ул. Полиграфистов, д.1
ООО "И. Д. Вильяме", 127055, r. Москва, ул. Лесная, д. 43, стр. 1
ISBN 978-5-8459-1955-7 (рус.)
ISBN 978-0-071-80925-2 (англ.)
© 2015, Издательский дом "Вильяме"
© 2014, McGraw-Hill Education
Оглавление
Введение 18
lлава 1. Основы Java 25
lлава 2. Введение в типы данных и операции над ними 57
lлава 3. Управляющие операторы 89
lлава 4. Введение в классы, объекты и методы 127
Iлава 5. Дополнительные сведения о типах данных и операциях 159
lлава 6. Дополнительные сведения о методах и классах 203
lлава 7. Наследование 247
Iлава 8. Пакеты и интерфейсы 289
lлава 9. Обработка исключений 323
Iлава 10. Ввод-вывод данных 353
lлава 11. Мноrопоточное программирование 397
lлава 12. Перечисления, автоупаковка, статический импорт и аннотации 435
lлава 13. Обобщения 465
Iлава 14. Лямбда-выражения и ссылки на методы 503
lлава 15. Аплеты, события и другие вопросы 537
lлава 16. Введение в Swing 567
Глава 17. Введение в JavaFX 605
Приложение А Ответы на вопросы и решения упражнений для
самопроверки 643
Приложение Б. Применение документирующих комментариев в Java 699
Предметный указатель 707
Содержание
Об авторе
О техническом редакторе
Введение
Эволюция Java
Java SE 8
Структура книги
Основные навыки и понятия
Вопросы и упражнения для самопроверки
Вопросы к эксперту
Упражнения к главам
Книга для всех программистов
Необходимое программное обеспечение
Исходный код примеров программ
Для дальнейшего изучения
От издательства
Тhава 1. Основы Java
Истоки Java
Взаимосвязь между Java и языками С и С++
Взаимосвязь между Java и языком С#
Вклад Java в развитие Интернета
Jаvа-аплеты
Безопасность
Переносимость
Волшебный байт-код Java
Основные характеристики Java
Объектно-ориентированное программирование
Инкапсуляция
Полиморфизм
Наследование
Установка комплекта Java Development Кit
Первая программа на Java
Ввод исходного кода программ
Компиляция программы
Построчный анализ исходного кода первого примера программы
Обработка синтаксических ошибок
Еще одна простая программа
17
17
18
18
21
21
21
21
22
22
22
22
22
22
23
25
27
28
29
29
29
30
30
30
32
33
34
35
35
36
37
37
38
39
41
42
Содержание 7
Другие типы данных 44
Два управляющих оператора 47
Оператор if
47
Цикл for 48
Создание блоков кода 50
Использование точки с запятой в коде программы 51
Стилевое оформление текста программ с помощью отступов 52
Ключевые слова Java 54
Идентификаторы в Java 54
Библиотеки классов Java 55
Тhава 2. Введение в типы данных и операции над ними 57
Особая важность типов данных 58
Элементарные типы данных Java 58
Целочисленные типы данных 59
Типы данных с плавающей точкой 61
Символы 61
Логический тип данных 63
Литералы 65
Шестнадцатеричные, восьмеричные и двоичные литералы 66
Управляющие последовательности символов 66
Строковые литералы 67
Подробнее о переменных 68
Инициализация переменных 68
Динамическая инициализация 69
Область действия и время жизни переменных 69
Операции 72
Арифметические операции 72
Операции инкремента и декремента 74
Операции сравнения и логические операции 75
Укороченные логические операции 76
Операция присваивания 79
Составные операции присваивания 79
Преобразование типов при присваивании 80
Приведение несовместимых типов 81
Приоритеты операций 83
Выражения 85
Преобразование типов в выражениях 85
Пробелы и круглые скобки 87
Тhава 3. Управляющие операторы 89
Ввод символов с клавиатуры 90
Условный оператор if 91
Вложенные условные операторы if 93
Многоступенчатая конструкция if-else-if 94
Оператор swi tch 95
Вложенные операторы switch 98
8 Содержание
Цикл for
Некоторые разновидности цикла for
Пропуск отдельных частей в определении цикла for
Бесконечный цикл
Циклы без тела
Объявление управляющих переменных в цикле for
Расширенный цикл for
Цикл while
Цикл do-while
Применение оператора break для выхода из цикла
Оператор break в роли оператора goto
Применение оператора continue
Вложенные циклы
Тhава 4. Введение в классы, объекты и методы
Основные сведения о классах
Общая форма определения класса
Определение класса
Порядок создания объектов
Переменные ссылочного типа и присваивание
Методы
Добавление метода в класс Vehicle
Возврат из метода
Возврат значения
Использование параметров
Добавление параметризированного метода в класс Vehicle
Конструкторы
Параметризированные конструкторы
Добавление конструктора в класс Vehicle
Еще раз об операторе new
Сборка мусора и методы завершения
Метод finalize ()
Ключевое слово this
Тhава 5. Дополнительные сведения о типах данных и операциях
Массивы
Одномерные массивы
Многомерные массивы
Двумерные массивы
Нерегулярные массивы
Трехмерные, четырехмерные и многомерные массивы
Инициализация многомерных массивов
Аnьтернативный синтаксис объявления массивов
Присваивание ссылок на массивы
Применение переменной экземпляра length
Разновидность for-each цикла for
Циклическое обращение к элементам многомерных массивов
Использование расширенного цикла for
101
103
104
105
105
106
107
107
109
113
115
119
124
127
128
129
129
132
133
134
135
137
138
140
141
148
149
150
151
152
153
156
159
160
161
166
166
167
168
168
169
170
171
177
180
181
Содержание 9
Символьные строки 182
Создание строк 183
Операции над символьными строками 183
Массивы строк 186
Неизменяемость строк 186
Использование строк для управления
оператором switch 187
Использование аргументов командной строки 189
Поразрядные операции 190
Поразрядные операции И, ИЛИ, исключающее ИЛИ и НЕ 191
Операции сдвига 195
Поразрядные составные операции присваивания 197
Оператор? 200
Тhава 6. Дополнительные сведения о методах и классах 203
Управление доступом к членам класса 204
Модификаторы доступа в Java 205
Передача объектов методам 21 l
Способы передачи аргументов методу 212
Возврат объектов 214
Перегрузка методов 216
Перегрузка конструкторов 221
Рекурсия 226
Применение ключевого слова static 228
Статические блоки 231
Вложенные и внутренние классы 234
Переменное число аргументов 237
Использование методов с переменным числом аргументов 238
Перегрузка методов с переменным числом аргументов 241
Переменное число аргументов и неопределенность 242
Тhава 7. Наследование 247
Основы наследования 248
Наследование и доступ к членам класса 251
Конструкторы и наследование 254
Использование ключевого слова super для вызова конструктора суперкласса 255
Применение ключевого слова super для доступа к членам суперкласса 259
Создание многоуровневой иерархии классов 263
Очередность вызова конструкторов 266
Ссылки на суперкласс и объекты подклассов 267
Переопределение методов 272
Поддержка полиморфизма в переопределяемых методах 274
Для чего нужны переопределенные методы 276
Демонстрация механизма переопределения методов
на примере класса TwoDShape 276
Использование абстрактных классов 280
Использование ключевого слова final 284
Предотвращение переопределения методов 284
1 О Содержание
Предотвращение наследования 285
Применение ключевого слова final к переменным экземrmяра 285
Класс Obj ect 287
Тhава 8. Пакеты и интерфейсы 289
Пакеты 290
Определение пакета 291
Поиск пакета и переменная среды CLASSPATH 292
Простой пример применения пакета 292
Пакеты и доступ к членам классов 294
Пример доступа к пакету 295
Защищенные члены классов 296
Импорт пакетов 298
Библиотечные классы Java, содержащиеся в пакетах 299
Интерфейсы 300
Реализация интерфейсов 301
Применение интерфейсных ссьшок 305
Переменные в интерфейсах 312
Наследование интерфейсов 313
Методы интерфейсов, используемые по умолчанию 314
Основные сведения о методах по умолчанию 315
Практический пример использования метода по умолчанию 317
Множественное наследование 318
Использование статических методов интерфейса 319
Последнние замечания относительно пакетов и интерфейсов 320
Тhава 9. Обработка исключений 323
Иерархия исключений 325
Общее представление об обработке исключений 325
Использование ключевых слов try и catch 326
Простой пример обработки исключений 327
Необработанные исключений 329
Обработка исключений - изящный способ устранения программных ошибок 330
Множественные операторы catch 331
Перехват исключений, генерируемых подклассами 332
Вложенные блоки try 333
Генерирование исключений 334
Повторное генерирование исключений 335
Подробнее о классе ThrowaЫe 336
Использование ключевого слова finally 338
Использование ключевого слова throws 340
Новые средства обработки исключений, появившиеся в версии JDK 7 341
Встроенные классы исключений Java 343
Создание подклассов, производных от класса Exception 344
Тhава 10. Ввод-вывод данных 353
Потоковая организация системы ввода-вывода Java 355
Содержание 11
Байтовые и символьные потоки 355
Классы байтовых потоков 355
Классы символьных потоков 356
Встроенные потоки 357
Использование байтовых потоков 358
Консольный ввод 358
Запись консольного вывода 360
Чтение и запись файлов
с использованием байтовых потоков 361
Ввод данных из файла 361
Запись в файл 365
Автоматическое закрытие файлов 367
Чтение и запись двоичных данных 370
Файлы с произвольным доступом 374
Использование символьных потоков Java 377
Консольный ввод с использованием символьных потоков 378
Консольный вывод с использованием символьных потоков 381
Файловый ввод-вывод с использованием символьных потоков 382
Класс FileWri ter 382
Использование класса FileReader 383
Использование классов-оболочек для преобразования числовых строк 385
Тhава 11. Мноrопоточное проrраммирование 397
Общее представление о мноrопоточной обработке 398
Класс Thread и интерфейс RunnaЫe 399
Создание потока 400
Несложные усовершенствования мноrопоточной программы 403
Создание нескольких потоков 407
Определение момента завершения потока 410
Приоритеты потоков 412
Синхронизация 415
Использование синхронизированных методов 416
Синхронизированные блоки 419
Организация взаимодействия потоков с помощью методов notify (),
wait() иnotifyAll() 421
Пример применения методов wait () и notify () 423
Приостановка, возобновление и остановка потоков 428
Тhава 12. Перечисления, автоупаковка, статический импорт
и аннотации
Перечисления
Основные сведения о перечислениях
Перечисления Java являются типами классов
Методы values () и valueOf ()
Конструкторы, методы, переменные экземпляра и перечисления
Два важных ограничения
Перечисления наследуются от класса Enшn
435
436
437
439
439
441
442
443
12 Содержание
Автоупаковка 450
Оболочки типов 450
Основные сведения об автоупаковке 452
Автоупаковка и методы 453
Автоупаковка и автораспаковка в выражениях 454
Предупреждение относительно использования автоупаковки и автораспаковки 456
Статический импорт 457
Аннотации (метаданные) 460
Тhава 13. Обобщения 465
Основные сведения об обобщениях 466
Простой пример обобщений 467
Обобщения работают только с объектами 471
Различение обобщений по аргументам типа 471
Обобщенный класс с двумя параметрами типа 472
Общая форма обобщенного класса 473
Ограниченные типы 473
Использование шаблонов аргументов 477
Ограниченные шаблоны 479
Обобщенные методы 482
Обобщенные конструкторы 484
Обобщенные интерфейсы 485
Базовые типы и унаследованный код 492
Автоматическое определение аргументов типов компилятором 495
Очистка 496
Ошибки неоднозначности 497
Ограничения в отношении использования обобщений 498
Невозможность создания экземпляров параметров типа 498
Ограничения статических членов класса 498
Ограничения обобщенных массивов 499
Ограничения обобщенных исключений 500
Дальнейшее изучение обобщений 500
Тhава 14. Лямбда-выражения и ссылки на методы 503
Введение в лямбда-выражения 504
Основные сведения о лямбда-выражениях 505
Функциональные интерфейсы 506
Применение лямбда-выражений 508
Блочные лямбда-выражения 513
Обобщенные функциональные интерфейсы 514
Лямбда-выражения и захват переменных 521
Генерация исключений в лямбда-выражениях 522
Ссылки на методы 524
Ссылки на статические методы 524
Ссылки на методы экземпляров 526
Ссылки на конструкторы 530
Предопределенные функциональные интерфейсы 532
Содержание 1 З
Тhава 15. Аплеты, события и друrие вопросы 537
Основные сведения об аплетах 538
Организация аплета и его основные элементы 542
Архитектура аплетов 542
Завершенный каркас аплета 543
Инициализация и прекращение работы аплета 544
Запрос на перерисовку окна аплета 544
Метод update (} 546
Использование окна состояния 549
Передача параметров аплету 550
Класс Applet 552
Обработка событий 554
Модель делегирования событий 554
События 554
Источники событий 554
Слушатели событий 555
Классы событий 555
Интерфейсы слушателей событий 556
Применение модели делегирования событий 557 Обработка событий мыши 557
Простой пример аплета, демонстрирующий обработку событий от мыши 558
Другие ключевые слова Java 561
Модификаторы transient и volatile 561
Оператор instanceof 562
Модификатор strictfp 562
Ключевое слово assert 562
Машинно-зависимые методы 563
Тhава 16. Введение в Swing 567
Происхождение и философия Swing 569
Компоненты и контейнеры 571
Компоненты 571
Контейнеры 572
Панели контейнеров верхнего уровня 573
Менеджеры компоновки 573
Первая простая Swing-пporpaммa 574
Построчный анализ первой Swing-пporpaммы 576
Использование компонента JButton 580
Работа с компонентом JТextField 583
Создание флажков с помощью компонента JCheckBox 587
Класс Jlist 590
Применение анонимных внутренних классов для обработки событий 599
Создание аплета средствами Swing 601
Тhава 17. Введение в JavaFX 605
Базовые понятия JavaFX 607
Пакеты JavaFX 607
14 Содержание
Классы Stage и Scene
Узлы и графы сцены
Панели компоновки
Класс Application и жизненный цикл приложения
Запуск приложения JavaFX
Каркас приложения JavaFX
Компиляция и выполнение программы JavaFX
Поток выполнения приложения
Простой элемент управления JavaFX: компонент Label
Использование кнопок и событий
Основные сведения о событиях
Элемент управления Button
Демонстрация обработки событий кнопки
Три других элемента управления JavaFX
Компонент CheckBox
Компонент ListView
Компонент TextField
Введение в эффекты и преобразования
Эффекты
Преобразования
Демонстрация эффектов и преобразований
Что дальше
Приложение А. Ответы на вопросы и решения упражнений для
607
608
608
608
609
609
613
613
614
616
616
617
617
620
621
625
630
633
634
635
637
640
самопроверки 643
Глава l. Основы Java 644
Глава 2. Введение в типы данных и операции над ними 646
Глава 3. Управляющие операторы 647
Глава 4. Введение в классы, объекты и методы 650
Глава 5. Дополнительные сведения о типах данных и операциях 651
Глава 6. Дополнительные сведения о методах и классах 655
Глава 7. Наследование 659
Глава 8. Пакеты и интерфейсы 661
Глава 9. Обработка исключений 663
Глава 10. Ввод-вывод данных 666
Глава l l. Многопоточное программирование 669
Глава 12. Перечисления, автоупаковка, статический импорт и аннотации 671
Глава 13. Обобщения 675
Глава 14. Лямбда-выражения и ссылки на методы 679
Глава 15. Аплеты, события и другие вопросы 683
Глава 16. Введение в Swing 688
Глава 17. Введение в JavaFX 693
Приложение Б. Применение документирующих комментариев в Java 699
Дескрипторы javadoc 700
Дескриптор @author 701
Дескриптор {@code} 701
Содержание 15
Дескриптор @deprecated 701
Дескриптор { @docRoot} 702
Дескриптор @exception 702
Дескриптор {@inheritDoc} 702
Дескриптор {@link} 702
Дескриптор {@linkplain} 702
Дескриптор {@literal} 702
Дескриптор @param 702
Дескриптор @return 703
Дескриптор @see 703
Дескриптор @serial 703
Дескриптор @serialData 703
Дескриптор @serialField 703
Дескриптор @since 704
Дескриптор @throws 704
Дескриптор @value 704
Дескриптор @version 704
Общая форма документирующих комментариев 704
Результат, выводимый утилитой javadoc 705
Пример применения документирующих комментариев 705
Предметный указатель 707

Об авторе
Герберт Шилдт - общепризнанный эксперт в области Java, автор многочисленных
бестселлеров, посвященных программированию, с почти тридцатилетним стажем писательской
деятельности. Его книги продаются миллионными тиражами и переведены
на многие языки. Из-под его пера вышли такие популярные книги по Java, как Java 8.
Полное руководство, 9-е издание, Java: методики программирования Шилдта и SWING:
руководство для начинающих. Им также написано множество книг по языкам программирования
С, С++ и С#. Герберт Шилдт закончил университет штата Иллинойс и там
же получил ученую степень. Посетите его сайт www. HerbSchildt. com.
О техническом редакторе
Дэнни Кауард - участник разработки всех версий платформы Java. Под его руководством
проходило внедрение технологии Java Servlets в первый и последующий выпуски
платформы Java ЕЕ, разрабатывались веб-службы для платформы Java М Е и осуществлялось
стратегическое планирование платформы Java SE 7. Кроме того, он был инициатором
создания группы первоначальных разработчиков технологии JavaFX, а в последнее
время занимался проектированием Java WebSocket API - одного из наиболее
значительных нововведений стандарта Java ЕЕ 7. Благодаря опыту непосредственного
написания программ на Java, участию в проектировании библиотек классов совместно
с отраслевыми экспертами, а также многолетнему членству в исполнительном комитете,
действующем в рамках Процесса сообщества пользователей Java (Java Community
Process), Дэнни обладает уникальным по своей широте кругозором во всем, что касается
технологий Java.
Введение
ц ель этой книги - обучить читателей основам программирования на Java. В ней
применяется пошаговый подход к освоению языковых средств, основанный на
анализе многочисленных примеров, разработке несложных проектов и закреплении полученных
знаний путем ответа на вопросы и выполнения упражнений мя самопроверки.
Изучение Java по этой книге не требует наличия предыдущего опыта программирования.
Книга начинается с рассмотрения элементарных понятий, включая компиляцию
и выполнение программ. Затем речь пойдет о ключевых словах и языковых средствах и
конструкциях, составляющих основу Java. После этого рассматриваются более сложные
языковые средства, в том числе мноrопоточное программирование и обобщения. Завершается
книга знакомством с библиотекой Swing и JavaFX. Все это позволит вам получить
четкое представление об основах программирования на Java.
Но эта книга - лишь первый шаг на пути к освоению Java, поскольку мя профессионального
программирования на Java нужно знать не только составные элементы этого
языка, но и многочисленные библиотеки и инструменты, существенно упрощающие
процесс разработки программ. Проработав материал книги, вы получите достаточно
знаний, чтобы приступить к изучению всех остальных аспектов Java.
Эволюция Java
Немногие языки могут похвастаться тем, что им удалось изменить общее представление
о программировании. Но и в этой "элитной" группе один язык выделяется среди
прочих. Его влияние очень быстро почувствовали все программисты. Речь, конечно же,
идет о Java. Не будет преувеличением сказать, что выпуск в 1995 году компанией Sun
Microsystems lnc. версии Java 1.0 вызвал настоящую революцию в программировании.
В результате "Всемирная паутина" стала по-настоящему интерактивной средой. Между
тем Java установил новый стандарт в разработке языков программирования.
Со временем Java усовершенствовался. В отличие от многих других языков, в которых
новые средства внедрялись относительно меменно, Java всегда находился на переднем
крае разработки языков программирования. Одной из причин, позволивших
добиться этого, послужило создание вокруг Java плодотворной атмосферы, способствовавшей
внедрению новых идей. В результате язык Java постоянно совершенствовался:
одни его изменения были незначительными, а другие - весьма существенными.
Первым существенным обновлением Java стала версия 1.1. Изменения в ней бьmи
более значительны, чем это обычно подразумевает переход к новой версии языка программирования.
В версии Java 1.1 были добавлены многие библиотечные элементы,
Введение 19
переопределены средства обработки событий, перекомпонованы многие функциональные
средства исходной библиотеки версии 1.0.
Следующим этапом развития данного языка стала платформа Java 2, где цифра 2 означает
"второе поколение". Ее появление стало поворотным событием, ознаменовавшим
начало "новой эпохи" Java. Первым выпуском Java 2 стала версия 1.2. На первый
взгляд, несоответствие номеров в обозначениях Java 2 и версии 1.2 может показаться
странным. Дело в том, что номером 1.2 сначала обозначались библиотеки Java и только
затем - весь выпуск. Компания Sun перекомпоновала программный продукт Java в J2SE
(Java 2 Platform Standard Edition - Стандартная версия платформы Java 2), и с тех пор
номера версий стали относиться именно к этому продукту.
Затем появилась версия J2SE 1.3, в которую были внесены первые значительные
изменения по сравнению с первоначальным выпуском Java 2. Новые функциональные
средства были в основном добавлены к уже существующим и более тесно связаны со
средой разработки. Версия J2SE 1.4 стала очередным этапом в развитии Java. Она содержала
новые важные средства, в том числе цепочки исключений, канальный ввод-вывод
и ключевое слово assert.
Следующая версия J2SE 5, по сути, стала вторым революционным преобразованием
Java. В отличие от большинства предьщущих модернизаций, которые сводились к важным,
но предсказуемым усовершенствованиям, в J2SE 5 были существенно расширены
рамки применения и функциональные возможности языка, а также повышена его производительность.
Для более ясного представления о масштабах изменений, внесенных в
версии J2SE 5, ниже дан перечень появившихся возможностей:
-о обобщения;
if! автоупаковка и автораспаковка;
е перечисления;
Ф усовершенствованный вариант цикла for;
􀃃 список аргументов переменной длины;
$ статический импорт;
,11, аннотации.
В этот список не вошли второстепенные дополнения и поэтапные изменения, характерные
для перехода к новой версии. Каждый элемент этого списка представляет собой
значительное усовершенствование Java. Для поддержки одних нововведений, в том числе
обобщений, варианта for-each цикла for и строки аргументов переменной длины, передаваемой
методу, понадобилось ввести новые синтаксические конструкции в язык. Другие
нововведения, такие как автоупаковка и автораспаковка, повлияли на семантику языка.
И наконец, аннотации открьши совершенно новые возможности для программирования.
Особая значимость описанных новшеств проявилась в том, что новая версия получила
номер "5". Можно было ожидать, что номером очередной версии Java будет 1.5.
Но нововведения были настолько существенными, что переход от версии 1.4 к 1.5 не
отражал бы масштабы внесенных изменений. Поэтому разработчики из компании Sun
решили увеличить номер версии до 5, подчеркнув тем самым важность нововведений.
В итоге новая версия получила название J2SE 5, а комплект разработчика приложений
на языке Java стал называться JDK 5. Но ради согласованности с предыдущими версиями
бьшо решено использовать 1.5 в качестве внутреннего номера версии, на который
также иногда ссылаются как на номер версии разработки. Цифра "5" в J2SE 5 означает
номер версии программного продукта.
20 Java 8: руководство для начинающих. 6-е издание
Следующая версия Java была названа Java SE 6. Это означает, что в компании Sun
вновь решили изменить название платформы Java. Прежде всего, из названия исчезла
цифра "2". Теперь платформа стала называться Java SE, официальным именем продукта
стало Java Platform, Standard Edition 6, а комплект разработчика приложений получил название
JDK 6. Как и цифра "5" в названии J2SE 5, цифра "6" в Java SE 6 означает номер
версии программного продукта, тогда как внутренним номером версии является 1.6.
Версия Java SE 6 создавалась на основе платформы J2SE 5, но отличалась от последней
рядом нововведений. Изменения в этой версии не такие масштабные, как в
предыдущей, но в ней были улучшены библиотеки интерфейса прикладного программирования
(API), добавлен ряд новых пакетов и доработана исполняющая система.
По существу, в версии Java SE 6 были закреплены усовершенствования, внедренные в
J2SE 5.
Следующая версия Java получила название Java SE 7, а соответствующий комплект
разработки приложений - JDK 7. Данной версии присвоен внутренний номер 1.7.
Java SE - это первая основная версия Java, выпущенная после того, как компания Sun
Microsystems lnc. была приобретена компанией Oracle (этот процесс начался в апреле
2009 года и завершился в январе 2010 года). В версии Java SE 7 появилось немало новых
средств, в том числе существенные дополнения были включены как в сам язык, так и
в стандартные библиотеки API. Также была усовершенствована исполняющая система
Java, в которой теперь поддерживаются программы, написанные на других языках программирования.
Наиболее важные средства, внедренные в версии Java SE 7 и рассматриваемые в этой
книге, были разработаны в рамках проекта Project Coin. В этом проекте преследовалась
цель определить ряд незначительных изменений в языке Java, которые должны быть
внедрены в JDK 7. И хотя эти изменения в целом считаются незначительными, их влияние
на процесс разработки программ нельзя недооценивать. На самом деле для многих
программистов они могут стать самыми важными среди всех новых средств, вошедших в
Java SE 7. Вот краткий перечень новых языковых средств Java SE 7:
,w возможность управления выбором в переключателе swi tch с помощью объектов
класса String;
')) двоичные целочисленные литералы;
w- символы подчеркивания в числовых литералах;
<# расширенный оператор try, называемый оператором try с ресурсами и поддерживающий
автоматическое управление ресурсами (например, теперь файловый
поток может быть закрыт, если в нем больше нет необходимости);
01 выводимость типов при создании обобщенного экземпляра объекта.
􀂲 усовершенствованная обработка исключений, благодаря которой несколько исключений
могут быть перехвачены одним (групповым) оператором catch, а также
улучшенный контроль типов для повторно генерируемых исключений.
Как видите, средства, отнесенные в рамках проекта Project Coin к разряду незначительных
языковых изменений, обеспечили преимущества, которые вовсе нельзя считать
незначительными. В частности, оператор try с ресурсами существенно сокращает объем
кода.
Java SE 8
Введение 21
Для новейшей версии Java - Java SE 8 - требуется комплект разработчика JDK 8,
имеющий внутренний номер версии 1.8. Комплект JDK 8 существенно расширяет возможности
языка Java за счет добавления нового языкового средства - лямбда-выражений.
Включение в язык лямбда-выражений, изменяющих как концептуальную основу
программных решений, так и способ написания кода на Java, будет иметь далеко идущие
последствия. Использование лямбда-выражений позволяет упростить исходный код
при создании некоторых языковых конструкций и уменьшить его объем. Добавление в
Java лямбда-выражений привело к появлению в языке нового оператора(->) и нового
синтаксического элемента. Эти нововведения лишний раз подтверждают статус Java как
живого, развивающегося языка, чего и ожидают от него пользователи.
Помимо лямбда-выражений, в JDK 8 добавлено много новых полезных средств. Так,
начиная с JDK 8 стало возможным определять реализации по умолчанию для методов,
специфицируемых интерфейсами. Кроме того, в JDK 8 включена поддержка JavaFX -
новой библиотеки графического пользовательского интерфейса (GUI). Ожидается, что
вскоре JavaFX станет непременной частью почти всех Jаvа-приложений и практически
вытеснит технологию Swing в большинстве GUI-проектов. В завершение можно сказать,
что платформа Java SE 8 представляет собой ключевой выпуск, который существенно
расширяет возможности языка и вынуждает пересмотреть подходы к написанию кода
на Java. Влияние описанных нововведений будет ощущаться всеми разработчиками
Jаvа-проrрамм еще протяжении многих лет.
Предыдущее издание этой книги было переработано с учетом всего вышесказанного
и теперь отражает многочисленные новшества, обновления и дополнения, появившиеся
в версии Java SE 8.
Структура книги
Книга представляет собой учебное пособие, разделенное на 17 глав, в каждой из которых
рассматриваются отдельные вопросы программирования на Java. Материал каждой
последующей главы основывается на предыдущей. Отличительная особенность
книги состоит в том, что в ней используется ряд специальных приемов, повышающих
эффективность обучения.
Основные навыки и понятия
Каждая глава начинается с рассмотрения самых важных для программирования навыков,
которыми читателю следует овладеть.
Вопросы и упражнения для самопроверки
В конце каждой главы приведены вопросы и упражнения для самопроверки, позволяющие
читателю проверить приобретенные им знания. Ответы на вопросы и решения
к упражнениям приведены в приложении А.
22 Java 8: руководство для начинающих. 6-е издание
Вопросы к эксперту
На страницах книги вам будуr встречаться врезки "Спросим у эксперта". Они содержат
дополнительные сведения или комментарии к рассматриваемой теме в виде вопросов
и ответов.
Упражнения к главам
В каждую главу включено одно или несколько упражнений, представляющих собой
несложные проекты, которые помогут вам закрепить полученные знания на практике.
Как правило, это реальные примеры, которые можно использовать в качестве основы
для разработки собственных прикладных программ.
Книга для всех программистов
Для чтения книги никаких особых навыков программирования не требуется. Конечно,
если вы уже имеете опыт программирования, то вам будет проще усваивать материал
книги. Но, поскольку Java имеет ряд принципиальных отличий от других популярных
языков, не спешите с выводами. Желательно читать книгу последовательно и не перескакивать
сразу к упражнениям.
Необходимое программное обеспечение
Для компиляции и запуска программ, исходные коды которых представлены в этой
книге, вам потребуется последняя версия комплекта Java Development Kit (JDK). На
момент написания книги это был комплект JDK 8 от компании Oracle для версии Java
SE 8. О том, как найти и установить такой комплект, речь поЙдет в главе 1.
Даже если вы пользуетесь более ранней версией Java, то это не помешает вам извлечь
пользу из чтения книги. Однако в этом случае вам не удастся скомпилировать и выполнить
те программы, в которых используются новые функциональные возможности Java.
Исходный код примеров программ
Исходный код всех примеров программ и проектов, рассмотренных в книге,
доступен для загрузки по адресу http: //www.mhprofessional.com/product.
php?isbn=0071809252 1
•
Для дальнейшего изучения
Эта книга - лишь одна из целого ряда книг по программированию, написанных Гербертом
Шилдтом. Тем, кто хочет больше узнать о программировании на Java, рекомендуются
следующие книги автора:
• Java 8. Полное руководство, 9-е издание (Ид "Вильяме", 2015 r.);
• Java: методики программирования Шилдта (Ид "Вильяме", 2008 r.);
• SWING: руководство для начинающих (Ид "Вильяме", 2007 r.).
I Загрузить исходный код примеров можно также на сайте Издательского дома "Вильяме" по
адресу http://www. williamspuЫishing. com/Books/978-5-8459-1955-7. html. - Примеч. ред.
Введение 23
От издательства
Вы, читатель этой книги, и есть главный ее критик. Мы ценим ваше мнение и хотим
знать, что бьuю сделано нами правильно, что можно было сделать лучше и что еще вы
хотели бы увидеть изданным нами. Нам интересны любые ваши замечания в наш адрес.
Мы ждем ваших комментариев и надеемся на них. Вы можете прислать нам бумажное
или электронное письмо либо просто посетить наш сайт и оставить свои замечания
там. Одним словом, любым удобным для вас способом дайте нам знать, нравится ли вам
эта книга, а также выскажите свое мнение о том, как сделать наши книги более интересными
для вас.
Отправляя письмо или сообщение, не забудьте указать название книги и ее авторов,
а также свой обратный адрес. Мы внимательно ознакомимся с вашим мнением и обязательно
учтем его при отборе и подготовке к изданию новых книг.
Наши электронные адреса:
E-mail: info@dialektika. сот
WWW: http: //www.dialektika.com
Наши почтовые адреса:
в России: 127055, r. Москва, ул. Лесная, д. 43, стр. 1
в Украине: 03150, Киев, а/я 152

Глава 1
Основы Java
26 Java 8: руководство для начинающих, 6-е издание
В этой главе ...
􀂨 История развития и основные концепции Java
i$J Влияние Java на развитие Интернета
􀂩 Назначение байт-кода
il Терминология Java
􀂪 Основные концепции объектно-ориентированного программирования
􀂫 Создание, компиляция и выполнение простой программы на Java
􀂬 Использование переменных
􀂭 Использование управляющих операторов if и for
$ Создание блоков кода
􀂮 Разбиение на строки, структурирование и завершение инструкций в
исходном коде
􀂯 Ключевые слова Java
􀂰 Правила использования идентификаторов Java
р азвитие Интернета и, в частности, Всемирной паутины (YvWW') существенно изменило
наши представления о сфере применения вычислительной техники. До появления Интернета
в распоряжении большинства пользователей были лишь персональные компьютеры,
работавшие независимо друг от друга. В настоящее время почти каждый компьютер
может иметь доступ к глобальным ресурсам через подключение к Интернету, который
также подвергся впечатляющим преобразованиям. Если первоначально Интернет был не
более чем удобным средством, позволяющим обмениваться файлами, то теперь он превратился
в огромную и разветвленную компьютерную вселенную. Подобные изменения
привели к появлению нового подхода к программированию, основанного на языке Java.
Язык Java особенно удобен для написания интернет-приложений, однако это не
единственная область его применения. Появление Java стало переломным моментом в
программировании, кардинально изменив наши представления о структуре и назначении
программ. В настоящее время программист не может считать себя профессионалом,
если не умеет писать программы на Java. Проработав материал книги, вы сможете овладеть
основами этого языка.
Данная глава служит введением в программирование на языке Java. В ней представлена
краткая история развития Java, стратегии разработки программ и наиболее важные
средства этого языка. Начинающим труднее всего уяснить, что в любом языке программирования
не существует независимых элементов и что все они тесно связаны между
собой. Такая взаимосвязь элементов языка характерна и для Java. В самом деле, очень
трудно рассматривать какой-то один аспект Java в отрыве от остальных. И для того чтобы
преодолеть подобное затруднение, в этой главе дается краткий обзор ряда языковых
средств Java, включая общую структуру программы на Java, основные управляющие блоки
и операторы. Не вдаваясь в детали, уделим основное внимание общим понятиям и
принципам, на основе которых создается любая программа на языке Java.
Истоки Java
Глава 1 . Основы Java 27
Главными причинами, побуждающими к созданию нового языка программирования,
служат совершенствование искусства программирования и изменения в вычислительной
среде. И Java не является исключением из этого правила. Опираясь на богатое наследие
С и С++, этот язык программирования расширен и дополнен средствами, отражающими
текущее положение дел в программировании. Отвечая потребностям возникшей
интерактивной среды, Java предоставляет средства, упрощающие создание прикладных
программ с распределенной архитектурой.
Язык Java был задуман в 1991 году сотрудниками компании Sun Microsystems Джеймсом
Гослинrом, Патриком Нотоном, Крисом Уортом, Эдом Фрэнком и Майком Шериданом.
Первоначально он назывался Oak, но в 1995 году, когда за его продвижение на
рынке взядись маркетологи, он был переименован в Java. Как это ни удивительно, на
первых порах сами разработчики языка не ставили перед собой задач разработки интернет-
приложений. Их целью бьuю создание платформенно-независимоrо языка, на
котором можно было бы писать встраиваемое программное обеспечение для различной
бытовой аппаратуры с микропроцессорным управлением, в том числе тостеров, микроволновых
печей и пультов дистанционного управления. Как правило, в устройствах подобного
типа применялись контроллеры на базе микропроцессоров различной архитектуры,
а исполняемый код, генерируемый компиляторами большинства существовавших
в то время языков программирования, был ориентирован на определенные типы процессоров.
Характерным тому примером может служить язык С++.
Несмотря на то что программу, написанную на С++, можно выполнить на процессоре
практически любого типа, сделать это можно, лишь скомпилировав ее в исполняемый
код команд конкретного процессора. Создание компиляторов - длительный и
трудоемкий процесс, поэтому в поисках оптимального решения Гослинr и другие члены
рабочей группы остановились на межплатформенном языке, для которого компилятор
генерировал бы код, способный выполняться на разных процессорах в различных вычислительных
средах. В конце концов их усилия увенчались созданием языка, известного
теперь под названием Java.
В то время как разработчики Java уточняли детали создаваемого ими языка, началось
бурное развитие "Всемирной паутины", во многом определившей будущее Java. Если бы
не формирование веб-сообщества, язык Java, вероятно, нашел бы лишь ограниченное
применение, главным образом в разработке программ, встраиваемых в специализированные
контроллеры. Но как только широкодоступный Интернет стал реальностью, появилась
острая потребность в переносимых программах, что и послужило причиной для
выдвижения Java на передний план в качестве основного языка разработки подобных
программ.
По мере накопления опыта многие программисты очень быстро приходят к выводу,
что переносимость программ - это нечто вроде труднодостижимого идеала. Задача создания
кросс-платформенных программ возникла едва ли не вместе с появлением первых
компьютеров, но взяться за ее решение так и не удавалось из-за необходимости решать
другие, более важные и неотложные задачи. Тем не менее с появлением Интернета проблема
переносимости программ перешла в разряд совершенно неотложных. Ведь Интернет
состоит из множества разнотипных компьютеров с различной архитектурой процессоров
и разными операционными системами.
В итоге увлекательная, но маловажная задача неожиданно стала чрезвычайно актуальной.
В 1993 году разработчикам Java стало ясно, что задачу переносимости нужно
28 Java 8: руководство для начинающих, 6-е издание
решать не только при программировании микропроцессорных устройств, но и при создании
кода для интернет-приложений. Иными словами, сфера применения языка Java
внезапно расширилась. И если программирование микроконтроллеров стало побудительной
причиной для создания Java, то Интернет способствовал широкому распространению
этого языка.
Взаимосвязь между Java и языками С и С++
Язык Java очень похож на языки С и С++. От С язык Java унаследовал синтаксис,
а от С++ - объектную модель. Сходство Java с языками С и С++ играет важную роль.
Во-первых, многие программисты знакомы с синтаксисом С и С++, что упрощает изучение
языка Java. Те же, кто освоил Java, могут без труда изучить С и С++.
Во-вторых, тем, кто программирует на Java, не приходится изобретать колесо. Они
могут успешно применять уже известные и хорошо зарекомендовавшие себя подходы.
Современная эпоха в программировании, по существу, началась с языка С. Затем появился
язык С++, а после него - Java. Имея такое богатое наследство, Java предоставляет
программистам производительную и логически согласованную среду, в которой были
реализованы лучшие из уже известных решений и добавлены новые средства, необходимые
для интерактивной среды. Очень важно отметить тот факт, что вследствие своей
схожести языки С, С++ и Java сформировали концептуальную основу для профессионального
программирования. При переходе от одного языка к другому программистам
не приходится преодолевать глубокие "пропасти" принципиального характера.
Один из принципов проектирования, заложенных в основу С и С++, заключается в
предоставлении программисту широчайших полномочий. Разработчики Java также следовали
этому принципу. Если не учитывать ограничения, накладываемые средой Интернета,
то следует признать, что Java предоставляет программисту полный контроль над
кодом. Если вы умеете грамотно программировать, это будет видно по вашим программам.
Недостаток опыта также отразится на ваших программах. Одним словом, Java -
язык не для дилетантов, а для профессионалов.
У Java имеется еще одно сходство с языками С и С++: все эти языки были задуманы,
разработаны, проверены и уточнены программистами-практиками. В их основу положены
реальные потребности их создателей. При таком подходе к разработке языка программирования
велика вероятность получить качественный продукт, способный найти
признание у специалистов.
Из-за сходства языков Java и С++, в особенности из-за подобия предоставляемых
ими средств для объектно-ориентированного программирования, возникает соблазн
рассматривать Java как своего рода версию С++ для Интернета. Но это было бы ошибкой.
У Java имеется целый ряд существенных отличий от С++ как в концептуальном,
так и в прикладном плане. Несмотря на то что С++ оказал очень сильное влияние на
язык Java, последний вовсе не является расширенной версией первого. В частности, эти
языки не совместимы ни сверху вниз, ни снизу вверх. Конечно, сходство с языком С++
очень важно, и если у вас имеется опыт программирования на С++, вы будете чувствовать
себя в своей стихии, программируя на Java. Но не следует забывать, что Java был
разработан не на замену С++, а для решения вполне определенного круга задач, отличающихся
от тех, что решаются с помощью С++. Именно поэтому мирное сосуществование
Java и С++ будет продолжаться еще многие годы.
Взаимосвязь между Java и языком С#
Глава 1 . Основы Java 29
Через несколько лет после создания Java корпорация Microsoft разработала язык С#.
И это очень важно, поскольку С# тесно связан с Java. В самом деле, у многих языковых
средств С# имеются свои аналоги в Java. В Java и С# используется единый общий синтаксис,
похожий на синтаксис С++, поддерживается распределенное программирование
и применяется одна и та же объектная модель. Разумеется, у Java и С# имеются отличия,
но внешне эти языки очень похожи. Это означает, что, зная С#, вы сможете относительно
легко изучить Java, и, наоборот, если вам предстоит изучить С#, знание Java может
очень пригодиться.
Учитывая сходство Java и С#, вы можете спросить: "Заменит ли С# язык Java?" Безусловно,
ответ на этот вопрос будет отрицательным. Java и С# оптимизированы для абсолютно
разных типов вычислительных сред. Как и вместе с языком С++, Java будет
мирно сосуществовать с языком С# еще многие годы.
Вклад Java в развитие Интернета
Развитие Интернета послужило основной побудительной причиной для выхода Java
на передовые рубежи программирования. В свою очередь, Java оказал благотворное влияние
на развитие Интернета. Этот язык не только упростил веб-проrраммирование, но
и положил начало новой разновидности сетевых программ, называемых аплетами, которые
полностью изменили представление о том, каким может быть веб-содержимое. Java
также позволил решить наиболее сложные задачи, возникающие при создании сетевых
программ: обеспечение переносимости и безопасности. Рассмотрим подробнее аплеты и
их основные свойства.
Jаvа-аплеты
Аплет - это особая разновидность программ на Java, предназначенная для передачи
по Интернету и автоматического выполнения в среде, формируемой Jаvа-совместимым
браузером. Аплет загружается по требованию клиентской программы, а для его передачи
по сети вмешательство пользователя не требуется. Если пользователь щелкает на ссылке,
указывающей на документ, который содержит аплет, последний будет автоматически
скопирован и запущен браузером. Большинство аплетов невелики по размерам. Обычно
они служат для отображения информации, предоставляемой серверами, или для поддержки
ввода данных пользователем. Иногда с их помощью реализуются несложные
функции. Например, калькулятор удобнее разместить в виде аплета на стороне клиента,
чем выполнять вычисления на стороне сервера. Таким образом, аплет позволяет переносить
некоторые функции с сервера на компьютер клиента.
С появлением аплетов расширился круг объектов, пригодных для свободной передачи
в сетевой среде. Существуют две категории объектов, которыми сервер может
обмениваться с клиентом: пассивные (статические) данные и активные исполняемые
программы (динамические данные). Например, просматривая электронную почту, вы
имеете дело со статическими данными. Даже если в почтовом отправлении пересылается
программа, то ее код не активизируется до тех пор, пока не получит управление.
Аплет, напротив, является динамической, самостоятельно выполняющейся программой,
для запуска которой не приходится принимать никаких мер. Такие программы выполняют
роль активных агентов на клиентских машинах, но инициализируются сервером.
30 Java 8: руководство для начинающих, 6-е издание
Несмотря на то что с помощью динамических программ можно реализовать полезные
функции, они могут вызвать серьезные затруднения, имеющие отношение к безопасности
и переносимости. Очевидно, что программа, которая загружается на компьютер
клиента и автоматически запускается, не должна наносить вред клиентской системе.
Кроме того, она должна допускать выполнение в разнотипных средах: на разных платформах
под управлением различных операционных систем. Как будет показано далее, в
Java эти затруднения изящно и эффективно преодолены.
Безопасность
Как известно, запуск обычной программы, загруженной через Интернет, сопряжен
с риском, поскольку она может быть заражена вирусом или служить своего рода "троянским
конем" для злонамеренного проникновения в систему. А злонамеренные действия
такой программы возможны из-за того, что она получает несанкционированный
доступ к системным ресурсам. Так, вирус, анализируя содержимое файловой системы
локального компьютера, может собирать конфиденциальные данные, например номера
платежных карт, сведения о банковских счетах и пароли. Для безопасной загрузки и запуска
аплетов на клиентской машине необходимо устранить саму возможность атаки на
систему со стороны аплета.
Защита от атак реализуется путем создания специальной среды для выполнения
аплета, не позволяющей ему обращаться к ресурсам компьютера. При отсутствии такой
среды аплет выполняться не может (далее будет показано, как решается подобная задача).
Возможность загружать аплет с уверенностью в том, что он не нанесет вреда системе,
относится к числу наиболее привлекательных особенностей Java.
Переносимость
Переносимость является важным свойством сетевых программ. Значимость этой характеристики
обусловлена тем, что в сети могут присутствовать разнотипные компьютеры,
работающие под управлением различных операционных систем. Если программа
на Java предназначена для выполнения на произвольном компьютере, подключенном к
Интернету, то должны существовать способы обеспечения работы этой программы в различных
системах. Например, один и тот же аплет должен работать на машинах с разнотипными
процессорами, в разных операционных системах и с различными браузерами.
Хранить разные версии аплета для разнотипных компьютеров слишком сложно, если
вообще возможно. Один и тот же код должен работать на всех машинах. Таким образом,
необходима поддержка процесса генерации переносимого исполняемого кода. Как
станет ясно в дальнейшем, те же самые средства, которые обеспечивают безопасность,
помогают добиться переносимости программ.
Волшебный байт-код Java
Добиться безопасности и переносимости программ по сети позволяет генерируемый
компилятором Java код, не являющийся исполняемым. Такой код называется байт-кодом.
Эго оптимизированный набор команд, предназначенных для выполнения в исполняющей
системе Java, называемой виртуальной машиной Java (Java Virtual Machine -
JVМ). Виртуальная машина Java, по существу, представляет собой интерпретатор
байт-кода. Такой подход может показаться не совсем обычным, поскольку для повышения
производительности компиляторы большинства современных языков генерируют
Глава 1 . Основы Java З 1
исполняемый код. Но выполнение программы под управлением виртуальной машины
позволяет разрешить многие затруднения, возникающие в работе веб-приложений.
Трансляция исходного кода Java в байт-код существенно упрощает перенос программ
из одной среды в другую, поскольку для обеспечения работоспособности кода достаточно
реализовать на каждой платформе виртуальную машину. Если на компьютере присутствует
пакет исполняющей системы, то на нем может работать любая программа, написанная
на Java. Несмотря на то что виртуальные машины на различных платформах
могут быть реализованы по-разному, они должны одинаково интерпретировать байткод.
Если бы исходный текст программы на Java компилировался в собственный код,
для каждого типа процессора, взаимодействующего с Интернетом, необходимо было
бы предусмотреть отдельную версию данной программы. Такое решение нельзя назвать
приемлемым. Следовательно, выполнение байт-кода под управлением виртуальной машины
- самый простой путь к обеспечению переносимости программ.
Выполнение программы под управлением виртуальной машины помогает также
обеспечить безопасность. Виртуальная машина может запретить программе выполнять
операции, побочные эффекты которых способны повлиять на ресурсы за пределами
исполняющей системы. Кроме того, безопасность достигается посредством некоторых
ограничений, предусмотренных в языке Java.
Как правило, интерпретируемая программа выполняется медленнее, чем скомпилированная
в машинный код. Но для кода Java отличия в быстродействии не очень существенны.
Ведь байт-код оптимизирован, и поэтому программа выполняется под управлением
виртуальной машины значительно быстрее, чем следовало бы ожидать.
Несмотря на то что Java был задуман как интерпретируемый язык, ничто не мешает
использовать оперативную (т.е. выполняемую на лету) компиляцию байт-кода в собственный
код процессора для повышения производительности. С этой целью сразу же
после первой реализации NМ компания Sun Microsystems начала работу над технологией
HotSpot, в рамках которой был разработан динамический компилятор байт-кода. Если
в состав виртуальной машины входит динамический компилятор, байт-код по частям
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Мне приходилось слышать о специальных программах на Java, называемых
сервлетами. Что это такое?
ОТВЕТ. Сервлет - это небольшая программа, выполняемая на стороне сервера.
Подобно тому как аплеты динамически расширяют функциональные возможности
веб-браузера, сервлеты динамически реализуют дополнительные функции
веб-сервера. Как бы ни бьти важны аплеты, они реализуют только одну
часть архитектуры "клиент-сервер". Прошло совсем немного времени с момента
появления Java, как специалистам стало ясно, что этот язык может оказаться
полезным и на стороне сервера. В результате появились сервлеты. Благодаря
сервлетам процесс взаимодействия клиентов и серверов может полностью поддерживаться
в программах на Java. Вопросы функционирования сервлетов выходят
за рамки книги для начинающих, но в дальнейшем вам будет полезно
изучить этот тип программ. Более подробно о сервлетах можно узнать из книги
Java 8. Полное руководство, 9-е изд. (Ид "Вильяме", 2015 г.).
32 Java 8: руководство для начинающих. 6-е издание
преобразуется в собственный исполняемый код. Преобразовывать сразу всю программу
на Java в исполняемый код нецелесообразно из-за разнообразных проверок, которые
могут производиться только на этапе выполнения программы. Поэтому динамический
компилятор выполняет преобразования кода частями по мере необходимости (отсюда
и его другое название - J/Т-компилятор, т.е. компилятор, вступающий в действие лишь
в нужный момент времени). Более того, компиляции подвергаются не все фрагменты
байт-кода, а лишь те, скорость выполнения которых можно повысить благодаря компиляции,
а остальной код интерпретируется. Несмотря на все ограничения, присущие
динамической компиляции, она тем не менее позволяет существенно повысить производительность
программ. И невзирая на динамическое преобразование байт-кода в
исполняемый код, переносимость и защита сохраняются, поскольку JVМ по-прежнему
участвует в процессе выполнения программ.
Основные характеристики Java
Даже самый краткий обзор языка Java будет неполным без упоминания его основных
свойств. И хотя главной причиной, побудившей к разработке Java, послужила потребность
в языке, обеспечивающем переносимость и безопасность программ, заметное влияние
на оформление Java в окончательном виде оказали и другие факторы. Ниже вкратце
перечислены основные свойства этого языка программирования.
Простота Java обладает лаконичными, тесно связанными друг с другом и легко ус-
ваиваемыми языковыми средствами
Безопасность Java предоставляет безопасные средства для создания интернет-прило-
жений
Переносимость Программы на Javo могут выполняться в любой среде, для которой имеет-
ся исполняющая система Java
Объектно-ориентира- В Jova воплощена современная философия объектно-ориентированного
ванный характер программирования
Надежность Javo уменьшает вероятность появления ошибок в программах благодаря
строгой типизации переменных и выполнению соответствующих проверок
во время выполнения
Многопоточность Jova обеспечивает встроенную поддержку многопоточного прогромми-
рования
Архитектурная Язык Jova не привязан к конкретному типу вычислительной машины или
независимость архитектуре операционной системы
Интерпретируемость Java предоставляет байт-код, обеспечивающий независимость от плот-
формы
Высокая производитель- Байт-код Jovo максимально оптимизируется для повышения производи-
ность тельности
Распределенность Язык Java проектировался с учетом его применения в распределенной
среде Интернета
Динамичность Программы но Jova содержат значительную долю информации, исполь-
зуемой во время выполнения для проверки и разрешения доступа к объ-
ектам
СПРОСИМ У ЭКСПЕРТА
Глава 1 . Основы Java 33
ВОПРОС. Если задачи переносимости и безопасности оказались столь актуальными,
то зачем для их решения нужно было создавать новый язык программирования
вроде Java. Не проще ли было адаптировать для этой цели уже существующий
язык, например С++? Иными словами, можно ли создать компилятор
С++, который генерировал бы байт-код?
ОТВЕТ. Создание компилятора С++, который вместо исполняемого кода генерировал
бы байт-код, вполне возможно, но язык С++ обладает рядом свойств,
препятствующих его использованию для разработки интернет-приложений.
Самым важным из них является поддержка указателей. Указатель содержит
адрес некоторого объекта, находящегося в памяти. С помощью указателей
можно обращаться к ресурсам за пределами программы, что создает бреши в
системе безопасности. В Java указатели не поддерживаются, а следовательно, и
не возникает никаких осложнений, связанных с безопасностью.
Объектно-ориентированное программирование
Одним из главных свойств Java является поддержка объектно-ориентированного
программирования (ООП). Объектная методология неотделима от Java, а все программы
на Java в той или иной степени являются объектно-ориентированными. Поэтому имеет
смысл кратко рассмотреть принципы ООП, прежде чем переходить к написанию даже
самой простой программы на Java. Далее вы увидите, как эти принципы реализуются на
практике.
Объектно-ориентированный подход к программированию позволяет разрабатывать
достаточно сложные программы. С момента появления первого компьютера методология
программирования претерпела ряд существенных изменений, связанных с возрастанием
сложности программ. На заре вычислительной техники процесс программирования
представлял собой ввод машинных команд в двоичной форме с пульта управления
ЭВМ. В то время размеры программ не превышали нескольких сотен команд, и поэтому
такой подход считался вполне приемлемым. Затем появился язык ассемблера. Символьное
представление машинных команд и процедура компиляции позволили перейти к
созданию более сложных программ. В связи с дальнейшим увеличением объема программного
кода появились языки высокого уровня. Они стали теми инструментами,
которые позволили программистам справиться с постепенным усложнением программ.
Первым из широко распространенных языков высокого уровня стал FORTRAN. Разработка
FORTRAN стала важным этапом в развитии языков программирования, но этот
язык не вполне подходил для создания удобочитаемых программ.
В 1960-е годы начало зарождаться структурное программирование. Впоследствии для
поддержки данного подхода был созданы такие языки, как С и Pascal. Благодаря структурированным
языкам программирования появилась возможность создавать программы
средней сложности. Главными свойствами структурированных языков стали поддержка
независимых подпрограмм, локальных переменных, наличие расширенного набора
управляющих конструкций и отсутствие оператора GOTO. Но, несмотря на то что структурированные
языки стали мощными инструментами программирования, с увеличением
объема и сложности проектов их возможности быстро исчерпались.
34 Java 8: руководство для начинающих. 6-е издание
На каждом очередном этапе развития методологии и инструментальных средств программирования
разработчики получали возможность создавать все более сложные программы.
На этом пути очередной подход наследовал лучшие черты своих· предшественников,
а кроме тоrо, он приобретал новые качества, позволявшие двигаться вперед.
К моменту разработки принципов ООП многие проекты стали настолько сложными,
что управлять ими средствами структурного программирования уже не представлялось
возможным. Объектно-ориентированная методология позволила разработчикам преодолеть
эти препятствия.
Создатели объектно-ориентированного программирования переняли лучшие идеи
структурного программирования и дополнили их новыми понятиями. В результате возник
новый способ организации программ. В принципе, программы могут создаваться
двумя путями: на основе кода (выполняющего действия) и на основе данных (подвергающихся
обработке). При использовании только принципов структурного программирования
программы организуются на основе кода. Такой подход можно рассматривать как
код, воздействующий на данные.
Объектно-ориентированное программирование подразумевает другой подход. Программы
организуются на основе данных по следующему главному принципу: данные
управляют доступом к коду. В объектно-ориентированных языках программирования
определяются данные и процедуры, которым разрешается обрабатывать эти данные. Таким
образом, тип данных определяет те операции, которые применимы к этим данным.
Во всех объектно-ориентированных языках программирования, в том числе и в Java,
поддерживаются три основных принципа ООП: инкапсуляция, полиморфизм и наследование.
Рассмотрим каждый из этих принципов по отдельности.
Инкапсуляция
Инкапсуляция представляет собой механизм программирования, объединяющий код
и данные, которыми он манипулирует. Он предотвращает несанкционированный доступ
к данным извне и их некорректное использование. В объектно-ориентированных
языках программирования код и данные организуются в некое подобие "черного ящика".
В результате такого объединения кода и данных создается объект. Иными словами,
объект - это компонент, поддерживающий инкапсуляцию.
Данные и код внутри объекта могут быть закрытыми (pri vate) или открытыми
(puЫic). Закрытый код или данные доступны только элементам, содержащимся в том
же самом объекте. Поэтому обратиться к такому коду или данным вне объекта невозможно.
Если код или данные являются открытыми, то к ним можно обращаться из любой
части программы (несмотря на то, что они находятся внутри объекта). Как правило,
открытые элементы объекта используются лля создания управляемого интерфейса к ero
закрытым элементам.
Основной языковой конструкцией, поддерживающей инкапсуляцию в Java, является
класс. Классы будут подробнее рассматриваться далее, но о них нужно сказать несколько
слов уже теперь. Класс определяет тип объекта. В нем определяются как данные, так
и код, выполняющий определенные действия над этими данными. В Java определение,
или так называемая спецификация класса, служит для построения объектов. Объекты
представляют собой экземпляры классов. Следовательно, класс - это ряд "чертежей",
по которым строится объект.
Код и данные в составе класса называются членами класса. Данные, определенные
в составе класса, принято называть переменными-членами, или переменными экземпляра,
а код, выполняющий действия над этими данными, - методами-членами, или просто
Глава 1 . Основы Java 35
методами. Метод - это термин, которым в Java принято обозначать подпрограмму.
Если вы знакомы с языками С/С++, то, вероятно, знаете, что в этих языках для той же
самой цели служит термин функция.
Полиморфизм
Полиморфизм (от греческого слова, означающего "много форм") - это свойство, позволяющее
с помощью одного интерфейса обращаться к общему классу действий. Конкретное
действие определяется ситуацией. В качестве примера, позволяющего лучше
понять принцип полиморфизма, можно привести руль автомобиля. Руль (т.е. интерфейс
взаимодействия) остается одним и тем же, независимо от того, какой именно механизм
рулевого управления применяется в автомобиле, будь то зубчатая, реечная передача или
гидроусилитель. Таким образом, зная, как обращаться с рулем, вы сможете управлять
автомобилем любого типа.
Тот же самый принцип применяется и в программировании. Рассмотрим в качестве
примера стек (структуру данных, организованных по принципу "последним поступил -
первым обслужен"). Допустим, в программе требуются три разнотипных стека. Первый
стек служит для хранения целочисленных значений, второй - для хранения значений с
плавающей точкой и третий - для хранения символьных значений. Каждый стек реализуется
с помощью одного и того же алгоритма, несмотря на то что в стеках хранятся разнотипные
данные. В случае языка, не поддерживающего ООП, пришлось бы создавать три
разных набора процедур управления стеками, присвоив им разные имена. Но в Java благодаря
полиморфизму можно создать один общий набор процедур управления стеками,
который будет действовать по-разному в зависимости от конкретного типа стека. Таким
образом, зная, как работать с одним стеком, можно обращаться со всеми тремя стеками.
Принцип полиморфизма хорошо иллюстрируется следующим выражением: "один
интерфейс - множество методов". Это означает возможность создания универсального
интерфейса для группы взаимосвязанных действий. Полиморфизм упрощает программу
благодаря возможности определить общий класс действий с помощью одного и того же
интерфейса. Выбрать определенное действие (т.е. метод) - задача компилятора, и он
решает ее в зависимости от конкретных условий. Как программисту вам не приходится
выбирать метод вручную. Нужно лишь помнить принципы использования общего интерфейса.
Наследование
Наследование - это процесс, в ходе которого один объект приобретает свойства другого
объекта. Наследование имеет очень большое значение, поскольку с его помощью
поддерживается иерархическая классификация. Если вдуматься, то знания чаще всего
имеют иерархическую структуру. Например, яблоки конкретного сорта относятся
к классу яблок, который в свою очередь относится к классу фруктов, а тот - к более
обширному классу продуктов питания. В данном случае продукты питания обладают
определенными свойствами (они съедобны, калорийны и т.п.). Эти же свойства автоматически
присущи подклассу фруктов. Кроме того, класс фруктов обладает дополнительными
свойствами (сочные, сладкие и т.п.), что отличает его от класса других продуктов
питания. Яблоки имеют более конкретные свойства (растут на деревьях, не являются
тропическими плодами и т.п.) И наконец, отдельный сорт яблок наследует все свойства
описанных выше классов и, кроме того, обладает особыми свойствами, отличающими
его от других сортов яблок.
36 Java 8: руководство для начинающих. 6-е издание
Без такой иерархической структуры для каждого объекта пришлось бы заново определять
весь набор свойств. Благодаря наследованию для объекта достаточно указать те
свойства, которые отличают его от других классов, а остальные общие атрибуты он наследует
от своих родительских классов. Таким образом, благодаря наследованию возможно
создать объект, являющийся экземпляром более общего класса.
Установка комплекта Java Development Kit
Итак, усвоив теоретические основы Java, можно приступать к написанию программ
на Java. Для того чтобы написанную программу можно было скомпилировать и выполнить,
вам нужно установить на своем компьютере комплект Java Development Кit (JDK),
поддерживающий процесс разработки программ на Java. Этот комплект свободно предоставляется
компанией Oracle. На момент написания книги текущей является версия
JDK 8, применяемая на платформе Java SE 8, где SE - аббревиатура от Standard Edition
(стандартный выпуск). Комплект JDK 8 содержит немало новых средств, которые не
поддерживаются в предыдущих версиях Java, и поэтому для компиляции и выполнения
примеров программ, представленных в книге, рекомендуется использовать JDK 8 или
более позднюю версию. В случае использования более ранних версий программы, содержащие
новые средства, не смогут быть скомпилированы.
Комплект JDK можно загрузить по следующему адресу:
http://www.oracle.com/technetwork/java/javase/downloads/index.html
Достаточно перейти на страницу загрузки по указанному адресу и следовать инструкциям
для вашего типа компьютера и операционной системы. После установки JDK вы
сможете компилировать и запускать программы. Среди многих программ, входящих в
состав JDK, вам в первую очередь понадобятся две: javac и j ava. Первая из них - это
компилятор Java, а вторая - стандартный интерпретатор Java, который также называют
модулем запуска приложений.
Следует, однако, иметь в виду, что программы, входящие в состав JDK, запускаются
из командной строки. Они не являются оконными приложениями и не составляют интегрированную
среду разработки (IDE).
ПРИМЕЧАНИЕ
Помимо основных инструментальных средств JDK, доступных из командной строки, для разработки
программ на Java имеются высококачественные интегрированные среды наподобие
NetBeans и Eclipse. Интегрированная среда может оказаться очень удобной для разработки и
развертывания коммерческих приложений. Как правило, в интегрированной среде можно легко
скомпилировать и выполнить примеры программ, представленных в данной книге. Но инструкции
по компиляции и выполнению примеров программ приводятся в книге только для инструментальных
средств JDK, доступных из командной строки. Это сделано по ряду причин. Во-первых,
комплект JDK доступен для всех читателей книги. Во-вторых, инструкции по применению JDK
одинаковы для всех пользователей. А кроме того, простые примеры программ, представленные
в книге, проще всего компилировать и выполнять инструментальными средствами JDK из командной
строки. Если же вы пользуетесь интегрированной средой разработки, то вам придется следовать
ее инструкциям. А в силу отличий, имеющихся у разных интегрированных сред разработки,
дать общие инструкции по компиляции и выполнению программ, написанных на Java, не
представляется возможным.
СПРОСИМ У ЭКСПЕРТА
Глава 1. Основы Java 37
ВОПРОС. Вы утверждаете, что объектно-ориентированное программирование -
эффективный способ управления крупными программами. Но в случае небольших
программ отрицательное влияние накладных расходов, связанных с
применением ООП, на производительность будет, вероятно, относительно более
заметным. Все программы на Java в той или иной степени являются объектно-
ориентированными. Означает ли это, что данный язык неэффективен для
написания небольших программ?
ОТВЕТ. Нет, не означает. Как будет показано далее, даже в случае небольших программ
применение методик ООП почти не сказывается на производительности.
Несмотря на то что язык Java строго придерживается объектной модели,
окончательное решение о том, в какой степени применять его объектно-ориентированные
средства, остается за вами. Для небольших программ объектно-ориентированный
подход вряд ли можно считать целесообразным. Но по мере
того, как сложность ваших программ будет увеличиваться, вы сможете без труда
применять более развитые средства ООП.
Первая программа на Java
Начнем с компиляции и запуска простой программы.
/*
Это пример простой программы на Java.
Присвойте файлу с исходным кодом имя Example.java.
*/
class Example
// Выполнение любой программы на Java начинается
// с вызова метода maiп()
puЫic static void maiп(Striпg args[]) {
System.out.priпtln{"Java правит Интернетом!");
Итак, вам предстоит выполнить следуюшие действия:
1) ввести исходный код программы';
2) скомпилировать программу;
З) запустить программу на выполнение.
Ввод исходного кода программ
Исходные коды примеров программ, представленных в книге, доступны для загрузки
на сайте книги, адрес которого был указан во введении, но при желании можно вводить
код вручную. В таком случае следует использовать обычные текстовые редакторы, а не
I Для корректного отображения русских букв в окне командной строки Windows исходные файлы
должны быть набраны в текстовом редакторе с кодировкой русских букв, принятой в системе
MS-DOS (СР866). - Примеч. ред.
38 Java 8: руководство для начинающих. 6-е издание
текстовые процессоры вроде \\Ьrd, записывающие в файл не только текст, но и данные
о его форматировании, которые будут восприняты компилятором как недопустимые
языковые конструкции. Если вы работаете на платформе Windows, вам вполне подоЙДет
\\ЬrdPad или другой простой текстовый редактор.
В большинстве языков программирования допускается присваивать произвольное
имя файлу, содержащему исходный код программы. Но в Java действуют иные правила.
Для программирования на Java следует знать, что имя исходного файла играет очень
важную роль. В рассматриваемом здесь примере файлу, содержащему исходный код программы,
нужно присвоить имя Example. j ava. Ниже поясняются причины, по которым
выбирается именно такое имя файла.
В Java файл с исходным кодом формально называется единицей компиляции. Это
текстовый файл, содержащий определения одного или нескольких классов. (Исходные
файлы первых примеров программ будут содержать только один класс.) Компилятор
Java требует, чтобы исходный файл имел расширение . j ava. Анализируя исходный
код первого примера программы, вы заметите, что класс называется Example. И это не
случайно. В программах на Java весь код должен находиться внутри класса. Согласно
принятым соглашениям имя файла, содержащего исходный текст программы, должно
совпадать с именем класса. Нетрудно убедиться, что имя файла в точности соответствует
имени класса вплоть до регистра. Дело в том, что в Java имена и друтие идентификаторы
зависят от регистра символов. На первый взгляд, условие соответствия имен классов и
файлов может показаться слишком строгим, но оно упрощает организацию и сопровождение
программ, как станет ясно из последующих примеров.
Компиляция программы
Для компиляции программы Example запустите компилятор javac, указав в командной
строке имя исходного файла:
C:\>javac Example.java
Компилятор javac создаст файл Example. class, содержащий байт-код программы.
Напомним, что байт-код не является исполняемым, но интерпретируется виртуальной
машиной Java. Таким образом, результат компиляции в javac нельзя запускать на выполнение
непосредственно.
Для запуска скомпилированной программы следует воспользоваться интерпретатором
java. В качестве параметра ему нужно передать имя класса Example в командной
строке:
C:\>java Example
В результате выполнения программы на экран будет выведена следующая строка:
Java правит Интернетом!
При компиляции исходного кода Java каждый класс помещается в отдельный выходной
файл, называемый по имени класса и получающий расширение . class. Именно по
этой причине и выдвигается требование, чтобы имя исходного файла программы на Java
в точности соответствовало имени содержащегося в нем класса, а по существу - имени
файла с расширением .class. При вызове интерпретатора Java ему передается имя
класса, предназначенного для выполнения (пример такого вызова приведен выше). В результате
интерпретатор автоматически находит файл с указанным именем и расширением
. class. Обнаружив этот файл, интерпретатор выполняет код, указанный в классе.
ПРИМЕЧАНИЕ
Глава 1 . Основы Java 39
Если при попытке скомпилировать программу компилятор j avac не будет найден, вам придется
указать полный путь к инструментальным средствам JDK, доступным из командной строки, при
условии, что комплект JDK установлен правильно. В Windows это, например, означает, что вам
нужно ввести путь к доступным из командной строки инструментальным средствам JDK, указанный
в переменной среды РАТН. Так, если комплект JDK 8 установлен в выбираемых по умолчанию
каталогах, путь к его инструментальным средствам будет следующим: С: \Program Files \
Java \ j dkl. 8. О \Ьin. (Разумеется, если комплект JDK 8 установлен в другом каталоге или вы
используете другую его версию, этот путь надо будет изменить.) Чтобы узнать, как задавать путь
к файлам, обратитесь к справочной системе конкретной операционной системы, поскольку в
разных операционных системах эта процедура может отличаться.
Построчный анализ исходного кода
первого примера программы
Несмотря на то что программа Example. j ava очень проста и объем ее кода невелик,
она обладает рядом свойств, общих для всех программ на Java. Проанализируем эту программу
по частям.
Ее исходный код начинается так.
/*
Это пример простой программы на Java.
Присвойте файлу с исходным кодом имя Example.java.
*/
Это комментарии. Как и в большинстве других языков программирования, в Java
разрешается комментировать исходный текст программы. Комментарии игнорируются
компилятором. Текст комментариев содержит описание работы программы, предназначенное
для тех, кто будет просматривать ее исходный код. В данном случае комментарии
сообщают, что программа проста, а ее исходному файлу следует присвоить имя
Example. j ava. Очевидно, что в реальных приложениях комментарии описывают, какие
именно функции выполняют отдельные фрагменты программы или зачем используются
те или иные языковые конструкции.
В Java поддерживаются три вида комментариев. Первый из них приведен в начале
рассматриваемой здесь программы и позволяет задавать многострочные комментарии.
Они начинаются символами / * и оканчиваются символами * /. Любое содержимое, находящееся
меЖду этими ограничителями, игнорируется компилятором.
Далее следует такая строка кода:
class Example (
В ней присутствует ключевое слово class, с помощью которого определяется новый
класс. Как упоминалось ранее, класс является основной языковой конструкцией
Java, поддерживающей инкапсуляцию, и Example - это имя класса. Определение
класса начинается открывающей фигурной скобкой ( {) и заканчивается закрывающей
фигурной скобкой (} ). Элементы, находящиеся меЖду ними, являются членами класса.
Не пытайтесь пока что разобраться в особенностях классов, но имейте в виду, что
любой код, какие бы действия он ни выполнял, находится внутри класса. Такая организация
свидетельствует о том, что любая программа на Java ямяется в той или иной мере
объектно-ориентированной.
40 Java 8: руководство для начинающих. 6-е издание
Следующая строка кода содержит однострочные комментарии.
// Выполнение любой программы на Java начинается
// с вызова метода main()
Эrо второй вид комментариев, поддерживаемых в Java. Однострочные комментарии начинаются
с символов / / и продолжаются до конца строки. Как правило, многострочные
комментарии служат для длинных примечаний, а однострочные - для коротких заметок.
Следующая анализируемая строка кода выглядит так:
puЫic static void main (String args []) {
В этой строке определяется метод main (). Как упоминалось ранее, в терминологии
Java подпрограммы принято называть методами. Именно с данной строки начинается
работа программы, и приведенные выше комментарии подтверждают это. Выполнение
любой прикладной программы на Java начинается с вызова метода main (). Мы не будем
пока что касаться назначения каждого элемента анализируемой строки кода. Ведь
для этого нужно сначала рассмотреть ряд других языковых средств Java. Но поскольку
многие примеры программ, представленные в книге, содержат строку с подобным определением
метода main () , рассмотрим вкратце ее составные части.
Ключевое слово puЫic называется модификатором доступа. Модификатор доступа
определяет правила обращения к членам класса из других частей программы. Если
член класса предваряется ключевым словом puЫic, то к нему можно обращаться за
пределами класса. (В отличие от puЫic, модификатор доступа private запрещает
доступ к членам класса за его пределами.) В данном случае метод main () должен быть
объявлен как puЫic, поскольку при выполнении программы он вызывается за пределами
своего класса. Ключевое слово static допускает вызов метода main () до создания
объекта класса. Указывать его необходимо, поскольку метод main () вызывается
виртуальной машиной еще до того, как будут созданы какие-либо объекты. Ключевое
слово void лишь сообщает компилятору о том, что метод main () не возвращает значение.
Как будет показано далее, для некоторых методов предусматривается возвращаемое
значение. Если вам пока еще не все понятно в анализируемой строке кода, не
отчаивайтесь. Упомянутые здесь языковые средства Java будут подробно рассмотрены
в последующих главах.
Как упоминалось выше, метод main () вызывается в начале выполнения программы
на Java. Любые данные, которые требуется передать этому методу, задаются с помощью
переменных, указываемых в круглых скобках после имени метода. Эти переменные называются
параметрами. Если для какого-нибудь метода параметры не предусмотрены,
то после его имени указывается лишь пара круглых скобок. В данном случае для метода
main () под именем args задается единственный параметр String args []. Это массив
объектов типа String. (Массивы представляют собой наборы однотипных объектов.)
В объектах типа String хранятся последовательности символов. В данном случае в массиве
args методу main () передаются в виде аргументов параметры, указываемые в командной
строке при запуске программы. В анализируемой здесь программе данные, получаемые
из командной строки, не используются, но в других примерах программ будет
показано, каким образом можно обработать эти данные.
И завершается анализируемая строка кода символом {. Этот символ обозначает начало
тела метода main (). Весь код, содержащийся в методе, располагается между открывающей
и закрывающей фигурными скобками.
Глава 1 . Основы Java 41
Очередная анализируемая строка кода приведена ниже. Обратите внимание на то,
что она содержится в методе main ().
System.out.println("Java правит Интернетом!");
В этой строке кода на экран сначала выводится символьная строка "Java правит
Интернетом! ", а затем происходит переход на новую строку. Вывод на экран осуществляется
встроенным методом println (). В данном случае метод println () выводит на
экран переданную ему символьную строку. Как будет показано далее, с помощью метода
println () можно выводить на экран не только символьные строки, но и данные других
типов. Анализируемая строка кода начинается с имен System. out. В настоящий момент
объяснить их назначение нелегко, поэтому достаточно будет сказать, что System - это
предопределенный класс, предоставляющий доступ к системным ресурсам, а out - поток
вывода на консоль. Таким образом, System. out - это объект, инкапсулирующий
вывод на консоль. Тот факт, что для определения консоли в Java используется объект,
лишний раз свидетельствует об объектно-ориентированном характере этого языка.
Как вы, вероятно, уже догадались, в реальных программах и аrшетах Java вывод на
консоль (как, впрочем, и ввод с консоли) используется очень редко. Современные вычислительные
среды, как правило, имеют оконный и графический характер, и поэтому
обмен данными с консолью применяется лишь в простых служебных и демонстрационных
программах. Далее будут рассмотрены другие способы формирования выходных
данных средствами Java, а пока ограничимся использованием методов ввода-вывода на
консоль в представленных примерах программ.
Обратите внимание на то, что оператор, содержащий вызов метода println () , оканчивается
точкой с запятой. Этим символом завершаются все операторы в Java. В других
строках кода точка с запятой отсутствует лишь потому, что они формально не являются
операторами.
Первая закрывающая фигурная скобка завершает метод main (), а вторая такая же
скобка указывает на окончание определения класса Example.
И последнее замечание: в Java учитывается регистр символов. Игнорирование этого
правила влечет за собой серьезные осложнения. Так, если вместо main вы случайно наберете
Main, а вместо println - PrintLn, исходный код программы окажется некорректным.
И хотя компилятор Java скомпилирует классы, не содержащие метод main () , у
него не окажется средств для их выполнения. Следовательно, если вы допустите ошибку
в имени main, компилятор скомпилирует программу и не сообщит об ошибке. Но о ней
вас уведомит интерпретатор, когда не сумеет обнаружить метод main ().
Обработка синтаксических ошибок
Введите текст рассмотренной выше программы, скомпилируйте и запустите ее (если
вы не сделали этого раньше). Если у вас имеется определенный опыт программирования,
то вам, безусловно, известно, что никто не гарантирован от ошибок при наборе
исходного кода программы, а также о том, насколько легко допустить такие ошибки.
Если вы наберете исходный код программы неправильно, то компилятор, пытаясь обработать
этот код, выведет сообщение об ошибке. Компилятор Java следует формальным
правилам, и поэтому строка в исходном коде, на которую он указывает, не всегда соответствует
истинному местоположению источника ошибки. Допустим, в рассмотренной
ранее программе вы забыли ввести открывающую фигурную скобку после метода
main (). В таком случае компилятор сообщит вам о следующих ошибках.
42 Java 8: руководство для начинающих. 6-е издание
Example. java: 8: ';' expected
puЫic static void main(String args[J)
Example.java:11: class, interface, or enum expected
)
Очевидно, что первое сообщение не соответствует действительности: пропущена не
точка с запятой, а фигурная скобка.
Таким образом, если ваша программа содержит синтаксические ошибки, не стоит
бездумно следовать рекомендациям компилятора. Сообщение об ошибке составляется
по формальным правилам, а вы должны выяснять истинные причины ошибок. Желательно
проанализировать строки кода программы, предшествующие строке, обозначенной
компилятором. Иногда ошибку удается распознать лишь после анализа нескольких
строк кода, следующих за той, в которой она бьmа на самом деле обнаружена.
Еще одна простая программа
Вероятно, наиболее распространенной конструкцией в любом языке программирования
является оператор присваивания значения переменной. Переменная - это именованная
ячейка памяти, в которой можно хранить присваиваемое значение. В процессе
выполнения программы значение переменной может изменяться. Это означает, что содержимое
переменной не фиксировано. В приведенной ниже программе используются
две переменные: varl и var2.
/*
Демонстрация использования переменных.
Присвойте файлу с исходным кодом имя Example2.java.
*/
class Example2 {
puЬlic static void main(String args[J) {
int varl; // объявляется переменная '4-------Объявпенне переменных
int var2; // объявляется еще одна переменная
varl = 1024; // переменной varl присваивается значение 1024 􀂼4-----1
System.out.println("Пepeмeннaя varl содержит " + varl);
var2 = varl / 2;
System.out.print("Пepeмeннaя var2 содержит varl / 2: ");
System.out.println(var2);
Запустив программу, вы получите следующий результат.
Переменная varl содержит 1024
Переменная var2 содержит varl / 2: 512
Прнсванванне
значения
переменной
Глава 1. Основы Java 43
В этой программе предстамен ряд новых понятий. Сначала в следующем операторе
объямяется переменная varl целочисленного типа:
int varl; // объявляется переменная
В Java каждая переменная должна быть объявлена перед ее использованием. При
объявлении переменной задается ее тип, т.е. тип данных, которые могут в ней содержаться.
В данном случае переменная varl может содержать целочисленные значения.
Для этой цели при объямении переменной перед ее именем указывается ключевое слово
int. Таким образом, в приведенной выше строке кода объямяется переменная varl
типа int.
В следующей строке кода объявляется вторая переменная var2:
int var2; // объявляется еще одна переменная
Как видите, в этой строке кода используется та же самая форма объямения переменной,
что и в предыдущей. Отличаются они лишь именем переменной.
Общая форма инструкции объямения переменной выглядит следующим образом:
тип имя_переменной;
где тип обозначает конкретный тип объямяемой переменной, а имя_ переменной - ее
наименование. Помимо int, в Java поддерживаются и другие типы данных.
В следующей строке кода переменной varl присваивается значение 1024:
varl = 1024; // переменной varl присваивается значение 1024
В Java оператор присваивания обозначается знаком равенства. Он копирует значение,
находящееся справа от него, в переменную, указанную слева.
В следующей строке кода значение переменной varl выводится на экран после символьной
строки "Переменная varl содержит":
System.out.println("Пepeмeннaя varl содержит " + varl);
В этом операторе знак + указывает на то, что после символьной строки должно быть
выведено значение переменной varl. Это правило имеет общий смысл. Знаком+ можно
объединить несколько элементов в одной инструкции, передав их в качестве параметра
методу println ().
В следующей строке кода переменной var2 присваивается значение переменной
varl, разделенное на 2:
var2 = varl / 2;
После выполнения этого кода переменная var2 будет содержать значение 512, тогда
как значение переменной varl останется без изменения. Как и в большинстве других
языков программирования, в Java поддерживаются арифметические операции, в том
числе и перечисленные ниже.
+ Сложение
Вычитание
*
Умножение
/ Деление
44 Java 8: руководство для начинающих, 6-е издание
Рассмотрим следующие две строки кода.
Systern.out.print("Пepeмeннaя var2 содержит varl / 2: ");
Systern.out.println(var2);
В первой из них вызывается метод print (), выводящий строку "var2 содержит
varl / 2:" без последующего символа перевода строки. Это означает, что очередные
данные будут отображены в той же строке. Метод print () действует аналогично методу
println (), за исключением того, что его выполнение не завершается переходом на следующую
строку. Во второй строке методу println () в качестве параметра передается
переменная var2. С помощью обоих методов, print () и println (), можно выводить
на экран значения любого встроенного в Java типа данных.
Прежде чем переходить к изучению других аспектов Java, необходимо обратить внимание
на следующую особенность: в одном операторе можно объявить две и более переменных.
Для этого достаточно разделить их имена запятыми. Например, переменные
varl и var2 можно объявить так:
int varl, var2; // обе переменные объявляются в одном операторе
Другие типы данных
В предыдущем примере программы были использованы переменные типа int. Но
они могут содержать только целые числа и не пригодны для хранения дробной части.
Так, переменная типа int может содержать значение 18, но не 18. 3. Но int - это лишь
один из нескольких типов данных, определенных в Java. Для хранения чисел, содержащих
дробную часть, в Java предусмотрены типы с плавающей точкой, floa t и douЫe,
которые представляют значения с одинарной и двойной точностью соответственно. Тип
douЫe используется чаще, чем float.
Для объявления переменной типа douЫe следует использовать инструкцию, аналогичную
следующей:
douЫe х;
где х обозначает имя переменной типа douЫe. А поскольку х объявлена как переменная
с плавающей точкой, в ней можно хранить значения 122. 23, О. 034, -19. О и т.п.
Для того чтобы стали понятнее различия между типами int и douЫe, рассмотрим
следующую программу.
/*
Демонстрация различий между типами int и douЫe.
Присвойте файлу с исходным кодом имя ExarnpleЗ.java.
*/
class ExarnpleЗ {
puЫic static void rnain(String args[]) {
int var; // объявить целочисленную переменную
douЫe х; // объявить переменную с плавающей точкой
var = 10; // присвоить переменной var значение 10
х = 10.0; // присвоить переменной х значение 10.О
Глава 1 . Основы Java 45
System.out.println("Haчaльнoe значение переменной var: " + var);
System.out.println("Haчaльнoe значение переменной х: " + х);
System. out. println (); / /вывести пустую строку Вывод пустой строки
// Разделить значения обеих переменных на 4
var var / 4;
х = х / 4;
System.out.println("Знaчeниe переменной var после деления: " +
var);
System.out.println("Знaчeниe переменной х после деления: " + х);
Выполнение данной программы дает следующий результат.
Начальное значение переменной var: 10
Начальное значение переменной х: 10.0
Значение переменной var после деления: 2
Значение переменной х после деления: 2.5
-------Дробно• часть чисnа тер•етс•
-------Дробна• часть чнсnа сохрон,етс•
Как видите, при делении значения переменной var на 4 результат получается дробным,
и программа выводит числовое значение 2, а дробная его часть теряется. В то же
время при делении на 4 значения переменной х дробная часть ее числового значения
сохраняется, и программа отображает правильный результат.
В этой программе показан еще один прием. Для вывода пустой строки на экран достаточно
вызвать метод println () без параметров.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Почему для хранения целых и дробных значений используются разные
типы? Не проще ли создать один универсальный тип для всех числовых
значений?
ОТВЕТ. Для написания эффективных программ предусмотрены разные типы данных
. Например, целочисленные вычисления производятся быстрее, чем вычисления
с плавающей точкой. Следовательно, если вы не пользуетесь дробными
значениями, то лишние накладные расходы, связанные с обработкой
содержимого переменной float или douЫe, вам ни к чему. Кроме того, для
хранения переменных разных типов требуется разный объем памяти. Предоставляя
разработчику возможность выбора типов данных, Java создает благоприятные
условия для оптимального использования системных ресурсов.
И наконец, для некоторых алгоритмов требуются конкретные типы данных
(во всяком случае, они работают с ними более эффективно). Вообще говоря,
разные встроенные типы предусмотрены в Java для обеспечения большей гибкости
программирования.
46 Java 8: руководство для начинающих. 6-е издание
Упражнение 1 .1 Преобразование rаллонов в литры
Предыдущие примеры программ иллюстрируют некоторые важные
особенности языка программирования Java, но они вряд ли
применимы на практике. Несмотря на то что ваши знания Java
пока еще весьма ограничены, вам вполне по силам написать программу, выполняющую
нечто полезное, в частности, преобразование галлонов в литры.
В этой программе объявляются две переменные типа douЫe. Одна из них соответствует
объему жидкости в галлонах, а вторая - тому же самому объему, но выраженному
в литрах. В галлоне содержится 3, 7854 литра. Поэтому для преобразования галлонов
в литры следует умножить число галлонов на 3,7854. В результате выполнения данной
программы объем жидкости отображается как в галлонах, так и в литрах. Поэтапное
описание процесса создания программы приведено ниже.
1. Создайте новый файл Gal ToLi t. j ava.
2. Сохраните в этом файле следующий код программы.
/*
Упражнение 1.1
Программа перевода галлонов в литры.
Присвойте файлу с исходным кодом имя GalToLit.java.
*/
class GalToLit {
puЫic static void main{String args[]) {
douЫe gallons; // в этой переменной хранится значение,
// выражающее объем жидкости в галлонах
douЫe liters; // в этой переменной хранится значение,
// выражающее объем жидкости в литрах
gallons = 10; // начальное значение соответствует 10 галлонам
liters = gallons * 3.7854; // перевести в литры
System.out.println(gallons + " галлонам соответствует " +
liters + " литров");
3. Скомпилируйте программу, введя в командной строке следующую команду:
C>javac GalToLit.java
4. Запустите программу на выполнение, введя следующую команду:
C>java GalToLit
Результат выполнения данной программы выглядит следующим образом:
10.0 галлонам соответствует 37.854 литра
5. Данная программа преобразует в литры только одно значение объема жидкости,
равное десяти галлонам. Изменив значение переменной gallons, выражающее
объем жидкости в галлонах, вы получите другое результирующее значение, выражающее
объем жидкости в литрах.
Два управляющих оператора
Глава l . Основы Java 47
Операторы в методе выполняются последовательно сверху вниз. Но этот порядок
можно изменить, воспользовавшись управляющими операторами, предусмотренными
в Java. Подробнее об управляющих операторах речь поЙдет далее, а пока ограничимся
кратким рассмотрением двух таких операторов. Они будут использованы при написании
примеров программ.
Оператор if
Используя условный оператор i f, можно выборочно выполнять отдельные части
программы. В Java этот оператор действует таким же образом, как и оператор i f из любого
другого языка программирования. Ниже приведена простейшая форма оператора i f:
if (условие) оператор;
где условие обозначает логическое выражение. Если условие истинно (принимает логическое
значение true), оператор выполняется. А если условие ложно (принимает
логическое значение false), то оператор не выполняется. Ниже приведен простой
пример применения оператора if в коде.
if(lO < 11) System.out.println("lO меньше 11");
В данном примере числовое значение 1 О меньше 11, и поэтому условное выражение
принимает логическое значение true, в результате чего выполняется метод println ().
Рассмотрим еще один пример с противоположным условием:
if(lO < 9) System.out.println("Этa строка не отобразится");
В данном случае условие" 10 меньше 9" не выполняется, поэтому метод println ()
не вызывается и на экран ничего не выводится.
В Java определен полный набор операций сравнения, которые могут быть использованы
при составлении условных выражений. Эти операции перечислены ниже.
Операция Значение
< Меньше
<= Меньше или равно
> Больше
>= Больше или равно
Равно
!= Неравно
Обратите внимание на то, что для проверки на равенство следует указать два знака
равенства.
Ниже приведен пример программы, демонстрирующий применение оператора if.
/*
Демонстрация применения оператора if.
Присвойте файлу с исходным кодом имя IfDemo.java.
48 Java 8: руководство для начинающих. 6-е издание
*/
class IfDemo {
puЫic static void main (String args []) {
int а, Ь, с;
а = 2;
ь = З;
if(a < Ь) System.out.println("a меньше Ь");
// Следующая строка никогда не может быть выведена
if(a == Ь) System.out.println("Bы не должны увидеть этот текст");
System.out.println();
с = а - Ь; // переменная "с" содержит значение -1
System.out.println("c содержит -1");
if(c >= О) System.out.println("c - не отрицательное число");
if(c < О) System.out.println("c - отрицательное число");
System.out.println();
с = Ь - а; // переменная "с" теперь содержит значение 1
System.out.println("c содержит 1");
if(c >= О) System.out.println("c - не отрицательное число");
if(c < О) System.out.println("c - отрицательное число");
Ниже приведен результат выполнения данной программы.
а меньше Ь
с содержит -1
с - отрицательное число
с содержит 1
с - не отрицательное число
Обратите внимание еще на одну особенность данной программы. В следующей строке
объявляются три переменные, а, Ь и с, имена которых разделяются запятыми:
int а, Ь, с;
Как ранее уже упоминалось, если требуется несколько переменных одного типа, их
можно объявить в одной инструкции. Для этого имена переменных следует разделить
запятыми.
Цикл for
Циклы позволяют многократно выполнять наборы инструкций. В Java для этой цели
предусмотрен целый ряд эффективных конструкций циклов. Рассмотрим для начала
цикл for. Ниже приведена простейшая форма цикла for:
fоr(инициализация; условие; итерация) оператор;
Глава 1 . Основы Java 49
В самой общей форме исходное значение переменной цикла задается в части инициализация,
а в части условие - логическое выражение, которое, как правило, проверяет
значение переменной цикла. Если логическое выражение принимает значение
true, цикл for продолжает выполняться. А если оно принимает значение false, то
цикл прекращается. И наконец, в части итерация задается порядок изменения переменной
цикла на каждой итерации. Ниже приведен пример простой программы, демонстрирующий
применение цикла for.
/*
Демонстрация применения цикла for.
Присвойте файлу с исходным кодом имя ForDemo.java.
*/
class ForDemo {
puЫic static void main(String args[]) {
int count;
for(count = О; count < 5; count = count+l) -------Этот цнкя выnоnняет
System.out.println("Знaчeниe счетчика: " + count); nsm, итераций
System.out.println("Гoтoвo!");
Ниже приведен результат выполнения данной программы.
Значение счетчика: о
Значение счетчика: 1
Значение счетчика: 2
Значение счетчика: з
Значение счетчика: 4
Готово!
В данном примере count - это переменная цикла. При инициализации ей присваивается
значение О. В начале каЖдоrо шага цикла (включая и первый) проверяется условие
count < 5. Если это условное выражение принимает логическое значение true,
вызывается метод println (), после чего выполняется итерационная часть цикла. Данная
последовательность действий повторяется до тех пор, пока условное выражение не
примет логическое значение false. В этом случае управление передается следующему
после цикла оператору.
Следует иметь в виду, что в профессионально написанных программах очень редко
можно встретить итерационную часть цикла, написанную так, как это сделано в приведенном
выше примере программы:
count = count + 1;
Дело в том, что в Java имеется специальный и более эффективный оператор инкремента,
который обозначается двумя знаками "плюс" ( ++) без пробела между ними. В результате
выполнения этою оператора значение операнда увеличивается на единицу. Используя
оператор инкремента, предьщущее итерационное выражение можно переписать
следующим образом:
count++;
50 Java 8: руководство для начинающих. 6-е издание
Следовательно, оператор цикла for из предыдущего примера программы можно переписать
так:
for(count = О; count < 5; count++)
Попробуйте внести это изменение в рассматриваемый здесь цикл, и вы увидите, что
результаты выполнения программы останутся прежними.
В Java предусмотрен также оператор декремента, обозначаемый двумя знаками "минус"
(--) без пробела между ними. При выполнении этого оператора значение операнда
уменьшается на единицу.
Создание блоков кода
Еще одним ключевым элементом Java является блок кода. Он представляет собой
группу инструкций, помещенных между открывающей и закрывающей фигурными
скобками. Созданный блок кода становится единым логическим блоком и может использоваться
в любом месте программы, как одиночная инструкция. В частности, такой
блок можно использовать в качестве тела операторов if и for. Рассмотрим следующий
пример применения блоков в операторе i f.
if(w < h) -------Ночоnо бnоко
v w * h;
w = О;
-------Конец бnоко
В данном примере обе инструкции в блоке выполняются в том случае, если значение
переменной w меньше значения переменной h. Эти инструкции составляют единый логический
блок, и ни одна из них не может быть выполнена без другой. Таким образом,
для объединения нескольких выражений в единое логическое целое нужно создать блок
кода. Блоки позволяют оформлять многие алгоритмы в удобном для восприятия виде.
Ниже приведен пример программы, в которой блок кода используется для того, чтобы
предотвратить деление на нуль.
/*
Демонстрация применения блоков кода.
Присвойте файлу с исходным кодом имя BlockDemo.java
*/
class BlockDemo {
puЫic static void main(String args[J) {
douЫe i, j, d;
i 5;
j 10;
// Телом этого оператора if является целый блок кода.
if(i != О) {
System.out.println("i не равно нулю");
d = j / i; 􀁖 Теnом оператора i f
. , d
явnяется весь бnок System.out.print("j / i равно '+ );
Глава 1 . Основы Java 51
Результат выполнения данной программы выглядит следующим образом.
i не равно нулю
j / i равно 2.0
В данном примере телом оператора if служит не один оператор, а целый блок кода.
Если условие, управляющее оператором if, принимает логическое значение true, как в
данном случае, то выполняются все три инструкции, образующие блок. Попробуйте присвоить
переменной i нулевое значение и запустить программу, и вы увидите, что ни один
из операторов из кодового блока не будет выполнен, т.е. весь этот блок будет пропущен.
Как будет показано далее, блоки обладают также другими свойствами и находят иное
применение. Но главное их назначение - создание логически неделимых единиц кода.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Приводит ли использование блоков кода к снижению эффективности
программы? Иными словами, выполняются ли какие-то дополнительные действия,
когда в коде Java встречаются символы { и } ?
ОТВЕТ. Нет. Использование блоков кода не влечет за собой никаких дополнительных
издержек. Более того, блоки повышают быстродействие, поскольку они
упрощают код и позволяют создавать более эффективные алгоритмы. Символы
{ и } существуют только в исходном коде программы, но не подразумевают выполнение
каких-то дополнительных действий.
Использование точки с запятой в коде программы
В Java точка с запятой служит в качестве разделителя инструкций. Это означает, что
каждая инструкция должна оканчиваться точкой с запятой. Точка с запятой обозначает
окончание одной логически завершенной единицы кода.
Как вы уже знаете, блок кода - это совокупность логически связанных инструкций,
помещаемых между открывающей и закрывающей фигурными скобками. Блок не завершается
точкой с запятой. Он представляет собой группу инструкций, и поэтому точка с
запятой ставится в конце каждой инструкции, а сам блок завершается лишь закрывающей
фигурной скобкой.
В Java конец строки не считается окончанием оператора. Поэтому не имеет значения,
где именно он находится в строке кода. Например, в Java следующие строки кода:
х = у;
у = у + 1;
System.out.println(x + " " + у);
означают то же самое, что и такие строка кода:
х = у; у= у + 1; System.out.println(x + " " + у);
Более того, каждый элемент оператора можно разместить в отдельной строке.
Например, следующая запись вполне допустима.
System.out.println("Этo длинная выходная строка" +
х + у + z +
"дополнительный вывод");
52 Java 8: руководство для начинающих. 6-е издание
Перенос на новую строку позволяет избегать длинных строк и делать код программы
удобочитаемым. Кроме того, разбивая оператор на несколько строк, вы предотвращаете
автоматический перенос, который зачастую портит внешний вид исходного текста программы.
Стилевое оформление текста
программ с помощью отступов
Вы, вероятно, заметили, что некоторые операторы в предыдущих примерах программ
располагаются с отступом от начала строки. В Java допускается произвольное оформление
исходного кода, а это означает, что расположение операторов относительно друг друга не
имеет особого значения. Но как показывает опыт программирования, располагая некоторые
операторы с отступом от начала строки, можно сделать исходный текст программы
более удобным для восприятия. В этой книге широко применяются отступы. Внимательно
проанализировав представленные в ней примеры программ, вы, скорее всего, согласитесь,
что подобный стиль представления исходного кода вполне оправдан. Так, операторы,
заключенные в фигурные скобки, желательно располагать с отступом. А некоторым
операторам требуется дополнительный отступ. Подробнее об этом речь пойдет далее.
Упражнение 1 .2 Усовершенствованная версия проrраммы
дnя преобразования rannoнoв в литры
гG·􀀓·;:т·􀀔r:i􀀕-т􀀖·ьi·􀀗·:·j·􀀘·;􀀘······, в рассматриваемой здесь усовершенствованной версии про-
, .................................................... , граммы, переводящей галлоны в литры и созданной в рам-
ках первого проекта, используются цикл for, условный оператор if и блоки кода. В новой
версии программы на экран выводится таблица перевода для значений от l до l 00
(в галлонах). После каждых десяти значений отображается пустая строка. Это достигается
благодаря переменной counter, которая подсчитывает число выведенных строк. Обратите
внимание на особенности применения данной переменной. Поэтапное описание
процесса создания программы приведено ниже.
1. Создайте новый файл Gal ToLi tТаЫе. j ava.
2. Сохраните в этом файле следующий код программы.
/*
Упражнение 1.2
Эта программа отображает таблицу перевода галлонов в литры.
Присвойте файлу с исходным кодом имя GalToLitTaЬle.java.
*/
class GalToLitTaЬle
puЫic static void rnain (String args []) {
douЫe gallons, liters;
int counter;
counter = О; Счетчик строк ииициаnизируется иуnевым значением
for(gallons = 1; gallons <= 100; gallons++) {
liters = gallons * 3.7854; // преобразовать в литры
Systern.out.println(gallons + " галлонам соответствует " +
liters + " liters.");
Глава 1. Основы Java 53
counter++; .. Уаеnнчнвать значение счетчика строк на 1 на каждой нтерацнн цнкпа
if (counter == 10) { ..--есnн значение счетчика равно 10, аwаестн пустую строку
System.out.println();
counter = О; // сбросить счетчик строк
3. Скомпилируйте программу, введя в командной строке следующую команду:
C>javac GalToLitTaЫe.java
4. Запустите программу, введя в командной строке следующую команду:
C>java GalToLitTaЬle
В результате выполнения данной программы на экран будет выведен следующий
результат.
1.0 галлонам соответствует 3.7854 литра
2.0 галлонам соответствует 7.5708 литра
3.0 галлонам соответствует 11.356200000000001 литра
4.0 галлонам соответствует 15.1416 литра
5.0 галлонам соответствует 18.927 литра
6.0 галлонам соответствует 22.712400000000002 литра
7.0 галлонам соответствует 26.4978 литра
в.о галлонам соответствует 30.2832 литра
9.0 галлонам соответствует 34.0686 литра
10.0 галлонам соответствует 37.854 литра
11. О галлонам соответствует 41.6394 литра
12.0 галлонам соответствует 45.424800000000005 литра
13.0 галлонам соответствует 49.2102 литра
14.0 галлонам соответствует 52.9956 литра
15.0 галлонам соответствует 56.781 литра
16.0 галлонам соответствует 60.5664 литра
17.0 галлонам соответствует 64.3518 литра
18.0 галлонам соответствует 68.1372 литра
19.О галлонам соответствует 71.9226 литра
20.0 галлонам соответствует 75.708 литра
21.0 галлонам соответствует 79.49340000000001 литра
22.0 галлонам соответствует 83.2788 литра
23.0 галлонам соответствует 87.0642 литра
24.0 галлонам соответствует 90.84960000000001 литра
25.0 галлонам соответствует 94.635 литра
26.0 галлонам соответствует 98.4204 литра
27.0 галлонам соответствует 102.2058 литра
28.0 галлонам соответствует 105.9912 литра
29.0 галлонам соответствует 109.7766 литра
30.0 галлонам соответствует 113. 562 литра
54 Java 8: руководство для начинающих, 6-е издание
Ключевые слова Java
В настоящее время в языке Java определено пятьдесят ключевых слов (табл. 1.1). Вместе
с синтаксисом операторов и разделителями они образуют определение языка Java.
Ключевые слова нельзя использовать в качестве имен переменных, классов или методов.
Ключевые слова const и goto зарезервированы, но не используются. На ранних
этапах развития Java для дальнейшего использования бьmи зарезервированы и другие
ключевые слова. Но в текущем определении (так называемой спецификации) Java определены
только те ключевые слова, которые представлены в табл. 1.1.
Помимо ключевых слов, в Java зарезервированы также логические значения true,
false и null. Их нельзя использовать для обозначения переменных, классов и других
элементов программ.
Таблица 1.1. Ключевые слова Java
abstract assert boolean break byte case
catch char class const continue default
do douЫe else enщn extends final
finally float for goto if implements
import instanceof int interface long native
new package private protected puЫic return
short static strictfp super switch synchronized
this throw throws transient try void
volatile while
Идентификаторы в Java
В Java идентификатор обозначает имя метода, переменной или элемента, определяемых
пользователем. Идентификатор может содержать один или несколько символов.
Имя переменной может начинаться с любой буквы, знака подчеркивания (_) или символа
доллара{$). Далее могут следовать буквы, цифры, символы подчеркивания и доллара.
Символ подчеркивания обычно применяется для того, чтобы сделать имя более
удобным для восприятия, например line _ count.
В Java символы нижнего и верхнего регистра различаются, т.е. rnyvar и MyVar - это
имена разных переменных. Ниже приведен ряд примеров допустимых в Java идентификаторов.
Test х у2 MaxLoad
$up top ту_ var sample23
Как упоминалось выше, идентификатор не может начинаться с цифры. Например,
идентификатор 12х недопустим.
В качестве идентификаторов нельзя использовать ключевые слова Java. Для этой
цели нельзя использовать также имена стандартных методов, например println. Эти
ограничения необходимо соблюдать. Кроме того, профессиональный стиль программирования
предполагает употребление информативных имен, отражающих назначение соответствующих
элементов.
Библиотеки классов Java
Глава 1. Основы Java 55
В примерах программ, представленных в этой главе, применяются два встроенных в
Java метода: println () и print (). Эти методы являются членами класса System, который
предопределен в Java и автоматически включается в состав любой программы.
В более широком контексте среда Java включает в себя ряд встроенных библиотек классов,
содержащих большое количество методов. Они обеспечивают поддержку операuий
ввода-вывода, операuий с символьными строками, сетевого взаимодействия и отображения
графики. Стандартные классы также реализуют оконный вывод. Таким образом,
Java представляет собой сочетание собственно языка и стандартных классов. Как станет
ясно в дальнейшем, многими своими функuиональными возможностями язык Java
обязан именно библиотекам классов. Поэтому научиться грамотно программировать на
Java невозможно, не изучая стандартные классы. На протяжении всей книги вам будут
встречаться описания различных классов и методов из стандартных библиотек. Но в одной
книге невозможно описать все библиотеки, поэтому полученные знания основ Java
вам придется пополнить в проuессе самостоятельной работы.
;-􀀂, ..: Bonpoc1,1 .., уnражненця для самопроверки
1. Что такое байт-код и почему он так важен для интернет-программирования на
языке Java?
2. Каковы три ключевых принuипа объектно-ориентированного программирова-
ния?
3. С чего начинается выполнение программы на Java?
4. Что такое переменная?
5. Какое из перечисленных ниже имен переменных недопустимо?
А. count
Б. $count
В. count27
[ 67count
6. Как создаются однострочный и мноrострочный комментарии?
7. Как выглядит общая форма условного оператора i f? Как выглядит общая форма
uикла for?
8. Как создать блок кода?
9. Сила тяжести на Луне составляет около 17% земной. Напишите программу, которая
вычислила бы ваш вес на Луне.
10. Видоизмените программу, созданную в упражнении 1.2, таким образом, чтобы
она выводила таблиuу перевода дюймов в метры. Выведите значения длины до
12 футов через каждый дюйм. После каждых 12 дюймов выведите пустую строку.
(Один метр приблизительно равен 39,37 дюйма.)
11. Если при вводе кода программы вы допустите опечатку, то какого рода сообщение
об ошибке получите?
12. Имеет ли значение, с какой именно позиuии в строке начинается инструкuия?

Глава 2
Введение в типы
данных и операции
над ними
58 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
<t Простые типы данных в Java
IJ!; Использование литералов
'i> Инициализация переменных
о Области действия переменных в методе
􀂉 Арифметические операции
'ili Операции отношения и логические операции
8 Операторы присваивания
• Укороченные операторы присваивания
• Преобразование типов при присваивании
􀂊· Приведение несовместимых типов данных
􀂋 Преобразование типов в выражениях
о снову любого языка программирования составляют типы данных и операторы, и
Java не является исключением из этого правила. Типы данных и операторы определяют
область применимости языка и круг задач, которые можно успешно решать с его
помощью. В Java поддерживаются самые разные типы данных и операторы, что делает
этот язык универсальным и пригодным ддя написания любых программ.
Значение типов данных и операций нельзя недооценивать. Эта глава начинается с
анализа основных типов данных и наиболее часто используемых операций. А кроме
того, в ней будут подробно рассмотрены переменные и выражения.
Особая важность типов данных
В связи с тем, что Java относится к категории строго типизированных языков программирования,
типы данных имеют в нем очень большое значение. В процессе компиляции
проверяются типы операндов во всех операциях. И если в программе встречаются
недопустимые операции, то ее исходный код не преобразуется в байт-код. Контроль типов
позволяет сократить количество ошибок и повысить надежность программы. В отличие
от других языков программирования, где допускается не указывать типы данных,
хранящихся в переменных, в Java все переменные, выражения и значения строго контролируются
на соответствие типов данных. Более того, тип переменной определяет,
какие именно операции могут быть выполнены над ней. Операции, разрешенные ддя
одного типа данных, могут оказаться недопустимы ддя другого.
Элементарные типы данных Java
Встроенные типы данных в Java разделяются на две категории: объектно-ориентированные
и необъектно-ориентированные. Объектно-ориентированные типы данных
Глава 2. Введение в типы данных и операции над ними 59
определяются в классах, о которых речь поЙДет далее. В основу языка Java положено
восемь элементарных типов данных, приведенных в табл. 2.1 (их также называют примитивными
или простыми). Термин элементарные указывает на то, что эти типы данных
являются не объектами, а обычными двоичными значениями. Такие типы данных
предусмотрены в языке для того, чтобы увеличить эффективность работы программ. Все
остальные типы данных Java образуются на основе элементарных типов.
В Java четко определены области действия элементарных типов и диапазон допустимых
значений для них. Эти правила должны соблюдаться при создании всех виртуальных
машин. А поскольку программы на Java должны быть переносимыми, точное
следование этим правилам является одним из основных требований языка. Например,
тип int остается неизменным в любой исполняющей среде, благодаря чему удается
обеспечить реальную переносимость программ. Это означает, что при переходе с одной
платформы на другую не приходится переписывать код. И хотя строгий контроль типов
может привести к незначительному снижению производительности в некоторых исполняющих
средах, он является обязательным условием переносимости программ.
Таблица 2.1. Встроенные элементарные типы Java
Тип
boolean
byte
char
douЫe
float
int
long
short
Описание
Представляет логические значения true и false
8-разрядное целое число
Символ
Числовое значение с плавающей точкой двойной точности
Числовое значение с плавающей точкой одинарной точности
Целое число
Длинное целое число
Короткое число
Целочисленные типы данных
В Java определены четыре целочисленных типа данных: byte, short, int и long.
Их краткое описание приведено ниже.
Тип Разрядность, бит Диапазон допустимых значений
byte
short
int
long
8
16
32
64
ОТ -128 ДО 127
ОТ -32,768 ДО 32,767
ОТ -2, 147,483,648 ДО 2, 147,483,647
ОТ -9,223,372,036,854,775,808 ДО 9,223,372,036,854,775,807
Как следует из приведенной выше таблицы, целочисленные типы данных предполагают
как положительные, так и отрицательные значения. В Java не поддерживаются
целочисленные значения без знака, т.е. только положительные целые числа. Во многих
других языках программирования широко применяются целочисленные типы данных
без знака, но создатели Java посчитали их излишними.
60 Java 8: руководство для начинающих. 6-е издание
ПРИМЕЧАНИЕ
В исполняющей системе Java для хранения простых типов может формально выделяться любой
объем памяти, но диапазон допустимых значений остается неизменным.
Из всех целочисленных типов данных чаще всего применяется int. Переменные
типа int нередко используются в качестве переменных циклов, индексов массивов и,
конечно же, для выполнения универсальных операций над целыми числами.
Если диапазон значений, допустимых для типа int, вас не устраивает, можно выбрать
тип long. Ниже приведен пример программы для расчета числа кубических дюймов
в кубе, длина, ширина и высота которого равны одной миле.
/*
Расчет числа кубических дюймов в кубе объемом в 1 куб. милю
*/
class Inches {
puЫic static void main(String args[]) {
long ci;
long im;
im 5280 * 12;
ci im * im * im;
System.out.println("B одной кубической миле содержится " + ci +
" кубических дюймов");
Результат выполнения данной программы выглядит следующим образом:
В одной кубической миле содержится 254358061056000 кубических дюймов
Очевидно, что результирующее значение не умещается в переменной типа int.
Наименьшим диапазоном допустимых значений среди всех целочисленных типов
обладает тип byte. Переменные типа byte очень удобны для обработки исходных двоичных
данных, которые могут оказаться несовместимыми с другими встроенными в Java
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как упоминалось выше, существуют четыре целочисленных типа данных:
int, short, long и byte. Но говорят, что тип char в Java также считается
целочисленным. В чем здесь дело?
ОТВЕТ. Формально в спецификации Java определена категория целочисленных
типов данных, в которую входят типы byte, short, int, long и char. Такие
типы называют целочисленными, поскольку они могут хранить целые двоичные
значения. Первые четыре типа предназначены для представления целых чисел,
а тип char - для представления символов. Таким образом, тип char принципиально
отличается от остальных четырех целых типов данных. Учитывая это
отличие, тип char рассматривается в данной книге отдельно.
Глава 2. Введение в типы данных и операции над ними 61
типами данных. Тип short предназначен ДJIЯ хранения небольших целых чисел. Переменные
данного типа пригодны ДJIЯ хранения значений, изменяющихся в относительно
небольших пределах по сравнению со значениями типа int.
Типы даннь1х с плавающей точкой
Как пояснялось в главе l, типы с плавающей точкой могут представлять числовые
значения с дробной частью. Существуют два типа данных с плавающей точкой: float
и douЫe. Они представляют числовые значения с одинарной и двойной точностью соответственно.
Разрядность данных типа f loa t составляет 32 бита, а разрядность данных
типа douЫe - 64 бита.
Тип douЫe употребляется намного чаще, чем float, поскольку во всех математических
функциях из библиотек классов Java используются значения типа douЫe. Например,
метод sqrt (), определенный в стандартном классе Math, возвращает значение
douЬle, являющееся квадратным корнем значения аргумента этого метода, также представленного
типом douЬle. Ниже приведен фрагмент кода, в котором метод sqrt () используется
ДJIЯ расчета ДJIИНЫ гипотенузы, при условии, что заданы ДJIИНы катетов.
/*
*/
Определение длины гипотенузы, исходя из длины катетов,
по теореме Пифагора
class Hypot {
puЫic static void main(String args[]) {
douЫe х, у, z;
х = 3;
у 4; 􀀝---Обратите внимание но вызов метода sqrt () . Перед именем
"t метода указывается имя кпоссо, чnеном которого он явnяется
z = Math.sqrt(x*x + у*у);
System.out.println("Длинa гипотенузы: " +z);
Выполнение этого фрагмента кода дает следующий результат:
Длина гипотенузы: 5.0
Как упоминалось выше, метод sqrt ( ) определен в стандартном классе Ма th. Обратите
внимание на вызов этого метода в приведенном выше фрагменте кода: перед его
именем указывается имя класса. Аналогичным образом перед именем метода println ()
указывается имена классов System. out. Имя класса указывается не перед всеми стандартными
методами, но ДJIЯ некоторых из них целесообразно применять именно такой
способ.
Символы
В отличие от других языков в Java символы не являются 8-битовыми значениями.
Вместо этого в Java используется кодировка Unicode, позволяющая представлять символы
всех письменных языков. В Java тип char представляет 16-разрядное значение без
знака в диапазоне от О до 65536. Стандартный набор 8-разрядных символов кодировки
62 Java 8: руководство для начинающих. 6-е издание
ASCII является подмножеством стандарта Unicode. В нем коды символов находятся в
пределах от О до 127. Следовательно, символы в коде ASCII по-прежнему допустимы
в Java.
Переменной символьного типа может быть присвоено значение, которое записывается
в виде символа, заключенного в одинарные кавычки. В приведенном ниже фрагменте
кода показано, каким образом переменной ch присваивается буква х.
char ch;
ch = 'Х';
Отобразить значение типа char можно с помощью метода println (). В приведенной
ниже строке кода показано, каким образом этот метод вызывается для вывода на
экран значения символа, хранящегося в переменной ch.
System.out.println("Этo символ " + ch);
Поскольку тип char представляет 16-разрядное значение без знака, над переменной
символьного типа можно выполнять различные арифметические операции. Рассмотрим
в качестве примера следующую программу.
// С символьными переменными можно обращаться, как с целочисленными
class CharArithDemo {
puЫic static void main(String args[J) {
char ch;
ch = 'Х';
System.out.println("ch содержит " + ch);
ch++; / / инкрементировать переменную ch -------Переменную типа char
System.out.println("тenepь ch содержит " + ch); можно иноtрементировать
ch = 90; / / присвоить переменной ch значение Z ------Переменной типа
System.out.println("тenepь ch содержит " + ch); сhаrможноnрисвонть
Ниже приведен результат выполнения данной программы.
ch содержит Х
теперь ch содержит У
теперь ch содержит Z
цеnочисnенное значение
В приведенной выше программе переменной ch сначала присваивается значение
кода буквы х. Затем содержимое ch увеличивается на единицу, в результате чеrо оно
превращается в код буквы У - следующего по порядку символа в наборе ASCII (а также
в наборе Unicode). После этого переменной ch присваивается значение 90, представляющее
букву z в наборе символов ASCII (и в Unicode). А поскольку символам набора
АSСП соответствуют первые 127 значений набора Unicode, то все приемы, обычно применяемые
для манипулирования символами в других языках программирования, будут
работать и в Java.
Глава 2. Введение в типы данных и операции над ними 63
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Почему в Java для кодировки символов применяется стандарт Unicode?
ОТВЕТ. Язык Java изначально разрабатывался для международного применения.
Поэтому возникла необходимость в наборе символов, способном представлять
все письменные языки. Именно для этой цели и был разработан стандарт
Unicode. Очевидно, что применение этого стандарта в программах на таких
языках, как английский, немецкий, испанский и французский, сопряжено с
дополнительными издержками, поскольку для символа, который вполне может
быть представлен восемью битами, приходится вьщелять 16 бит. Это та цена,
которую приходится платить за обеспечение переносимости программ.
Логический тип данных
Тип boolean представляет логические значения "истина" и "ложь", для которых в
Java зарезервированы слова true и false соответственно. Следовательно, переменная
или выражение типа boolean может принимать одно из этих двух значений.
Ниже приведен пример программы, демонстрирующий применение типа boolean в
коде.
// Демонстрация использования логических значений
class BoolDemo {
puЫic static void main(String args[])
boolean Ь;
Ь = false;
System.out.println("Знaчeниe Ь: " + Ь);
Ь = true;
System.out.println("Знaчeниe Ь: " + Ь);
// Логическое значение можно использовать для
// управления условным оператором if
if (Ь) System. out. println ( "Эта инструкция вьmолняется");
Ь = false;
if(b) System.out.println("Этa инструкция не выполняется");
// В результате выполнения сравнения
// получается логическое значение
System.out.println("Peзyльтaт сравнения 10 > 9: " + (10 > 9));
Результат выполнения данной программы выглядит следующим образом.
Значение Ь: false
Значение Ь: true
Эта инструкция выполняется
Результат сравнения 10 > 9: true
64 Java 8: руководство для начинающих. 6-е издание
Анализируя эту программу, необходимо отметить следующее. Во-первых, нетрудно
заметить, что метод println (), обрабатывая логическое значение, отображает символьные
строки "true" и "false". Во-вторых, значение логической переменной может
быть само использовано для управления условным оператором if. Это означает, что отпадает
необходимость в выражениях вроде следующего:
if(b == true) ...
И в-третьих, результатом выполнения оператора сравнения, например <, является
логическое значение. Именно поэтому при передаче методу println () выражения
( 10 > 9) отображается логическое значение true. Скобки в данном случае необходимы,
потому что операция + имеет более высокий приоритет по сравнению с операцией >.
Упражнение 2.1 Расчет расстояния до места вспышки молнии
:··············· ............. = \ Sound.java \ В данном проекте предстоит написать программу, вычисляющую рас-
: ............................ , стояние в футах до источника звука, возникающего при вспышке мол-
нии. Звук распространяется в воздухе со скоростью, приблизительно равной 1100 фут/с.
Следовательно, зная промежуток времени между теми моментами, когда наблюдатель
увидит вспышку молнии и услышит сопровождающий ее раскат грома, можно рассчитать
расстояние до нее. Допустим, что этот промежуток времени составляет 7 ,2 секунды.
Поэтапное описание процесса создания программы приведено ниже.
1. Создайте новый файл Sound. j ava.
2. Для расчета искомого расстояния потребуются числовые значения с плавающей
точкой. Почему? Потому что упомянутое выше числовое значение промежутка
времени содержит дробную часть. И хотя для расчета достаточно точности, обеспечиваемой
типом float, в данном примере будет использован тип douЫe.
3. Для расчета искомого расстояния умножьте 1100 на 7, 2, а полученный результат
сохраните в переменной типа douЫe.
4. Выведите результат вычислений на экран.
Ниже приведен исходный код программы из файла Sound. j ava.
/*
*/
Упражнение 2.1
Рассчитать расстояние до места вспЬП11ки молнии, звук от которого
доходит до наблюдателя через 7,2 секунды.
class Sound {
puЫic static void rnain(String args[]) {
douЫe dist;
dist = 1100 * 7.2 ;
Systern.out.println("Paccтoяниe до места вспьпnки молнии " +
"составляет " + dist + " футов");
5. Скомпилируйте программу и запустите ее на выполнение. Вы получите следующий
результат:
Расстояние до места ВСПЬПIIКИ молнии составляет 7920.0 футов
Глава 2. Введение в типы данных и операции над ними 65
6. Усложним задачу. Рассчитать расстояние до крупного объекта, например скалы,
можно по времени прихода эхо. Так, если вы хлопнете в ладоши, время, через
которое вернется эхо, будет равно времени прохождения звука в прямом и обратном
направлении. Разделив этот промежуток времени на два, вы получите время
прохождения звука от вас до объекта. Полученное значение можно затем использовать
для расчета расстояния до объекта. Видоизмените рассмотренную выше
программу, используя в расчетах промежуток времени до прихода эха.
Литералы
В Java литералы применяются для представления постоянных значений в форме,
удобной для восприятия. Например, число 100 является литералом. Литералы часто называют
константами. Как правило, структура литералов и их использование интуитивно
понятны. Они уже встречались в рассмотренных ранее примерах программ, а теперь
пришло время дать им формальное определение. В Java предусмотрены литералы для
всех простых типов. Способ представления литерала зависит от типа данных. Как пояснялось
ранее, константы, соответствующие символам, заключаются в одинарные кавычки.
Например, и 'а ', и ' % ' являются символьными константами.
Целочисленные константы записываются как числа без дробной части. Например,
целочисленными константами являются 10 и -100. При формировании константы с
плавающей точкой необходимо указывать десятичную точку, после которой следует
дробная часть. Например, 11. 123 - это константа с плавающей точкой. В Java поддерживается
и так называемый экспоненциальный формат представления чисел с плавающей
точкой.
По умолчанию целочисленные литералы относятся к типу int. Если же требуется
определить литерал типа long, после числа следует указать букву 1 или L. Например,
12 - это константа типа int, а 121 - константа типа long.
По умолчанию литералы с плавающей точкой относятся к типу douЫe. А для того
чтобы задать литерал типа float, следует указать после числа букву f или F. Так, например,
к типу float относится литерал 10 .19F.
Несмотря на то что целочисленные литералы по умолчанию создаются как значения
типа int, их можно присваивать переменным типа char, byte, short и long. Присваиваемое
значение приводится к целевому типу. Переменной типа long можно также присвоить
любое значение, представленное целочисленным литералом.
В версии JDK 7 появилась возможность вставлять в литералы (как целочисленные,
так и с плавающей точкой) знак подчеркивания. Благодаря этому упрощается восприятие
числовых значений, состоящих из нескольких цифр. А при компиляции знаки подчеркивания
просто удаляются из литерала. Ниже приведен пример литерала со знаком
подчеркивания.
123 45 1234
Этот литерал задает числовое значение 123451234. Пользоваться знаками подчеркивания
особенно удобно при кодировании номеров деталей, идентификаторов заказчиков
и кодов состояния, которые обычно состоят из целых групп цифр.
66 Java 8: руководство для начинающих. 6-е издание
Шестнадцатеричные, восьмеричные и двоичные литералы
Вам, вероятно, известно, что при написании программ бывает удобно пользоваться
числами, представленными в системе счисления, отличающейся от десятичной. Для
этой цели чаще всего выбирается восьмеричная (с основанием 8) и шестнадцатеричная
(с основанием 16) системы счисления. В восьмеричной системе используются цифры от
О до 7, а число 1 О соответствует числу 8 в десятичной системе. В шестнадцатеричной
системе используются цифры от О до 9, а также буквы от А до F, которыми обозначаются
числа 10, 11, 12, 13, 14 и 15 в десятичной системе, тогда как число 10 в шестнадцатеричной
системе соответствует десятичному числу 16. Восьмеричная и шестнадцатеричная
системы используются очень часто в программировании, и поэтому в языке Java
предусмотрена возможность представления целочисленных констант (или литералов) в
восьмеричной и шестнадцатеричной форме. Шестнадцатеричная константа должна начинаться
с символов Ох (цифры О, после которой следует буква х). А восьмеричная константа
начинается с нуля. Ниже приведены примеры таких констант.
hex = OxFF; // соответствует десятичному числу 255
oct = 011; // соответствует десятичному числу 9
Любопытно, что в Java допускается задавать шестнадцатеричные литералы в формате
с плавающей точкой, хотя они употребляются очень редко.
В версии JDK 7 появилась также возможность задавать целочисленный литерал в
двоичной форме. Для этого перед целым числом достаточно указать символы ОЬ или ОВ.
Например, следующий литерал определяет целое значение 12 в двоичной форме:
ОЫlОО
Управляющие последовательности символов
Заключение символьных констант в одинарные кавычки подходит для большинства
печатных символов, но некоторые непечатные символы, например символ возврата каретки,
становятся источником проблем при работе с текстовыми редакторами. Кроме
того, некоторые знаки, например одинарные и двойные кавычки, имеют специальное
назначение, и поэтому их нельзя непосредственно указывать в качестве литерала. По
этой причине в языке Java предусмотрены специальные управляющие последовательности,
начинающиеся с обратной косой черты (помещение обратной косой черты перед
символом называют экранированием символа). Эти последовательности перечислены
в табл. 2.2. Они используются в литералах вместо непечатных символов, которые они
представляют.
Таблица 2.2. Управляющие последовательности символов
Управляющая последовательность
\'
\"
\\
\r
\n
Описание
Одинарная кавычка
Двойная кавычка
Обратная косая черта
Возврат каретки
Перевод строки
Глава 2. Введение в типы данных и операции над ними 67
Управляющая последовательность Описание
Перевод страницы
Горизонтальная табуляция
Возврат но одну позицию
Окончание табл. 2.2
\f
\t
\Ь
\ddd
\uxxxx
Восьмеричная константа (rде ddd -восьмеричное число)
Шестнадцатеричная константа (rде хххх -шестнадцатеричное
число)
Ниже приведен пример присваивания переменной ch символа табуляции.
ch = '\t';
А в следующем примере переменной ch присваивается одинарная кавычка:
ch = '\' ';
Строковые литералы
В Java предусмотрены также литералы дпя представления символьных строк. Символьная
строка - это набор символов, заключенный в двойные кавычки:
"Это тест"
Примеры строковых литералов не раз встречались в рассмотренных ранее примерах
программ. В частности, они передавались в качестве аргументов методу println ().
Помимо обычных символов, строковый литерал также может содержать упоминавшиеся
выше управляющие последовательности. Рассмотрим в качестве примера следующую
программу, в которой применяются управляющие последовательности \ n и \ t.
// Демонстрация управляющих последовательностей в символьных строках
class StrDemo {
puЫic static void main(String args[]) {
System.out.println("Пepвaя строка\nВторая строка");
􀃐
System.out.println("A\tB\tC''); f
system. out. println ( "D\ tE\tF") ; 􀃑---Исnол•зуйте последовотел•ность \nдnя встовки
) символа перевода строки
) Испол•зуйте табуляцию
дnя вwравииваиия вwвода
Ниже приведен результат выполнения данной программы.
Первая строка
Вторая строка
А В С
D Е F
68 Java 8: руководство для начинающих. 6-е издание
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Представляет ли строка, состоящая из одного символа, то же самое, что
и символьный литерал? Например, есть ли разница между "k" и 'k'?
ОТВЕТ. Нет, это разные вещи. Строки следует отличать от символов. Символьный
литерал представляет один символ и относится к типу char. А строка, содержащая
даже один символ, все равно остается строкой. Несмотря на то что строки
состоят из символов, они относятся к разным типам данных.
Обратите внимание на использование управляющей последовательности \n для перевода
строки в приведенном выше примере программы. Для вывода на экран нескольких
символьных строк вовсе не обязательно вызывать метод println () несколько раз
подряд. Достаточно ввести в строку символы \n, и при выводе в этом месте произойдет
переход на новую строку.
Подробнее о переменных
О переменных уже шла речь в главе l. А здесь они будут рассмотрены более подробно.
Как вы уже знаете, переменная объявляется в такой форме:
тип имя_переменной;
где тип обозначает конкретный тип объявляемой переменной, а имя_ переменной - ее
наименование. Объявить можно переменную любого допустимого типа, включая рассмотренные
ранее простые типы. Когда объявляется переменная, создается экземпляр
соответствующего типа. Следовательно, возможности переменной определяются ее типом.
Например, переменную типа boolean нельзя использовать для хранения значения
с плавающей точкой. На протяжении всего срока действия переменной ее тип остается
неизменным. Так, переменная int не может превратиться в переменную char.
В Java каждая переменная должна быть непременно объявлена перед ее использованием.
Ведь компилятору необходимо знать, данные какого именно типа содержит переменная,
и лишь тогда он сможет правильно скомпилировать оператор, в котором используется
переменная. Объявление переменных позволяет также осуществлять строгий
контроль типов в Java.
Инициализация переменных
Прежде чем использовать переменную в выражении, ей нужно присвоить значение.
Сделать это можно, в частности, с помощью уже знакомого вам оператора присваивания.
Существует и другой способ: инициализировать переменную при ее объявлении.
Для этого достаточно указать после имени переменной знак равенства и требуемое значение.
Ниже приведена общая форма инициализации переменной.
тип переменная = значение;
где значение обозначает конкретное значение, которое получает переменная при ее
создании, причем тип значения должен соответствовать указанному типу переменной.
Ниже приведен ряд примеров инициализации переменных.
int count 10;
char ch 'S';
float f = l.2F;
Глава 2. Введение в типы данных и операции над ними 69
// присвоить переменной count начальное значение 10
// инициализировать переменную ch буквой S
// инициализировать переменную f
// числовым значением 1.2
Присваивать начальные значения переменным можно и в том случае, если в одном
операторе объявляется несколько переменных:
int а, Ь = 8, с = 19, d; // инициализируются переменные Ь и с
В данном случае инициализируются переменные Ь и с.
Динамическая инициализация
В приведенных выше примерах в качестве значений, присваиваемых переменным,
использовались только константы. Но в Java поддерживается также динамическая инициализация,
при которой можно использовать любые выражения, допустимые в момент
объявления переменной. Ниже приведен пример простой программы, в которой объем
цилиндра рассчитывается, исходя из его радиуса и высоты.
// Демонстрация динамической инициализации
class Dyninit {
puЫic static void main(String args[])
douЫe radius = 4, height = 5;
// Переменная volume инициализируется динамически
//во время выполнения программы
douЫe volume = 3.1416 * radius * radius * height;
System.out.println("Oбъeм: " + volume);
В данном примере используются три локальные переменные: radius, height и
volume. Первые две из них инициализируются константами, а для присвоения значения
переменной vol ume применяется динамическая инициализация, в ходе которой вычисляется
объем цилиндра. В выражении динамической инициализации можно использовать
любой определенный к этому моменту элемент, в том числе вызовы методов, другие
переменные и литералы.
Область действия и время жизни переменных
Все использовавшиеся до сих пор переменные объявлялись в начале метода main ().
Но в Java можно объявлять переменные в любом блоке кода. Как пояснялось в главе l,
блок начинается с открывающей фигурной скобки и оканчивается закрывающей фигурной
скобкой. Блок определяет область действия (видимости) переменных. Начиная
новый блок, вы всякий раз создаете новую область действия. По существу, область действия
определяет доступность объектов из других частей программы и время их жизни
(срок их действия).
Во многих языках программирования поддерживаются две общие категории областей
действия: глобальная и локальная. И хотя они поддерживаются и в Java, тем не менее
не являются наиболее подходящими понятиями для категоризации областей действия
70 Java 8: руководство для начинающих. 6-е издание
объектов. Намного большее значение в Java имеют области, определяемые классом и
методом. Об областях действия, определяемых классом (и объявляемых в них переменных),
речь поЙдет далее, когда доЙдет черед до рассмотрения классов. А пока исследуем
только те области действия, которые определяются методами или в самих методах.
Начало области действия, определяемой методом, обозначает открывающая фигурная
скобка. Если для метода предусмотрены параметры, они также входят в область его
действия.
Как правило, переменные, объявленные в некоторой области действия, невидимы
(а следовательно, недоступны) за ее пределами. Таким образом, объявляя переменную в
некоторой области действия, вы тем самым ограничиваете пределы ее действия и защищаете
ее от нежелательного доступа и видоизменения. На самом деле правила определения
области действия служат основанием для инкапсуляции.
Области действия мoryr быть вложенными. Открывая новый блок кода, вы создаете
новую, вложенную область действия. Такая область заключена во внешней области. Это
означает, что объекты, объявленные во внешней области действия, будуr доступны для
кода во внутренней области, но не наоборот. Объекты, объявленные во внутренней области
действия, недоступны во внешней области.
Для того чтобы лучше понять принцип действия вложенных областей действия, рассмотрим
следующий пример программы.
// Демонстрация области действия блока кода
class ScopeDemo {
puЫic static void main(String args[]) {
int х; // Эта переменная доступна для всего кода в методе main
х = 10;
if(x == 10) { // Начало новой области действия
int у= 20; // Эта переменная доступна только в данном блоке
// Обе переменные, "х" и "у", доступны в данном кодовом блоке
}
System.out.println("x and у: " +х +" " +у);
х = у * 2;
// у = 100; // Ошибка! В этом месте переменная "у" недоступна..,.,. __􀁚
// А переменная "х" по-прежнему доступна
System.out.println("x is " + х);
Здесь переменная у находится
вне своей обnасти действия
Как следует из комментариев к приведенной выше программе, переменная х определяется
в начале области действия метода maiп () и доступна для всего кода, содержащегося
в этом методе. В блоке условного оператора if объявляется переменная у. Этот
блок определяет область действия переменной у, и, следовательно, она доступна только
в нем. Именно поэтому закомментирована строка кода у = 1 О О ; , находящаяся за пределами
данного блока. Если удалить символы комментариев, то при компиляции программы
появится сообщение об ошибке, поскольку переменная у недоступна для кода
за пределами блока, в котором она объявлена. В то же время в блоке условного оператора
i f можно пользоваться переменной х, потому что код в блоке, который определяет
Глава 2. Введение в типы данных и операции над ними 71
вложенную область действия, имеет доступ к переменным из внешней, охватывающей
его области действия.
Переменные можно объявлять в любом месте блока кода, но сделать это следует непременно
перед тем, как пользоваться ими. Именно поэтому переменная, определенная
в начале метода, доступна для всего кода этого метода. А если объявить переменную в
конце блока, то такое объявление окажется, по сути, бесполезным, поскольку переменная
станет вообще недоступной для кода.
Следует также иметь в виду, что переменные, созданные в области их действия, удаляются,
как только управление в программе передается за пределы этой области. Следовательно,
после выхода из области действия переменной содержащееся в ней значение
теряется. В частности, переменные, объявленные в теле метода, не хранят значения в
промежутках между последовательными вызовами этого метода. Таким образом, время
жизни переменной ограничивается областью ее действия.
Если при объявлении переменной осуществляется ее инициализация, то переменная
будет повторно инициализироваться при каждом входе в тот блок, в котором она объявлена.
Рассмотрим в качестве примера следующую программу.
// Демонстрация времени жизни переменной
class VarinitDemo {
у:
puЫic static void main(String args[])
int х;
for(x = О; х < З; х++) {
int у= -1; // переменная у инициализируется при каждом входе в блок
System.out.println("y: " + у); // всегда выводится значение -1
у = 100;
System.out.println("Измeнeннoe значение у: " + у);
Ниже приведен результат выполнения данной программы.
-1
Измененное значение у: 100
у: -1
Измененное значение у: 100
у: -1
Измененное значение у: 100
Как видите, на каждом шаге цикла for переменная у инициализируется значением
-1. Затем ей присваивается значение 100, но по завершении блока кода данного цикла
оно теряется.
Для правил области действия в Java характерна следующая особенность: во вложенном
блоке нельзя объявлять переменную, имя которой совпадает с именем переменной
во внешнем блоке. Рассмотрим пример программы, в которой предпринимается попытка
объявить две переменные с одним и тем же именем в разных областях действия, и
поэтому такая программа не пройдет компиляцию.
/*
В этой программе предпринимается попытка объявить во внутренней области
действия переменную с таким же именем, как и у переменной,
объявленной во внешней области действия.
72 Java 8: руководство для начинающих. 6-е издание
*** Эта программа не пройдет компиляцию ***
*/
class NestVar {
puЬlic static void maiп (Striпg args []) {
int count;
for(count = О; count < 10; count = count+l) {
System.out.println("Знaчeниe count: " + count);
int count; / / Недопустимо! ! ! 4------Неяьэк объквтпь п еременную count,
f or(count = О; count < 2; count++) поскояькуранееона ужебыяаобъквяена
System.out.println("B этой программе есть ошибка!");
Если у вас имеется определенный опыт программирования на С или С++, то вам,
вероятно, известно, что в этих языках отсутствуют какие-либо ограничения на имена
переменных, объявляемых во внутренней области действия. Так, в С и С++ объявление
переменной count в блоке внешнего цикла for из приведенного выше примера программы
вполне допустимо, несмотря на то что такая же переменная уже объявлена во
внешнем блоке. В этом случае переменная во внутреннем блоке скрывает переменную
из внешнего блока. Создатели Java решили, что подобное сокрытие имен переменных
может привести к программным ошибкам, и поэтому запретили его.
Операции
Язык Java предоставляет множество операций, позволяющих выполнять определенные
действия над исходными значениями, называемыми операндами, для получения результирующего
значения. Большинство операций может быть отнесено к одной из следующих
четырех категорий: арифметические, поразрядные (побитовые), логические и
операции отношения (сравнения), выполняемые с помощью соответствующих операторов.
Кроме того, в Java предусмотрены другие операции, имеющие специальное назначение.
В этой главе будут рассмотрены арифметические и логические операции, а также
операции сравнения и присваивания. О поразрядных операциях, а также дополнительных
операциях речь пойдет позже.
Арифметические операции
В языке Java определены следующие арифметические операции.
Знак операции
+
*
/
Выполняемое действие
Сложение (а также унарный плюс}
Вычитание (а таК>Ке унарный минус}
Умножение
Деление
Глава 2. Введение в типы данных и операции над ними 73
Окончание таблицы
Знак операции Выполняемое действие
%
++
Деление по модулю {остаток от деления)
Инкремент
Декремент
Операторы+, -, * и / имеют в Java тот же смысл, что и в любом другом языке программирования
в частности и в математике вообще, т.е. выполняют обычные арифметические
действия. Их можно применять к любым числовым данным встроенных типов, а
также к объектам типа char.
Несмотря на то что арифметические операции общеизвестны, у них имеются некоторые
особенности, требующие специального пояснения. Во-первых, если операция /
применяется к целым числам, остаток от деления отбрасывается. Например, результат
целочисленного деления 10 / З равен З. Для получения остатка от деления используется
операция деления по модулю %. В Java она выполняется так же, как и в других языках
программирования. Например, результатом вычисления выражения 10 % З будет 1.
Операция % применима не только к целым числам, но и к числам с Шiавающей точкой.
Следовательно, в результате вычисления выражения 1 О • О % З . О также будет получено
значение 1. Ниже приведен пример программы, демонстрирующий использование
операции%.
// Демонстрация использования операции%
class ModDemo {
puЬlic static void main(String args[])
int iresult, irem;
douЫe dresult, drem;
iresult = 10 / 3;
irem = 10 % 3;
dresult = 10.0 / 3.0;
drem = 10.0 % 3.0;
System.out.println("Peзyльтaт и остаток от деления 10 / 3: " +
iresult + " " + irem);
System.out.println("Peзyльтaт и остаток от деления 10.0 / 3.0: "
+ dresult + " " + drem);
Выполнение этой программы дает следующий результат.
Результат и остаток от деления 10 / 3: 3 1
Результат и остаток от деления 10.0 / 3.0: 3.3333333333333335 1.0
Как видите, операция % дает остаток от деления как целых чисел, так и чисел с плавающей
точкой.
74 Java 8: руководство для начинающих. 6-е издание
Операции инкремента и декремента
Операции++ и--, выполняющие положительное (инкремент) и отрицательное (декремент)
приращение значений, уже были представлены в главе 1. Как будет показано
ниже, эти операции имеют ряд интересных особенностей. Рассмотрим подробнее действия,
которые осуществляются при выполнении операций инкремента и декремента.
Операция инкремента добавляет к своему операнду единицу, а оператор декремента
вычитает единицу из операнда. Следовательно, операция
х = х + 1;
дает тот же результат, что и операция
х++;
а операция
х = х - 1;
дает тот же результат, что и операция
Операции инкремента и декремента могут записываться в одной из двух форм: префиксной
(знак операции предшествует операнду) и постфиксной (знак операции следует
за операндом). Например, оператор
х = х + 1;
можно записать так:
++х; // префиксная форма
или так:
х++; // постфиксная форма
В приведенных выше примерах результат не зависит от того, какая из форм применена.
Но при вычислении более сложных выражений применение этих форм будет давать
различные результаты. Общее правило таково: префиксной форме записи операций инкремента
и декремента соответствует изменение значения операнда до его использования
в соответствующем выражении, а постфиксной - после его использования. Рассмотрим
конкретный пример.
х = 10;
у= ++х;
В результате выполнения соответствующих действий значение переменной у будет
равно 11. Но если изменить код так, как показано ниже, то результат будет другим.
х = 10;
у= х++;
Теперь значение переменной у равно 10. При этом в обоих случаях значение переменной
х будет равно 11. Возможность контролировать момент выполнения операции
инкремента или декремента дает немало преимуществ при написании программ.
Глава 2. Введение в типы данных и операции над ними 75
Операции сравнения и логические операции
Операции сравнения (отношения) отличаются от логических операций тем, что первые
определяют отношения между значениями, а вторые связывают между собой логические
значения (true или false), получаемые в результате определения отношений между
значениями. Операции сравнения возвращают логическое значение true или false и
поэтому нередко используются совместно с логическими операциями. По этой причине
они и рассматриваются вместе.
Ниже перечислены операции сравнения.
Знак операции
!=
>
<
>=
<=
Значение
Ровно
Не ровно
Больше
Меньше
Больше или ровно
Меньше или ровно
Далее перечислены логические операции.
Оператор
&
11
&&
Значение
и
или
Исключающее ИЛИ
Укороченное ИЛИ
Укороченное И
НЕ
Результатом выполнения операции сравнения или логической операции является логическое
значение типа boolean.
В Java все объекты могут быть проверены на равенство или неравенство с помощью
операций == и ! = соответственно. В то же время операции <, >, <= и >= могут применяться
только к тем типам данных, для которых определено отношение порядка. Следовательно,
к данным числовых типов и типа char можно применять все операции сравнения.
Логические же значения типа boolean можно проверять только на равенство
или неравенство, поскольку истинные (true) и ложные (false) значения не имеют отношения
порядка. Например, выражение true > false не имеет смысла в Java.
Операнды логических операций должны иметь тип boolean, как, впрочем, и результаты
выполнения этих операций. Встроенным операторам Java &, 1, ли ! соответствуют
логические операции "И", "ИЛИ", "исключающее ИЛИ" и "НЕ". Результаты их применения
к логическим операндам р и q представлены в следующей таблице.
76 Java 8: руководство для начинающих. 6-е издание
р q р & q р 1 q р
л
q !р
false false false false false true
true false false true true false
false true false true true true
true true true true false false
Отсюда видно, что результат выполнения логической операции "исключающее
ИЛИ" будет истинным (true) в том случае, если один и только один из ее операндов
имеет логическое значение true.
Приведенный ниже пример программы демонстрирует применение некоторых операций
сравнения и логических операций.
!/ Демонстрация использования операций сравнения
// и логических операций
class RelLogOps {
puЫic static void main(String args[]) {
int i, j;
boolean Ы, Ь2;
i = 10;
j = 11;
if(i < j) System.out.println("i < j");
if(i <= j) System.out.println("i <= j");
if(i != j) System.out.println("i != j");
if(i j) System.out.println("Этo не будет выполнено");
if(i >= j) System.out.println("Этo не будет выполнено");
if(i > j) System.out.println("Этo не будет выполнено");
Ы = true;
Ь2 = false;
if(Ы & Ь2) System.out.println("Этo не будет выполнено");
if(!(Ы & Ь2)) System.out.println("!(Ы & Ь2): true");
if(Ы I Ь2) System.out.println("Ы I Ь2: true");
if(Ы л Ь2) System.out.println("Ьl л Ь2: true");
Результат выполнения данной программы выглядит следующим образом.
i < j
i <= j
i != j
! (Ы & Ь2): true
Ы I Ь2: true
Ы л Ь2: true
Укороченные логические операции
В Java также предусмотрены специальные укороченные варианты логических операций
"И" и "ИЛИ", позволяющие выполнять так называемую быструю оценку значений
Глава 2. Введение в типы данных и операции над ними 77
логических выражений, обеспечивающую получение более эффективного кода. Поясним
это на следующих примерах. Если первый операнд логической операции "И" имеет
ложное значение (false), то результат будет иметь ложное значение независимо от значения
второго операнда. Если же первый операнд логической операции "ИЛИ" имеет
истинное значение (true), то ее результат будет иметь истинное значение независимо от
значения второго операнда. Благодаря тому что значение второго операнда в этих операциях
вычислять не нужно, экономится время и повышается эффективность кода.
Укороченной логической операции "И" соответствует знак операции &&, а укороченной
логической операции "ИЛИ" - знак 1 1. Аналогичные им обычные логические
операции обозначаются знаками & и 1 . Единственное отличие укороченной логической
операции от обычной заключается в том, что второй операнд вычисляется только тогда,
когда это нужно.
В приведенном ниже примере программы демонстрируется применение укороченной
логической операции "И". В этой программе с помощью деления по модулю определяется
следующее: делится ли значение переменной d на значение переменной n нацело.
Если остаток от деления n/d равен нулю, то n делится на d нацело. Но поскольку
данная операция подразумевает деление, то для проверки условия деления на нуль используется
укороченная логическая операция "И".
// Демонстрация использования укороченных логических операций
class SCops {
puЫic static void main(String args[J) {
int n, d, q;
n = 10;
d = 2;
i f ( d ! = О & & ( n % d) == О) .. Укороченная операция предотвращает деnенне на нуnь
System.out.println(d + " является делителем " + n);
d = О; // установить для d нулевое значение
// Второй операнд не вычисляется, поскольку значение
// переменной d равно нулю
if(d != О && (n % d) == О)
System.out.println(d + " является делителем " + n);
/* А теперь те же самые действия выполняются без использования
укороченного логического оператора. В результате возникнет
ошибка "деление на нуль".
*/
if(d != О & (n % d) == О)
Теперь вычисnяются о6а выражения, в резуnьтате
-------чеrо будет производиться деnение на нуnь
System.out.println(d + " является делителем " + n);
С целью предотвращения возможности деления на нуль в условном операторе i f
сначала проверяется, равно ли нулю значение переменной d. Если эта проверка дает истинный
результат, вычисление второго операнда укороченной логической операции "И"
не выполняется. Например, если значение переменной d равно 2, вычисляется остаток
от деления по модулю. Если же значение переменной d равно нулю, операция деления
по модулю пропускается, чем предотвращается деление на нуль. В конце программы
78 Java 8: руководство для начинающих, 6-е издание
применяется обычная логическая операция "И", в которой вычисляются оба операнда,
что может привести к делению на нуль при выполнении данной программы.
И последнее замечание: в формальной спецификации Java укороченная операция
"И" называется условной логической операцией "И", а укороченная операция "ИЛИ" -
условной логической операцией "ИЛИ", но чаще всего подобные операторы называют
укороченными.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Если укороченные операции более эффективны, то почему наряду с
ними в Java используются также обычные логические операции?
ОТВЕТ. В некоторых случаях требуется вычислять оба операнда логической оператора,
чтобы проявились побочные эффекты. Рассмотрим следующий пример.
// Демонстрация роли побочных эффектов
class SideEffects {
puЫic static void main(String args[])
int i;
i = О;
/* Значение переменной i инкрементируется, несмотря
на то что проверяемое условие в операторе if ложно */
if (false & (++i < 100))
System.out.println("Этa строка не будет отображаться");
System.out.println("Oпepaтop if выполняется: " +
i); // отображается 1
/* В данном случае значение переменной i не инкрементируется,
поскольку второй операнд укороченного логического оператора
не вычисляется, а следовательно, инкремент пропускается */
if(false && (++i < 100))
System.out.println("Этa строка не будет отображаться");
System.out.println("Oпepaтop if выполняется: " +
i); // по-прежнему отображается 1 ! !
Как следует из приведенного выше фрагмента кода и комментариев к нему, в
первом условном операторе i f значение переменной i должно увеличиваться
на единицу, независимо от того, выполняется ли условие этого оператора. Но
когда во втором условном операторе if применяется укороченный логический
оператор, значение переменной i не инкрементируется, поскольку первый операнд
в проверяемом условии имеет логическое значение false. Следовательно,
если логика программы требует, чтобы второй операнд логического оператора
непременно вычислялся, следует применять обычные, а не укороченные формы
логических операций.
Глава 2. Введение в типы данных и операции над ними 79
Операция присваивания
Операция присваивания уже не раз применялась в примерах программ, начиная с
главы 1. И теперь настало время дать ей формальное определение. Операция присваивания
обозначается одиночным знаком равенства(=). В Java она выполняет те же функции,
что и в других языках программирования. Ниже приведена общая форма записи
этой операции.
переменная = выражение
где переменная и выражение должны иметь совместимые типы.
У операции присваивания имеется одна интересная особенность, о которой вам будет
полезно знать: возможность создания цепочки операций присваивания. Рассмотрим,
например, следующий фрагмент кода.
int х, у, z;
х = у = z = 100; // присвоить значение 100 переменным х, у и z
В приведенном выше фрагменте кода одно и то же значение 100 задается для переменных
х, у и z с помощью единственного оператора присваивания, в котором значение
левого операнда каждой из операций присваивания всякий раз устанавливается равным
значению правого операнда. Таким образом, значение 100 присваивается сначала
переменной z, затем переменной у и, наконец, переменной х. Такой способ присваивания
по цепочке удобен для задания общего значения целой группе переменных.
Составные операции присваивания
В Java для ряда операций предусмотрены так называемые составные операции присваивания,
которые позволяют записывать операцию с последующим присвоением в виде
одной операции, что делает текст программ более компактным. Обратимся к простому
примеру. Приведенный ниже оператор присваивания
х = х + 10;
можно переписать в более компактной форме:
х += 10;
Знак операции += указывает компилятору на то, что переменной х должно быть присвоено
ее первоначальное значение, увеличенное на 10.
Рассмотрим еще один пример. Операция
х = х - 100;
и операция
х -= 100;
выполняют одни и те же действия. И в том и в другом случае переменной х присваивается
ее первоначальное значение, уменьшенное на 100.
Для всех бинарных операций, т.е. операций, требующих наличия двух операндов, в
Java предусмотрены соответствующие составные операторы присваивания. Общая форма
всех этих операций имеет следующий вид:
80 Java 8: руководство для начинающих. 6-е издание
переменная ор= выражение
где ар - арифметическая или логическая операция, применяемая совместно с операцией
присваивания.
Ниже перечислены составные операции присваивания лля арифметических и логических
операций.
%= 1 ::
+= *= /=
1 =
Каждая из перечисленных выше операций представляется знаком соответствующей
операции и следующим за ним знаком равенства, что и дало им название "составные".
Составные операции присваивания обладают двумя главными преимуществами.
Во-первых, они записываются в более компактной форме, чем их обычные эквиваленты.
Во-вторых, они приводят к более эффективному исполняемому коду, поскольку левый
операнд в них вычисляется только один раз. Именно по этим причинам они часто
используются в профессионально написанных программах на Java.
Преобразование типов при присваивании
При написании программ очень часто возникает потребность в присваивании значения,
хранящегося в переменной одного типа, переменной другого типа. Например,
значение int, возможно, потребуется присвоить переменной float.
int i;
float f;
i 10;
f i; // присвоить значение переменной типа int
// переменной типа float
Если типы данных являются совместимыми, значение из правой части оператора
присваивания автоматически преобразуется в тип данных в левой его части. Так, в приведенном
выше фрагменте кода значение переменной i преобразуется в тип float, а
затем присваивается переменной f. Но ведь Java - язык со строгим контролем типов,
и далеко не все типы данных в нем совместимы, поэтому неявное преобразование типов
выполняется не всегда. В частности, типы boolean и int не являются совместимыми.
Автоматическое преобразование типов в операции присваивания выполняется при
соблюдении следующих условий:
@ оба типа являются совместимыми;
,t{ целевой тип обладает более широким диапазоном допустимых значений, чем исходный.
Если оба перечисленных выше условия соблюдаются, происходит так называемое
расширение типа. Например, диапазона значений, допустимых лля типа int, совершенно
достаточно, чтобы представить любое значение типа byte, а кроме того, оба этих
типа данных являются целочисленными. Поэтому и происходит автоматическое преобразование
типа byte в тип int.
Глава 2. Введение в типы данных и операции над ними 81
С точки зрения расширения типов целочисленные типы и типы с плавающей точкой
совместимы друг с другом. Например, приведенная ниже программа написана корректно,
поскольку преобразование типа long в тип douЫe является расширяющим и выполняется
автоматически.
// Демонстрация автоматического преобразования типа long в тип douЫe
class LtoD {
}
}
puЫic static void main(String args[]) {
long L;
douЫe D;
L 100123285L;
D L; датоматнческое nреобразоаанне
тнnа long в тнn douЫe
System.out.println("L и D: " + L + " " + D);
В то же время тип douЫe не может быть автоматически преобразован в тип long,
поскольку такое преобразование уже не является расширяющим. Следовательно, приведенный
ниже вариант той же самом программы оказывается некорректным.
//*** Эта программа не пройдет компиляцию
class LtoD {
puЫic static void main(String args[]) {
long L;
douЫe D;
D 100123285.0;
***
L D; // Ошибка!!! -------Тнn douЫe не преобразуется
автоматнческн в тнn long
System.out.println("L и D: " + L + " " + D);
Автоматическое преобразование числовых типов в тип char или boolean не производится.
Кроме того, типы char и boolean несовместимы друг с другом. Тем не менее
переменной char может быть присвоено значение, представленное целочисленным литералом.
Приведение несовместимых типов
Несмотря на всю полезность неявных автоматических преобразований типов, они
не способны удовлетворить все потребности программиста, поскольку допускают лишь
расширяющие преобразования совместимых типов. А во всех остальных случаях приходится
обращаться к приведению типов. Приведение (cast) - это команда компилятору
преобразовать результат вычисления выражения в указанный тип. А для этого требуется
явное преобразование типов. Ниже приведен общий синтаксис приведения типов.
(целевой_тип) выражение
где целевой_ тип обозначает тот тип, в который желательно преобразовать указанное
выражение. Так, если требуется привести значение, возвращаемое выражением х / у,
к типу int, это можно сделать следующим образом.
82 Java 8: руководство для начинающих. 6-е издание
douЫe х, у;
/ / . . .
(int) (х / у)
В данном случае приведение типов обеспечит преобразование результатов выполнения
выражения в тип int, несмотря на то что переменные х и у принадлежат к типу
douЫe. Выражение х / у следует непременно заключить в круглые скобки, иначе будет
преобразован не результат деления, а только значение переменной х. Приведение типов
в данном случае требуется потому, что автоматическое преобразование типа douЫe в
тип int не выполняется.
Если приведение типа означает его сужение, то часть информации может быть утеряна.
Например, в результате приведения типа long к типу int часть информации будет
утеряна, если значение типа long окажется больше диапазона представления чисел для
типа int, поскольку старшие разряды этого числового значения отбрасываются. Когда
же значение с плавающей точкой приводится к целочисленному, в результате усечения
теряется дробная часть этого числового значения. Так, если присвоить значение 1. 2 З
целочисленной переменной, то в результате в ней останется лишь целая часть исходного
числа (1), а дробная его часть (О. 23) будет утеряна.
Ниже приведен пример программы, демонстрирующий некоторые виды преобразований,
требующие явного приведения типов.
// Демонстрация приведения типов
class CastDemo {
puЫic static void main (String args []) {
douЫe х, у;
byte Ь;
int i;
char ch;
х = 10.0;
у 3 . 0; .
􀃧-------- 8 данном сnучае теряется дробная часть чисnа
i (int) (х / у); // привести тип douЫe к типу int
System.out.println( 11 Цeлoчиcлeнный результат делениях/ у: 11 + i);
i = 1 О О ; А в этом сnучае информацня не теряется.
Ь = (byte) i; ТипЬуtеможет содержатьзначениеlОО
System.out.println( 11 Знaчeниe Ь: 11 + Ь);
i = 257;
Ь = (byte) i; ,. На этот роз информацня теряются. Тип byte не может содержать значение 257
System.out.println( 11 Знaчeниe Ь: 11 + Ь);
Ь = 88; // Представление символа Х в коде ASCII
ch = ( cha r) Ь; Явное приведение несовместимых типов
System.out.println( 11 ch: 11 + ch);
Глава 2. Введение в типы данных и операции над ними 83
Выполнение этой программы дает следующий результат.
Целочисленный результат деления х/ у: 3
Значение Ь: 100
Значение Ь: 1
ch: Х
В данной программе приведение выражения (х / у) к типу int означает потерю
дробной части числового значения результата деления. Когда переменной Ь присваивается
значение 100 из переменной i, данные не теряются, поскольку диапазон допустимых
значений у типа byte достаточен для представления этого значения. Далее
при попытке присвоить переменной Ь значение 257 снова происходит потеря данных,
поскольку значение 2 5 7 оказывается за пределами диапазона допустимых значений для
типа byte. И наконец, когда переменной char присваивается содержимое переменной
типа byte, данные не теряются, но явное приведение типов все же требуется.
Приоритеты операций
В табл. 2.3 приведены приоритеты используемых в Java операций в порядке следования
от самого высокого до самого низкого приоритета. В эту таблицу включен ряд
операций, которые будут рассмотрены в последующих главах. Формально разделители
[ J , () и . могут интерпретироваться как операции, и в этом случае они будут иметь
наивысший приоритет.
Таблица 2.3. Приоритет операций в Java
Наивысший
++ (постфиксная) -- (постфиксная)
++ (префиксная) -- (префиксноя) + (унарный плюс) - (унарный (приведение
минус) типов)
* / %
+
>> >>> <<
> >= < <= instanceof
!=
&
&&
11
? :
ор=
Наинизший
84 Java 8: руководство для начинающих. 6-е издание
Упражнение 2.2 Отображение таблицы истинности
для логических операций
:""1·􀀚􀀛·i·􀀜􀀝-1o􀀞т-􀀟ь'i􀀠·:j·􀀡;·􀀡···i в этом проекте предстоит создать программу, которая ото-
: .................................................... : бражает таблицу истинности для логических операций Java.
Для удобства восприятия отображаемой информации следует выровнять столбцы таблицы.
В данном проекте используется ряд рассмотренных ранее языковых средств, включая
управляющие последовательности и логические операции, а также демонстрируются
отличия в использовании приоритетов арифметических и логических операций. Поэтапное
описание процесса создания программы приведено ниже.
1. Создайте новый файл LogicalOpTaЬle. java.
2. Для того чтобы обеспечить выравнивание столбцов таблицы, в каждую выводимую
строку следует ввести символы \ t. В качестве примера ниже приведен вызов
метода println () для отображения заголовков таблицы.
System.out.println("P\tQ\tAND\tOR\tXOR\tNOT");
3. Для того чтобы сведения об операциях располагались под соответствующими заголовками,
в каждую последующую строку таблицы должны быть введены символы
табуляции.
4. Введите в файл LogicalOpTaЬle. java исходный код программы, как показано
ниже.
// Упражнение 2.2
// Отображение таблицы истинности для логических операций
class LogicalOpTaЫe {
puЫic static void main(Striпg args[]) {
boolean р, q;
System.out.println("P\tQ\tAND\tOR\tXOR\tNOT");
р = true; q = true;
System.out.print(p + "\t" + q +"\t");
System.out.print((p&q) + "\t" + (plq) + "\t");
System.out.println((pл q) + "\t" + (!р));
р = true; q = false;
System.out.print(p + "\t" + q +"\t");
System.out.print((p&q) + "\t" + (plq) + "\t");
System.out.println((pл q) + "\t" + (!р));
р = false; q = true;
System.out.print(p + "\t" + q +"\t");
System.out.print((p&q) + "\t" + (plq) + "\t");
System.out.println( (рл q) + "\t" + ( !р));
р = false; q = false;
System.out.print(p + "\t" + q +"\t");
System.out.print((p&q) + "\t" + (plq) + "\t");
System.out.println((pл q) + "\t" + (!р));
Глава 2. Введение в типы данных и операции над ними 85
Обратите внимание на то, что в операторах с вызовами метода println () логические
операции заключены в круглые скобки. Эти скобки необходимы для соблюдения
приоритета операций. В частности, арифметическая операция + имеет
более высокий приоритет, чем логические операции.
5. Скомпилируйте программу и запустите ее на выполнение. Результат должен выглядеть
следующим образом.
р Q AND OR XOR NOT
true true true true false false
true false false true true false
false true false true true true
false false false false false true
6. Попытайтесь видоизменить программу так, чтобы вместо логических значений
true и false отображались значения l и О. Это потребует больших усилий, чем
кажется на первый взгляд!
Выражения
Операции, переменные и литералы являются составными частями выражений. Выражением
в Java может стать любое допустимое сочетание этих элементов. Выражения
должны быть уже знакомы вам по предьщущим примерам программ. Более того, вы изучали
их в школьном курсе алгебры. Но некоторые их особенности все же нуждаются в
обсуждении.
Преобразование типов в вь􀀑ражениях
В выражении можно свободно использовать два или несколько типов данных, при
условии их совместимости друг с другом. Например, в одном выражении допускается
применение типов short и long, поскольку оба типа являются числовыми. Когда в
выражении употребляются разные типы данных, они преобразуются к одному общему
типу в соответствии с принятыми в Java правилами повышения типов (promotion rules).
Сначала все значения типа char, byte и short повышаются до типа int. Затем все
выражение повышается до типа long, если хотя бы один из его операндов имеет тип
long. Далее все выражение повышается до типа float, если хотя бы один из операндов
относится к типу float. А если какой-нибудь из операндов относится к типу douЫe, то
результат также относится к типу douЫe.
Очень важно иметь в виду, что правила повышения типов применяются только к значениям,
участвующим в вычислении выражений. Например, в то время как значение
переменной типа byte при вычислении выражения может повышаться до типа int, за
пределами выражения эта переменная будет по-прежнему иметь тип byte. Следовательно,
повышение типов применяется только при вычислении выражений.
Но иногда повышение типов может приводить к неожиданным результатам. Если,
например, в арифметической операции используются два значения типа byte, то происходит
следующее. Сначала операнды типа byte повышаются до типа int, а затем выполняется
операция, дающая результат типа int. Следовательно, результат выполнения
операции, в которой участвуют два значения типа byte, будет иметь тип int. Но ведь
это не тот результат, который можно было бы с очевидностью предположить. Рассмотрим
следующий пример программы.
86 Java 8: руководство для начинающих. 6-е издание
// Неожиданный результат повьпnения типов!
class PromDemo {
puЫic static void main (String args []) {
byte Ь;
int i;
Ь 10;
i Ь * Ь ; .... Приведение типов не требуется, так как тнn уже nовыwен да int
Г
Здесь дnя присваивания значения int переменной типа byte
Ь 1 О ; , требуется приведение тнnовl
Ь (byte) (Ь * Ь); // cast needed! !
System.out.println("i and Ь: " + i + " " + Ь);
Любопытно отметить, что при присваивании выражения Ь*Ь переменной i приведение
типов не требуется, поскольку тип Ь автоматически повышается до int при вычислении
выражения. В то же время, когда вы пытаетесь присвоить результат вычисления
выражения Ь*Ь переменной ь, требуется выполнить обратное приведение к типу byte!
Объясняется это тем, что в выражении Ь*Ь значение переменной Ь повышается до типа
int и поэтому не может быть присвоено переменной типа byte без приведения типов.
Имейте это обстоятельство в виду, если получите неожиданное сообшение об ошибке
несовместимости типов в выражениях, которые на первый взгляд кажутся совершенно
правильными.
Аналогичная ситуация возникает при выполнении операций с символьными операндами.
Например, в следующем фрагменте кода требуется обратное приведение к типу
char, поскольку операнды chl и ch2 в выражении повышаются до типа int.
char chl = 'а', ch2 = 'Ь';
chl = (char) (chl + ch2);
Без приведения типов результат сложения операндов chl и ch2 будет иметь тип int,
поэтому его нельзя присвоить переменной типа char.
Приведение типов требуется не только при присваивании значения переменной.
Рассмотрим в качестве примера следующую программу. В ней приведение типов выполняется
для того, чтобы дробная часть числового значения типа douЫe не была утеряна.
В противном случае операция деления будет выполняться над целыми числами.
// Приведение типов для правильного вычисления выражения
class UseCast {
puЫic static void main(String args[]) {
int i;
for(i = О; i < 5; i++)
System.out.println(i + " / 3: " + i / 3);
System.out.println(i + " / 3 с дробной частью: " +
(douЫe) i / 3);
System.out.println();
о
о
1
1
2
2
3
3
4
4
Глава 2. Введение в типы данных и операции над ними 87
Ниже приведен результат выполнения данной программы.
/ 3: о
/ 3 с дробной частью: о.о
/ 3: о
/ 3 с дробной частью: О.3333333333333333
/ 3: о
/ 3 с дробной частью: О.6666666666666666
/ 3: 1
/ 3 с дробной частью: 1.0
/ 3: 1
/ 3 с дробной частью: 1.3333333333333333
Пробелы и круглые скобки
Для повышения удобочитаемости выражений в коде Java в них можно использовать
символы табуляции и пробелы. Например, ниже приведены два варианта одного и того
же выражения, но второй вариант читается гораздо легче.
х=10/у*(127/х);
х = 10 / у * (127/х);
Круглые скобки повышают приоритет содержащихся в них операций (аналогичное
правило применяется и в алгебре). Избыточные скобки допустимы. Они не приводят к
ошибке и не замедляют выполнение программы. В некоторых случаях лишние скобки
даже желательны. Они проясняют порядок вычисления выражения как для вас, так и
для тех, кто будет разбирать исходный код вашей программы. Какое из приведенных
ниже двух выражений воспринимается легче?
х = y/3-34*temp+l27;
х = (у/3) - (34*temp) + 127;
,\../<'
Вопросы и упражнения для самопроверки
1. Почему в Java строго определены диапазоны допустимых значений и области действия
простых типов?
2. Что собой представляет символьный тип в Java и чем он отличается от символьного
типа в ряде других языков программирования?
3. "Переменная типа boolean может иметь любое значение, поскольку любое ненулевое
значение интерпретируется как истинное". Верно или неверно?
88 Java 8: руководство для начинающих. 6-е издание
4. Допустим, результат выполнения программы выглядит следующим образом:
Один
Два
Три
5. Напишите строку кода с вызовом метода println (), где этот результат выводится
в виде одной строки.
6. Какая ошибка допущена в следующем фрагменте кода?
for(i = О; i < 10; i++) {
int sum;
sum = sum + i;
System.out.println{"Cyммa: " + sum);
7. Поясните различие между префиксной и постфиксной формами записи операции
инкремента.
8. Покажите, каким образом укороченная логическая операция И может предотвратить
деление на нуль.
9. До какого типа повышаются типы byte и short при вычислении выражений?
10. Когда возникает потребность в явном приведении типов?
ll. Напишите программу, которая находила бы простые числа в пределах от 2 до 100.
12. Оказывают ли избыточные скобки влияние на эффективность выполнения программ?
13. Определяет ли блок кода область действия переменных?
Глава 3
Управляющие
операторы
90 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
·􀂲 Ввод символов с клавиатуры
t} Полная форма условного оператора if
􀂳 Оператор switch
􀂴 Полная форма цикла for
􀂵 Цикл while
@ Цикл do-while
Е< Использование оператора break дЛЯ выхода из цикла
􀂶 Использование оператора break в качестве оператора goto
41 Оператор continue
8 Вложенные циклы
в этой главе вы познакомитесь с операторами, управляющими ходом выполнения
программы. Существуют три категории управляющих операторов: операторы выбора,
к числу которых относятся if и switch, итерационные операторы, в том числе
операторы цикла for, while, do-while, а также операторы перехода, включая break,
continue и return. Все эти управляющие операторы, кроме return, обсуждаемого позже,
подробно рассматриваются в данной главе, в начале которой будет показано, каким
образом организуется простой ввод данных с клавиатуры.
Ввод символов с клавиатуры
Прежде чем приступать к рассмотрению управляющих операторов в Java, уделим
немного внимания средствам, которые позволяют писать интерактивные программы.
В рассмотренных до сих пор примерах программ данные выводились на экран, но
у пользователя не было возможности вводить данные. В этих программах, в частности,
применялся консольный вывод, но не консольный ввод (с клавиатуры). И объясняется
это тем, что возможности ввода данных с клавиатуры в Java опираются на языковые
средства, рассматриваемые в последующих главах. Кроме того, большинство реальных
программ на Java и аплетов имеют графический и оконный, а не консольный, интерфейс.
Именно по этим причинам консольный ввод нечасто применяется в примерах
программ, представленных в данной книге. Но имеется один вид консольного ввода, который
реализуется очень просто, - это чтение символов с клавиатуры. А поскольку ввод
символов применяется в ряде примеров, представленных в данной главе, мы и начнем
ее с обсуждения данного вопроса.
Для чтения символа с клавиатуры достаточно вызвать метод System. in. read () , где
System. in - объект ввода (с клавиатуры), дополняющий объект вывода System. out.
Метод read () ожидает нажатия пользователем клавиш, после чего возвращает результат.
Возвращаемый им символ представлен целочисленным значением, и поэтому, прежде
чем присвоить его символьной переменной, следует выполнить явное его приведение к
типу char. По умолчанию данные, вводимые с консоли, буферизуются построчно. Под
Глава 3. Управляющие операторы 91
термином буфер здесь подразумевается небольшая область памяти, выделяемая для хранения
символов перед тем, как они будут прочитаны программой. В данном случае в
буфере хранится целая текстовая строка, и поэтому для передачи программе любого введенного
с клавиатуры символа следует нажать клавишу <Enter>. Ниже приведен пример
программы, читающей символы, вводимые с клавиатуры.
// Чтение символа с клавиатуры
class КЫn {
puЫic static void main(String args[J)
throws java.io.IOException {
char ch;
System.out.print("Haжмитe нужную клавишу, а затем
клавишу ENTER: ");
ch = (char) System.in.read(); // получить символ
System.out.println("Bы нажали клавишу " + ch);
-----Ввод снмаоnа
с кnавнатур
Выполнение этой программы может дать, например, следующий результат.
Нажмите нужную клавишу, а затем клавишу ENTER: t
Вы нажали клавишу t
Обратите внимание на то, что метод main () начинается со следующих строк кода.
puЫic static void main(String args[])
throws java.io.IOException {
В рассматриваемой здесь программе применяется метод System. in. read () , и поэтому
в ее код следует ввести оператор throws j ava. io. IOException. Этот оператор требуется
для обработки ошибок, которые могут возникнуть в процессе ввода данных. Он
является частью механизма обработки исключений в Java, более подробно рассматриваемого
в главе 9. А до тех пор можете не обращать на него особого внимания, однако
помните о его назначении.
Построчная буферизация вводимых данных средствами System. in часто приводит к
недоразумениям. При нажатии клавиши <Enter> в поток ввода записывается последовательность,
состоящая из символов возврата каретки и перевода строки. Эти символы
ожидают чтения из буфера ввода . Поэтому в некоторых приложениях, возможно, потребуется
удалить символы возврата каретки и перевода строки, прежде чем переходить к
следующей операции ввода. Для этого достаточно прочитать их из буфера ввода. Соответствующий
пример реализации подобного решения на практике будет представлен далее.
Условный оператор if
Этот условный оператор уже был представлен в главе 1, а здесь он будет рассмотрен
более подробно. Условные операторы называют также операторами ветвления, поскольку
с их помощью выбирается ветвь кода, подлежащая выполнению. Ниже приведена
полная форма условного оператора if.
if(условие) оператор;
else оператор;
92 Java 8: руководство для начинающих, 6-е издание
Здесь условие - это некоторое условное выражение, а опера тор - адресат операторов
if и else. Оператор else не является обязательным. Адресатами обоих операторов,
if и else, могут также служить блоки операторов. Ниже приведена общая форма
условного оператора if, в котором используются блоки операторов.
if (условие)
{
последовательность операторов
else
последовательность операторов
Если условное выражение оказывается истинным, то выполняется ветвь оператора
if. В противном случае выполняется ветвь оператора else, если таковой существует.
Выполнение сразу двух ветвей невозможно. Условное выражение, управляющее оператором
if, должно давать результат типа bool.
Для того чтобы продемонстрировать применение оператора if (и ряда других управляющих
операторов) на практике, разработаем простую игру, основанную на угадывании.
Возможно, она понравится вашим детям. В первой версии этой игры программа
предложит пользователю угадать задуманную букву от А до z. Если пользователь правильно
угадает букву и нажмет на клавиатуре соответствующую клавишу, программа выведет
сообщение * * Правильно! * *. Ниже приведен исходный код программы, реализующей
эту игру.
//Игра в угадывание букв.
class Guess {
puЬlic static void main(String args[])
throws java.io.IOException
char ch, answer = 'S';
System.out.println("Зaдyмaнa буква из диапазона A-Z. 11);
System.out.print("Пoпытaйтecь ее угадать: ");
ch = (char) System.in.read(); // получить символ с клавиатуры
if(ch == answer) System.out.println("** Правильно! **");
Эта программа выводит на экран сообщение с предложением угадать букву, а затем
читает символ с клавиатуры. Используя условный оператор if, она сравнивает введенный
символ с правильным ответом (в данном случае это буква S). Если введена буква S,
то отображается сообщение о том, что ответ правильный. Работая с этой программой, не
забывайте, что угадываемую букву следует вводить в верхнем регистре.
В следующей версии программы оператор else используется для вывода сообщения
о том, что буква не была угадана.
//Игра в угадывание букв, вторая версия
class Guess2 {
puЫic static void main(String args[])
throws java.io.IOException {
char ch, answer = 'S';
Глава 3. Управляющие операторы 93
System.out.println("Зaдyмaнa буква из диапазона A-Z.");
System.out.print("Пoпытaйтecь ее угадать: ");
ch = (char) System.in.read(); // получить символ с клавиатуры
if(ch == answer} System.out.println("** Правильно! **");
else System.out.println(" ...И звинитe, вы не угадали.");
Вложенные условные операторы if
Вложенные операторы if представляют собой условные операторы, являющиеся
адресатами другого оператора if или оператора else. Подобные условные операторы
очень часто встречаются в программах. Но, пользуясь ими, следует помнить, что в Java
оператор else всегда связан с ближайшим к нему оператором if, находящимся в том же
блоке кода и не связанным с другим оператором else. Рассмотрим следующий пример.
if(i == 10) {
if(j < 20) а = Ь;
if(k > 100) с = d;
else а = с; // этот оператор else относится
// к оператору if(k > 100)
else а = d; // а этот оператор else относится
// к оператору if(i == 10)
Как следует из комментариев к приведенному выше фрагменту кода, последний
оператор else не имеет отношения к оператору if ( j < 20), поскольку он не находится
с ним в одном блоке, несмотря на то что это ближайший оператор if, не имеющий парного
оператора else. Следовательно, последний оператор else относится к оператору
if (i == 10). А оператор else, находящийся в блоке, связан с оператором if (k > 100),
поскольку это самый близкий из всех находящихся к нему операторов if в том же самом
блоке.
Используя вложенные условные операторы if, можно усовершенствовать игру, рассматриваемую
здесь в качестве примера. Теперь при неудачной попытке угадать букву
пользователю предоставляется дополнительная информация, подсказывающая, на-
сколько велико расхождение с правильным ответом.
//Игра в угадывание букв, третья версия
class GuessЗ {
puЫic static void main(String args[])
throws java.io.IOException
char ch, answer = 'S';
System.out.println("Зaдyмaнa буква из диапазона A-Z.");
System.out.print("Пoпытaйтecь ее угадать: ");
94 Java 8: руководство для начинающих. 6-е издание
ch = (char) System.in.read(); // получить символ с клавиатуры
if(ch == answer) System.out.println("** Правильно! **");
else {
System.out.print(" ... Извинитe, нужная буква находится 11);
Впоженный оператор if
L
// вложенный оператор if
if (ch < answer)
System.out.println("ближe к концу алфавита");
else System.out.println("ближe к началу алфавита");
Выполнение этой программы может дать, например, следующий результат.
Задумана буква из диапазона A-Z.
Попытайтесь ее угадать: Z
... Извините, нужная буква находится ближе к началу алфавита.
Многоступенчатая конструкция if-else-if
В программировании часто применяется многоступенчатая конструкция if-else-if,
состоящая из вложенных условных операторов if. Ниже приведен ее общий синтаксис.
if (условие)
оператор;
else if (условие)
оператор;
else if (условие)
оператор;
else
оператор;
Условные выражения в такой конструкции вычисляются сверху вниз. Как только обнаружится
истинное условие, выполняется связанный с ним оператор, а все остальные
операторы в многоступенчатой конструкции опускаются. Если ни одно из условий не
является истинным, то выполняется последний оператор else, который зачастую играет
роль условия, устанавливаемого по умолчанию. Когда же последний оператор else
отсутствует, а все остальные проверки по условию дают ложный результат, никаких действий
вообще не выполняется.
Ниже приведен пример программы, демонстрирующий применение многоступенчатой
конструкции if-else-if.
// Демонстрация многоступенчатой конструкции if-else-if
class Ladder {
puЫic static void main (String args []) {
int х;
for (х= О; х<б; х++) {
if (x== l)
Глава 3. Управляющие операторы 95
System.out.println("x равно единице");
else if(x== 2)
System.out.println("x равно двум");
else if(x== З)
System.out.println("x равно трем");
else if (х== 4)
System.out.println("x равно четырем");
else
// Условие, выполняемое по умолчанию.
System.out.println("Знaчeниe х находится вне диапазона 1 - 4");
Выполнение этой программы дает следующий результат.
Значение х находится вне диапазона 1 - 4
х равно единице
х равно двум
х равно трем
х равно четырем
Значение х находится вне диапазона 1 - 4
Как видите, устанавливаемый по умолчанию условный оператор else выполняется
лишь в том случае, если проверка условий каждого из предыдущих операторов if дает
ложный результат.
Оператор swi tch
Вторым оператором выбора в Java является swi tch, или переключатель, который
обеспечивает многовариантное ветвление программы. Этот оператор позволяет сделать
выбор среди нескольких альтернативных вариантов (ветвей) дальнейшего выполнения
программы. Несмотря на то что многовариантная проверка может быть организована
с помощью последовательного ряда вложенных условных операторов if,
во многих случаях более эффективным оказывается применение оператора switch.
Он действует следующим образом . Значение выражения последовательно сравнивается
с константами из заданного списка. Как только будет обнаружено совпадение,
выполняется соответствующая последовательность операторов. Ниже приведен общий
синтаксис оператора swi tch.
switсh(выражение) {
case константаl:
последовательность операторов
break;
case константа2:
последовательность операторов
break;
case константа]:
последовательность операторов
break;
96 Java 8: руководство для начинающих. 6-е издание
default:
последовательность операторов
В версиях Java, предшествующих JDK 7, выражение, управляющее оператором
switch, должно быть типа byte, short, int, char или перечислением. (Подробнее о перечислениях
речь пойдет в главе 12.)
Начиная с версии JDK 7 выражение может относиться к типу String. Эrо означает,
что в современных версиях Java для управления оператором swi tch можно пользоваться
символьной строкой. (Эrот прием программирования демонстрируется в главе 5 при
рассмотрении класса String.) Но зачастую в качестве выражения, управляющего оператором
swi tch, вместо сложного выражения используется простая переменная.
Последовательность операторов из ветви default выполняется в том случае, если
ни одна из констант выбора не совпадает с заданным выражением. Ветвь default не
является обязательной. Если же она отсутствует и выражение не совпадает ни с одним
из условий выбора, то никаких действий вообще не выполняется. Если же происходит
совпадение с одним из условий выбора, то выполняются операторы, связанные с этим
условием, вплоть до оператора break.
Ниже приведен пример программы, демонстрирующий применение оператора
switch.
// Демонстрация использования оператора switch
class SwitchDemo {
puЫic static void main (String args []) {
int i;
for(i=O; i<lO; i++)
switch(i) {
case О:
System.out.println("i равно нулю");
break;
case 1:
System.out.println("i равно единице");
break;
case 2:
System.out.println("i равно двум");
break;
case 3:
System.out.println("i равно трем");
break;
case 4:
System.out.println("i равно четырем");
break;
default:
System.out.println("i равно или больше пяти");
i
i
i
i
i
i
i
i
i
i
Глава 3. Управляющие операторы 97
Результат выполнения данной программы выглядит следующим образом.
равно нулю
равно единице
равно двум
равно трем
равно четырем
равно или больше пяти
равно или больше пяти
равно или больше пяти
равно или больше пяти
равно или больше пяти
Как видите, на каждом шаге цикла выполняются операторы, связанные с совпадающей
константой выбора в одной из ветвей case, в обход всех остальных ветвей. Когда
же значение переменной i становится равным или больше пяти, оно не совпадает ни с
одной из констант выбора, и поэтому управление получает выражение, следующее за
оператором default.
Формально оператор break может отсутствовать, но, как правило, в реальных приложениях
он применяется. При выполнении оператора break оператор swi tch завершает
работу, и управление передается следующему за ним оператору. Если же в последовательности
операторов, связанных с совпадающей константой выбора в одной из ветвей
case, не содержится оператор break, то сначала выполняются все операторы в этой ветви,
а затем операторы, совпадающие с константой выбора в следующей ветви case. Этот
процесс продолжается до тех пор, пока не встретится оператор break или же не будет
достигнут конец оператора swi tch.
В качестве упражнения проанализируйте исходный код приведенной ниже программы.
Сможете ли вы предсказать, как будет выглядеть результат ее выполнения?
// Демонстрация использования оператора switch без оператора break
class NoBreak {
puЫic static void main(String args[]) {
int i;
for (i=O; i<=5; i++) {
switch (i) {
case О:
System.out.println("i
case 1:
System.out.println("i
case 2:
System.out.println("i
case 3:
System.out.println("i
case 4:
System.out.println("i
System.out.println();
меньше единицы");
меньше двух");
меньше трех");
меньше четырех");
меньше пяти");
Проаоnивание патока выnоnнения
сквозь операторы case
98 Java 8: руководство для начинающих. 6-е издание
Выполнение этой программы дает следующий результат.
i меньше единицы
i меньше двух
i меньше трех
i меньше четырех
i меньше пяти
i меньше двух
i меньше трех
i меньше четырех
i меньше пяти
i меньше трех
i меньше четырех
i меньше пяти
i меньше четырех
i меньше пяти
i меньше пяти
Как демонстрирует приведенный выше пример, в отсутствие оператора break выполнение
программы продолжается в следующей ветви case. А в следующем примере
кода показано, что в операторе swi tch могут присутствовать пустые ветви case.
switch(i)
case 1:
case 2:
case 3: System.out.println("i равно 1, 2 или З");
break;
case 4: System.out.println("i равно 4");
break;
Если в приведенном выше фрагменте кода переменная i имеет значение 1, 2 или 3,
то вызывается первый метод println (). А если ее значение равно 4, вызывается второй
метод println (). Такое расположение нескольких пустых ветвей case подряд нередко
используется в тех случаях, когда нескольким ветвям должен соответствовать один и тот
же общий код.
Вложенные операторы swi tch
Один оператор swi tch может быть частью последовательности операторов другого,
внешнего оператора swi tch. Такой оператор swi tch называется вложенным. Константы
выбора внутреннего и внешнего операторов swi tch могут содержать общие значения,
не вызывая никаких конфликтов. Например, следующий фрагмент кода является вполне
допустимым.
switch(chl)
case 'А': System.out.
println("Этo раздел А внешнего оператора switch");
switch (ch2) {
case 'А':
System.out.
Глава 3. Управляющие операторы 99
println{"Этo раздел А внутреннего оператора switch");
break;
case 'В':// ...
// конец внутреннего оператора switch
break;
case 'B'://
Упражнение 3.1 Начало построения справочной системы Java
................................
.1 ..н .. e_ i _ P_ . .·. J·.• •a ._v___ а __ ...... .· В этом проекте предстоит создать простую сnравочную систему, пре- доставляющую сведения о синтаксисе управляющих операторов Java.
Программа, реализующая эту справочную систему, отображает меню с названиями
операторов и ожидает выбора одного из них. Как только пользователь выберет один из
пунктов меню, на экран будут выведены сведения о синтаксисе соответствующего оператора.
В первой версии данной программы предоставляются сведения только об операторах
if и switch. А в последующих проектах будут добавлены справочные сведения об
остальных управляющих операторах. Поэтапное описание процесса создания программы
приведено ниже.
1. Создайте новый файл Help. java.
2. В начале работы программы отображается следующее меню.
Справка:
1. if
2. switch
Выберите:
Это осуществляется с помощью приведенной ниже последовательности операторов.
System.out.println("Cпpaвкa:");
System.out.println(" 1. if");
System.out.println(" 2. switch");
System.out.print{"Bыбepитe: ");
3. Далее программа получает данные о выборе пользователя. С этой целью вызывается
метод System. in. read (), как показано ниже.
choice = {char) System.in.read{);
4. После этого для отображения сведений о синтаксисе выбранного оператора в
программе используется оператор swi tch.
switch{choice) {
case '1':
System.out.println("Oпepaтop if:\n");
System.out.println{"if{ycлoвиe) оператор;");
System.out.println{"else оператор;");
break;
case '2':
System.out.println("Oпepaтop switch:\n");
System.out.println("switch(выpaжeниe) {");
System.out.println(" case константа:");
100 Java 8: руководство для начинающих. 6-е издание
System.out.println(" последовательность операторов");
System.out.println(" break;");
System.out.println(" // ... ");
System.out.println("}");
break;
default:
System.out.print("Зaпpoc не найден.");
Обратите внимание на то, как в ветви defaul t перехватываются сведения о неправильно
сделанном выборе. Так, если пользователь введет значение З, оно не
совпадет ни с одной из констант в ветвях case оператора swi tch, и тогда управление
будет передано коду в ветви defaul t.
5. Ниже приведен весь исходный код программы из файла Help. java.
/*
Упражнение 3.1
.. Простая справочная система
*/
class Help {
puЫic static void main(String args[J)
throws java.io.IOException
char choice;
System.out.println("Cnpaвкa:");
System.out.println(" 1. if");
System.out.println(" 2. switch");
System.out.print("Bыбepитe: ");
choice = (char) System.in.read();
System.out.println("\n");
switch (choice) {
case '1':
System.out.println("Oпepaтop if:\n");
System.out.println("if(ycлoвиe) оператор;");
System.out.println("else оператор;");
break;
case '2':
System.out.println("Oпepaтop switch:\n");
System.out.println("switch(выpaжeниe) {");
System.out.println(" case константа:");
System.out.println(" последовательность операторов");
System.out.println(" break;");
System.out.println(" // ... ");
System.out.println("}");
break;
default:
System.out.print("Зaпpoc не найден.");
Глава 3. Управляющие операторы 101
6. Выполнение этой программы дает следующий результат.
Справка:
1. if
2. switch
Выберите: 1
Оператор if:
if(условие) оператор;
else оператор;
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. В каких случаях вместо оператора swi tch следует использовать многоступенчатую
конструкцию if-else-if?
ОТВЕТ. Вообще говоря, многоступенчатая конструкция if-else-if уместна в тех
случаях, когда проверка условий не сводится к выяснению совпадения или несовпадения
выражения с одиночным значением. Рассмотрим для примера следующую
последовательность условных операторов.
if(x < 10) // ...
else if(y != О) //
else if(!doпe) // ...
Данную последовательность нельзя заменить оператором swi tch, поскольку в
трех ее условиях используются разные переменные и разные виды сравнения.
Многоступенчатую конструкцию if-else-if целесообразно также применять
для проверки значений с плавающей точкой и других объектов, типы которых
отличаются от типов, предусмотренных для ветвей оператора swi tch.
Цикл for
Цикл for уже бьut представлен в главе l, а здесь он рассматривается более подробно.
Вас должны приятно удивить эффективность и гибкость этого цикла. Прежде всего обратимся
к самым основным и традиционным формам цикла for.
Ниже приведен общий синтаксис цикла for для повторного выполнения единственного
оператора:
fоr(инициализация; условие; итерация) оператор;
А вот как выглядит его синтаксис для повторного выполнения блока кода.
fоr(инициализация; условие; итерация)
{
последовательность операторов;
102 Java 8: руководство для начинающих. 6-е издание
Здесь инициализация, как правило, представлена оператором присваивания, задающим
первоначальное значение переменной, которая иrрает роль счетчика и управляет циклом;
условие - это логическое выражение, определяющее необходимость повторения
цикла; а итерация - выражение, определяющее величину, на которую должно изменяться
значение переменной, управляющей циклом, на каждом шаге цикла. Обратите внимание
на то, что эти три основные части оператора цикла for должны быть (NЦЦелены точкой
с запятой. Выполнение цикла for будет продолжаться до тех пор, пока проверка условия
дает истинный результат. Как только эта проверка даст ложный результат, цикл завершится,
а выполнение проrраммы будет продолжено с оператора, следующего после цикла for.
Ниже приведен пример проrраммы, где цикл for служит для вывода на экран значений
квадратного корня чисел в пределах от 1 до 99. В данной проrрамме отображается
также ошибка округления, допущенная при вычислении квадратного корня.
// Вывод квадратных корней чисел от 1 до 99
// вместе с ошибкой округления
class SqrRoot {
puЫic static void main(String args[]) {
douЫe num, sroot, rerr;
for(num = 1.0; num < 100.0; num++) {
sroot = Math.sqrt(num);
System.out.println(11 Kopeнь квадратный из 11 + num +
II равен 1
1 + sroot);
// вычислить ошибку округления
rerr = num - (sroot * sroot);
System.out.println( 11 0шибкa округления: 11 + rerr);
System.out.println();
Обратите внимание на то, что ошибка округления вычисляется путем возведения в
квадрат квадратного корня числа. Полученное значение вычитается из исходного числа.
Переменная цикла может как увеличиваться, так и уменьшаться, а величина приращения
может выбираться произвольно. Например, в приведенном ниже фрагменте кода
выводятся числа в пределах от 100 до -95, и на каждом шаге переменная цикла уменьшается
на 5.
// Цикл for, выполняющийся с отрицательным приращением переменной
class DecrFor (
puЫic static void main (String args []) (
int х;
for(x = 100; х > -100; х
System.out.println(x);
5) ----- Но каждой итерации перемеииоа цикпо
уменьwоетса но 5
В отношении циклов for следует особо подчеркнуть, что условное выражение всегда
проверяется в самом начале цикла. Это означает, что код в цикле может вообще не выполняться,
если проверяемое условие с самого начала оказывается ложным. Рассмотрим
следующий пример.
Глава 3. Управляющие операторы 103
for(count=lO; count < 5; count++)
х += count; // этот оператор не будет выполнен
Этот цикл вообще не будет выполняться, поскольку первоначальное значение переменной
count, которая им управляет, сразу же оказывается больше 5. А это означает, что
условное выражение count < 5 оказывается ложным с самого начала, т.е. еще до выполнения
первого шага цикла.
Некоторые разновидности цикла for
Цикл for относится к наиболее универсальным операторам языка Java, поскольку он
допускает самые разные варианты применения. Например, для управления циклом можно
использовать несколько переменных. Рассмотрим следующий пример программы.
// Применение запятых в операторе цикла for
class Cornma {
i
i
i
i
i
puЫic static void main(String args[]) {
int i, j;
for (i=O, j=lO; i < j; i++, j--)
System.out.println("i и j: " + i
. ___ Дnя уnровnення этнм цнкnом
нспоnьзуются две переменные
+ " " +j);
Выполнение этой программы дает следующий результат.
и j : о 10
и j: 1 9
и j: 2 8
и j: 3 7
и j: 4 6
В данном примере запятыми разделяются два оператора инициализации и еще два
итерационных выражения. Когда цикл начинается, инициализируются обе переменные,
i и j. Всякий раз, когда цикл повторяется, переменная i инкрементируется, а переменная
j декрементируется. Применение нескольких переменных управления циклом
нередко оказывается удобным и у1;1рощает некоторые алгоритмы. Теоретически в цикле
for может быть указано любое количество операторов инициализации и итерации, но
на практике такой цикл получается слишком громоздким, если применяется больше
двух подобных операторов.
Условным выражением, управляющим циклом for, может быть любое действительное
выражение, дающее результат типа bool. В него не обязательно должна входить переменная
управления циклом. В следующем примере программы цикл будет выполняться
до тех пор, пока пользователь не введет с клавиатуры букву s.
// Выполнение цикла до тех пор, пока с клавиатуры
!/ не будет введена буква S
class ForTest {
puЬlic static void main(String args[])
throws java.io.IOException {
int i;
104 Java 8: руководство для начинающих, 6-е издание
System.out.println("Для остановки нажмите клавишу S");
for(i = О; (char) System.in.read() != 'S'; i++)
System.out.println("Пpoxoд #" + i);
Пропуск отдельных частей
в определении цикла for
Ряд интересных разновидностей цикла for получается в том случае, если оставить
пустыми отдельные части в определении цикла. В Java допускается оставлять пустыми
любые или же все части инициализации, условия и итерации в операторе цикла for.
В качестве примера рассмотрим следующую программу.
// Пропуск отдельных составляющих в определении цикла for
class Empty {
puЫic static void main(String args[]) {
int i;
for (i = О; i < 10; ) { 4---- Отсуrствует итерационное выражение
System.out.println("Пpoxoд #" + i);
i++; // инкрементировать переменную цикла
В данном примере итерационное выражение в определении цикла for оказывается
пустым, т.е. вообще отсутствует. Вместо этого переменная i, управляющая циклом, инкрементируется
в теле самого цикла. Это означает, что всякий раз , когда цикл повторяется,
значение переменной i проверяется на равенство числу 10, но никаких других
действий при этом не происходит. А поскольку переменная i инкрементируется в теле
цикла, то сам цикл выполняется обычным образом, выводя приведенный ниже результат.
Проход #0
Проход #1
Проход #2
Проход #3
Проход #4
Проход #5
Проход #6
Проход #7
Проход #8
Проход #9
В следующем примере программы из определения цикла for исключена инициализирующая
часть.
// Пропуск отдельных составляющих в определении цикла for
class Empty2 {
puЫic static void main(String args[]) {
int i;
Глава 3. Управляющие операторы 105
+ Из оnредеnения 􀀬IUIO ИСКJ11Очено ини􀀬аnизнрующее аыраженне
i О;
for (; i < 10; ) {
System.out.println("Пpoxoд #" + i);
i++; // инкрементировать переменную цикла
В данном примере переменная i инициализируется перед началом цикла, а не в самом
цикле for. Как правило, переменная управления циклом инициализируется в цикле
for. Выведение инициализирующей части за пределы цикла обычно делается лишь в том
случае, если первоначальное значение упрамяющей им переменной получается в результате
сложного процесса, который нецелесообразно вводить в само определение цикла for.
Бесконечный цикл
Если оставить пустым выражение условия в определении цикла for, то получится
бесконечный цикл, т.е. такой цикл, который никогда не завершается. В качестве примера
в следующем фрагменте кода показано, каким образом в Java обычно создается бесконечный
цикл:
for(;;) // цикл, намеренно сделанный бесконечным
{
// . . .
Этот цикл будет выполняться бесконечно. Несмотря на то что бесконечные циклы
требуются для решения некоторых задач программирования, например при разработке
командных процессоров операционных систем, большинство так называемых "бесконечных"
циклов на самом деле предстамяют собой циклы со специальными требованиями
к завершению. (Далее мы поговорим об этом более подробно, однако уже сейчас
можно заметить, что в большинстве случаев выход из бесконечного цикла осуществляется
с помощью оператора break.)
Циклы без тела
В Java допускается остамять пустым тело цикла for или любого другого цикла, поскольку
пустой оператор с точки зрения синтаксиса этого языка считается действительным.
Циклы без тела нередко оказываются полезными. Например, в следующей программе
цикл без тела служит для получения суммы чисел от 1 до 5.
// Тело цикла for может быть пустым
class EmptyЗ {
puЫic static void main(String args[])
int i;
int sum = О;
for(i = 1; i <= 5; sum += i++) ----- В цн1U1е отсутстаует тenol
System.out.println("Cyммa: " + sum);
106 Java 8: руководство для начинающих. 6-е издание
Выполнение этой программы дает следующий результат:
Сумма: 15
Обратите внимание на то, что процесс суммирования чисел выполняется полностью
в операторе цикла for, и для этого тело цикла не требуется. В этом цикле особое внимание
обращает на себя итерационное выражение:
sum += i++
Подобные операторы не должны вас смущать. Они часто встречаются в программах,
профессионально написанных на Java, и становятся вполне понятными, если разобрать
их по частям. Приведенный выше оператор означает буквально следующее: сложить со
значением переменной sum результат суммирования значений переменных sum и i, а затем
инкрементировать значение переменной i. Следовательно, данный оператор равнозначен
следующей последовательности операторов.
sum = sum + i;
i++;
Объявление управляющих
переменных в цикле for
Нередко переменная цикла for, требуется только для выполнения самого цикла и
нигде больше не используется. В таком случае ее можно объявить в инициализирующей
части оператора цикла for. Например, в приведенной ниже программе вычисляются
сумма и факториал чисел от 1 до 5, а переменная i, управляющая циклом for, объявляется
в самом цикле.
// Объявление переменной цикла в самом цикле for
class ForVar {
puЬlic static void main ( String args []) {
int sum = О;
int fact = 1;
// Вычисление факториала чисел от 1 до 5
for ( int i = 1; i <= 5; i ++) { Переменная i 061,явnяется в сомом операторе for
sum += i; // переменная i доступна во всем цикле
fact *= i;
// однако здесь переменная i недоступна
System.out.println("Cyммa: " + sum);
System.out.println("Фaктopиaл: " + fact);
Объявляя переменную в цикле for, не следует забывать о том, что область действия
этой переменной ограничивается пределами оператора цикла for. Это означает, что
за пределами цикла действие данной переменной прекращается. Так, в приведенном
выше примере переменная i оказывается недоступной за пределами цикла for. Для того
Глава 3. Управляющие операторы 107
чтобы использовать переменную управления циклом в каком-нибудь другом месте программы,
ее нельзя объявлять в цикле for.
Прежде чем переходить к чтению последующих разделов, поэкспериментируйте самостоятельно
с различными разновидностями цикла for. В ходе эксперимента вы непременно
обнаружите замечательные свойства этого цикла.
Расширенный цикл f or
С недавних пор в распоряжение программистов на Java предоставлен так называемый
расширенный цикл for, обеспечивающий специальные средства для перебора
объектов из коллекции, например из массива. Расширенный цикл for будет представлен
в главе 5 при рассмотрении массивов.
Цикл while
Еще одной разновидностью циклов в Java является цикл while. Ниже приведен общий
синтакис этого цикла:
while (условие) оператор;
где опера тор - это одиночный оператор или блок операторов, а условие означает
конкретное условие управления циклом и может быть любым логическим выражением.
В этом цикле опера тор выполняется до тех пор, пока условие истинно. Как только
условие становится ложным, управление программой передается строке кода, следующей
непосредственно после цикла.
Ниже приведен простой пример использования цикла while для вывода на экран
букв английского алфавита.
!/ Демонстрация использования цикла while
class WhileDemo
puЫic static void main(String args[]) {
char ch;
/! вывести буквы английского алфавита, используя цикл while
ch = 'а';
while(ch <= 'z')
System.out.print(ch);
ch++;
В данном примере переменная ch инициализируется кодом буквы а. На каждом шаге
цикла на экран сначала выводится значение переменной ch, а затем это значение увеличивается
на единицу. Процесс продолжается до тех пор, пока значение переменной ch
не станет больше кода буквы z.
Как и в цикле for, в цикле while проверяется условное выражение, указываемое в
самом начале цикла. Это означает, что код в теле цикла может вообще не выполняться,
а кроме того, избавляет от необходимости выполнять отдельную проверку перед самим
циклом. Данное свойство цикла while демонстрируется в следующем примере программы,
где вычисляются целые степени числа 2 от О до 9.
108 Java 8: руководство для начинающих. 6-е издание
// Вычисление целых степеней числа 2
class Power {
2
2
2
2
2
2
puЫic static void main(String args[])
int е;
int result;
for (int i=O; i < 10; i++) {
result = 1;
е = i;
while (е > О)
result *= 2;
е--;
System.out.println("2 в степени " + i +
" равно " + result);
Ниже приведен результат выполнения данной программы.
в степени о равно 1
в степени 1 равно 2
в степени 2 равно 4
в степени 3 равно 8
в степени 4 равно 16
в степени 5 равно 32
2 в степени 6 равно 64
2 в степени 7 равно 128
2 в степени 8 равно 256
2 в степени 9 равно 512
Обратите внимание на то, что цикл while выполняется только в том случае, если
значение переменной е больше нуля. А когда оно равно нулю, как это имеет место на
первом шаге цикла for, цикл while пропускается.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. В языке Java циклы обладают большой гибкостью. Как же в таком случае
выбрать цикл, наиболее подходящий для решения конкретной задачи?
ОТВЕТ. Если число итераций известно заранее, то лучше выбрать цикл for. Цикл
while оказывается наиболее удобным тогда, когда число повторений цикла заранее
неизвестно. В тех случаях, когда требуется, чтобы была выполнена хотя
бы одна итерация, используйте цикл do-while.
Глава 3. Управляющие операторы 109
Цикл do-while
Третьей и последней разновидностью циклов в Java является цикл do-while. В отличие
от циклов for и while, в которых условие проверялось в самом начале (предусловие),
в цикле do-while условие выполнения проверяется в самом конце (постусловие).
Это означает, что цикл do-while всегда выполняется хотя бы один раз. Ниже приведен
общий синтаксис цикла do-while.
do {
операторы;
while (условие);
При наличии лишь одного оператора фигурные скобки в данной форме записи необязательны.
Тем не менее они зачастую используются для того, чтобы сделать конструкцию
do-while более удобочитаемой и не путать ее с конструкцией цикла while. Цикл
do-while выполняется до тех пор, пока условное выражение истинно.
// Демонстрация использования цикла do-while
class DWDemo {
puЫic static void main(String args[J)
throws java.io.IOException
char ch;
do {
System.out.
рrint{"Нажмите нужную клавишу, а затем клавишу <ENTER>: ");
ch = (char) System.in.read(); // получить символ с клавиатуры
while(ch != 'q');
Используя цикл do-while, мы можем усовершенствовать игру в угадывание букв,
созданную в начале главы. На этот раз выполнение цикла будет продолжаться до тех
пор, пока пользователь не угадает букву.
//Игра в угадывание букв, четвертая версия
class Guess4 {
puЫic static void main(String args[J)
throws java.io.IOException {
char ch, ignore, answer = 'S';
do {
System.out.println("Зaдyмaнa буква из диапазона A-Z.");
System.out.print("Пoпытaйтecь ее угадать: ");
// Получить символ с клавиатуры
ch = (char) System.in.read();
// Отбросить все остальные символы во входном буфере
do {
ignore = (char) System.in.read();
} while(ignore != '\n');
11 О Java 8: руководство для начинающих, 6-е издание
if(ch == answer) System.out.println("** Правильно! **");
else {
System.out.print(" ... Извинитe, нужная буква находится ");
if(ch < answer)
System.out.println("ближe к концу алфавита");
else System.out.println("ближe к началу алфавита");
System.out.println("Пoвтopитe попытку!\n");
while(answer != ch);
Ниже приведен один из возможных вариантов выполнения данной проrраммы в интерактивном
режиме.
Задумана буква из диапазона A-Z.
Попытайтесь ее угадать: А
... Извините, нужная буква находится ближе к концу алфавита
Повторите попытку!
Задумана буква из диапазона A-Z.
Попытайтесь ее угадать: Z
... Извините, нужная буква находится ближе к началу алфавита
Повторите попытку!
Задумана буква из диапазона A-Z.
Попытайтесь ее угадать: S
** Правильно! **
Обратите внимание на еще одну интересную особенность данной проrраммы: в ней
применяются два цикла do-while. Первый цикл выполняется до тех пор, пока пользователь
не введет правильную букву. А второй цикл приведен ниже и требует дополнительных
пояснений.
// Отбросить все остальные символы во входном буфере
do {
ignore = (char) System.in.read();
} while(ignore != '\n');
Как пояснялось ранее, консольный ввод буферизуется построчно. Это означает,
что для передачи символов, вводимых с клавиатуры, приходится нажимать клавишу
<Enter>, что приводит к формированию последовательности символов перевода строки
и возврата каретки. Эти символы сохраняются во входном буфере вместе с введенными
с клавиатуры. Кроме того, если ввести с клавиатуры несколько символов подряд, не нажав
клавишу <Enter>, они так и останутся во входном буфере.
В рассматриваемом здесь цикле эти символы отбрасываются до тех пор, пока не будет
достигнут конец строки. Если не сделать этого, лишние символы будут передаваться
проrрамме в качестве выбранной буквы, что не соответствует действительности. (Для того
чтобы убедиться в этом, попробуйте закомментировать внутренний цикл do-while в исходном
коде проrраммы.) После представления ряда других языковых средств Java в главе
10 будут рассмотрены более совершенные способы обработки консольного ввода. Но
применение метода read () в данной проrрамме дает элементарное представление о принципе
действия системы ввода-вывода в Java. А кроме того, в данной проrрамме демонстрируется
еще один пример применения циклов в практике проrраммирования на Java.
Глава 3. Управляющие операторы 111
Упражнение 3.2 Расширение справочной системы
:············ .................. : \ Help2.java \ В этом проекте нам предстоит расширить справочную систему Java,
, .............................. , созданную в упражнении 3.1. В эту версию программы будут добавле-
ны сведения о синтаксисе циклов for, while и do-while. Кроме того, будет реализована
проверка действий пользователя, работающего с меню. Цикл будет повторяться до
тех пор, пока пользователь не введет допустимое значение.
1. Скопируйте файл Help. java в новый файл Help2. java.
2. Измените часть программы, ответственную за отображение вариантов, предлагаемых
пользователю на выбор. Реализуйте ее с помощью циклов.
puЫic static void main(String args[])
throws java.io.IOException {
char choice, ignore;
do {
System.out.println("Cnpaвкa:");
System.out.println(" 1. if");
System.out.println(" 2. switch");
System.out.println(" З. for");
System.out.println(" 4. while");
System.out.println(" 5. do-while\n");
System.out.print("Bыбepитe: ");
choice = (char) System.in.read();
do {
ignore = (char) System.in.read();
} while(ignore != '\n');
while ( choice < '1' 1 choice > '5') ;
Обратите внимание на вложенные циклы do-while, используемые с целью избавиться
от нежелательных символов, оставшихся во входном буфере. После внесения
приведенных выше изменений программа будет отображать меню в цикле до
тех пор, пока пользователь не введет числовое значение в пределах от 1 до 5.
3. Дополните оператор swi tch выводом на экран сведений о синтаксисе циклов
for, while и do-while.
switch(choice) {
case '1':
System.out.println("Oпepaтop if:\n");
System.out.println("if(ycлoвиe) оператор;");
System.out.println("else оператор;");
break;
case '2':
System.out.println("Oпepaтop switch:\n");
System. out. println ( "swi tch (выражение) { ") ;
System.out.println(" case константа:");
System.out.println(" последовательность операторов");
System.out.println(" break;");
System.out.println(" // ... ");
System.out.println("}");
break;
112 Java 8: руководство для начинающих. 6-е издание
case '3':
System.out.println("Oпepaтop for:\n");
System.out.print("for(инициaлизaция; условие; итерация)");
System.out.println(" оператор;");
break;
case '4':
System.out.println("Oпepaтop while:\n");
System.out.println("while(ycлoвиe) оператор;");
break;
case '5':
System.out.println("Oпepaтop do-while:\n");
System.out.println("do {");
System.out.println(" оператор;");
System.out.println("} while (условие);");
break;
Обратите внимание на то, что в данном варианте оператора swi tch отсутствует
ветвь default. А поскольку цикл отображения меню будет выполняться до тех
пор, пока пользователь не введет допустимое значение, необходимость в обработке
неправильных значений отпадает.
4. Ниже приведен весь исходный код программы из файла Help2. java.
/*
Упражнение 3.2
Расширенная справочная система, в которой для обработки
результатов выбора из меню используется цикл do-while
*/
class Help2 {
puЫic static void main(String args[J)
throws java.io.IOException
char choice, ignore;
do {
System.out.println("Cпpaвкa:");
System.out.println(" 1. if");
System.out.println(" 2. switch");
System.out.println(" 3. for");
System.out.println(" 4. while");
System.out.println(" 5. do-while\n");
System.out.print("Bыбepитe: ");
choice = (char) System.in.read();
do {
ignore = (char} System.in.read();
) while(ignore != '\n');
while( choice < '1' 1 choice > '5');
System.out.println("\n");
switch(choice) {
case '1':
Глава 3. Управляющие операторы 113
System.out.println("Oпepaтop if:\n"};
System.out.println("if(ycлoвиe) оператор;");
System.out.println("else оператор;");
break;
case '2':
System.out.println("Oпepaтop switch:\n");
System.out.println("switch(выpaжeниe) {");
System.out.println(" case константа:");
System.out.println(" последовательность операторов");
System.out.println(" break;");
System.out.println{" // ... ");
System.out.println("}"J;
break;
case • 3 •:
System.out.println("Oпepaтop for:\n");
System.out.print("for(инициaлизaция; условие; итерация)");
System.out.println(" оператор;");
break;
case • 4 •:
System.out.println("Oпepaтop while:\n"};
System.out.println("while(ycлoвиe) оператор;");
break;
case '5':
System.out.println("Oпepaтop do-while:\n");
System.out.println("do {");
System.out.println(" оператор;");
System.out.println("} while (условие};");
break;
Применение оператора break
для выхода из цикла
С помощью оператора break можно специально организовать немедленный выход
из цикла в обход любого кода, оставшегося в теле цикла, а также минуя проверку условия
цикла. Коrда в теле цикла встречается оператор break, цикл завершается, а выполнение
программы возобновляется с оператора, следующего после этоrо цикла. Рассмотрим
следующий краткий пример программы.
// Применение оператора break для выхода из цикла
class BreakDemo {
puЬlic static void main(String args[JI
int num;
num = 100;
1 14 Java 8: руководство для начинающих. 6-е издание
// Выполнять цикл до тех пор, пока квадрат значения
// переменной i меньше значения переменной num
for(int i=O; i < nurn; i++) {
if(i*i >= nurn) break; // прекратить цикл, если i*i >= 100
Systern.out.print(i + " ");
Systern.out.println("Цикл завершен.");
Выполнение этой программы дает следующий результат:
О 1 2 3 4 5 6 7 8 9 Цикл завершен.
Как видите, цикл for организован для выполнения в пределах значений переменной
num от О до 100. Но, несмотря на это, оператор break прерывает цикл раньше, когда
квадрат значения переменной i становится больше значения переменной num.
Оператор break можно применять в любых циклах, предусмотренных в Java, включая
и те, что намеренно организованы бесконечными. В качестве примера ниже приведен
простой пример программы, в которой вводимые данные читаются до тех пор, пока
пользователь не введет с клавиатуры букву q.
// Чтение вводимых данных до тех пор, пока не будет получена буква q
class Break2 {
puЫic static void rnain(String args[])
throws java.io.IOException {
char ch;
for( ) {
ch = (char) Systern.in.read();// получить символ с клавиатуры
if ( ch == 'q') break; иБесконечный" цнкn, эоверwоемый оператором break
Systern.out.println("Bы нажали клавишу q!");
Если оператор break применяется посреди набора вложенных циклов, то он прерывает
выполнение только самого внутреннего цикла. В качестве примера рассмотрим следующую
программу.
// Применение оператора break во вложенных циклах
class BreakЗ {
puЫic static void rnain(String args[]) {
for (int i=O; i<З; i++) {
Systern.out.println("Cчeтчик внешнего цикла: " + i);
Systern.out.print("
int t = О;
while(t < 100)
Счетчик внутреннего цикла: ");
if(t == 10) break; // прервать цикл, если t 10
Systern.out.print(t + " ");
t++;
System.out.println();
Глава 3. Управляющие операторы 115
System.out.println("Циклы завершены.");
Выполнение этой программы дает следующий результат.
Счетчик внешнего цикла: о
Счетчик внутреннего цикла: о 1 2 3 4 5 6 7 8 9
Счетчик внешнего цикла: 1
Счетчик внутреннего цикла: о 1 2 3 4 5 6 7 8 9
Счетчик внешнего цикла: 2
Счетчик внутреннего цикла: о 1 2 3 4 5 6 7 8 9
Циклы завершены.
Как видите, оператор break из внутреннего цикла вызывает прерывание только этого
цикла. А на выполнение внешнего цикла он не оказывает никакого влияния.
В отношении оператора break необходимо также иметь в виду следующее. Во-первых,
в теле цикле может присутствовать несколько операторов break, но применять их
следует очень аккуратно, поскольку их чрезмерное количество обычно приводит к нарушению
нормальной структуры кода. И во-вторых, оператор break, выполняющий выход
из оператора swi tch, оказывает воздействие только на этот оператор, но не на охватывающие
его циклы.
Оператор break в роли оператора goto
Помимо оператора switch и циклов, оператор break может быть использован как
"цивилизованный" вариант оператора goto. В языке Java оператор goto отсутствует, поскольку
он дает возможность произвольного перехода в любую точку программы, что
способствует созданию плохо структурированного кода. Программы, в которых часто
используется оператор goto, обычно сложны для восприятия и сопровождения. Но в некоторых
случаях оператор goto может оказаться полезным. Его удобно, например, использовать
для экстренного выхода из многократно вложенных циклов.
Для решения подобных задач в Java определена расширенная форма оператора
break. Используя этот вариант оператора break, можно, например, выйти за пределы
одного или нескольких блоков кода. Эти блоки должны быть частью циклов или оператора
swi tch. Кроме того, нужно явно указать точку, с которой должно быть продолжено
выполнение программы. Для этой цели в расширенной форме оператора break предусмотрена
метка. Как будет показано далее, оператор break позволяет воспользоваться
всеми преимуществами оператора goto и в то же время избежать сложностей, связанных
с его применением.
Ниже приведен общий синтаксис оператора break с меткой:
break метка;
Как правило, метка - это имя, обозначающее блок кода. При выполнении расширенного
оператора break управление передается за пределы именованного блока. Оператор
break с меткой может содержаться непосредственно в именованном блоке или в одном из
блоков, входящих в состав именованного блока. Следовательно, рассматриваемый здесь вариант
оператора break можно использовать для выхода из ряда вложенных блоков. Но это
языковое средство не позволяет передать управление в блок, не содержащий оператор break.
116 Java 8: руководство для начинающих. 6-е издание
Для тоrо чтобы присвоить имя блоку, нужно поставить перед ним метку. Именовать
можно как независимый блок, так и оператор, адресатом которого является кодовый
блок. Роль метки может выполнять любой допустимый в Java идентификатор с двоеточием.
Пометив блок кода, метку можно использовать в качестве адресата оператора
break. Благодаря этому выполнение программы возобновляется с конца именованного
блока. Например, в приведенном ниже фрагменте кода используются три вложенных
блока.
// Применение оператора break с меткой
class Break4 {
puЫic static void main(String args[])
int i;
for(i=l; i<4; i++) {
one: {
two: {
three:
System.out.println("\ni равно " + i);
i f ( i == 1) brea k one; Переход no метке
if(i==2) break two;
if(i==З) break three;
// Эта строка кода никогда не будет достигнута
System.out.println("нe будет выведено");
System.out.println("Пocлe блока three"};
System.out.println("Пocлe блока two"};
System.out.println("Пocлe блока one");
System.out.println("Пocлe цикла for");
Выполнение этого фрагмента кода дает следующий результат.
i равно 1
После блока one
i равно 2
После блока two
После блока one
i равно 3
После блока three
После блока two
После блока one
После цикла for
Рассмотрим подробнее приведенный выше фрагмент кода, чтобы лучше понять, каким
образом получается именно такой результат его выполнения. Когда значение переменной
i равно 1, условие первого оператора if становится истинным и управление
Глава 3. Управляющие операторы 117
передается в конец блока с меткой one. В результате выводится сообщение "После блока
one". Если значение переменной i равно 2, то успешно завершается проверка условия
во втором операторе i f и выполнение программы продолжается с конца блока с
меткой two. В результате выводятся по порядку сообщения "После блока two" и "После
блока one". Когда же переменная i принимает значение 3, истинным становится условие
в третьем операторе if и управление передается в конец блока с меткой three.
В этом случае выводятся все три сообщения: два упомянутых выше, а также сообщение
"После блока three", а затем еще и сообщение "После цикла for".
Обратимся к еще одному примеру. На этот раз оператор break будет использован
для выхода за пределы нескольких вложенных циклов. Когда во внутреннем цикле выполняется
оператор break, управление передается в конец блока внешнего цикла. Этот
блок помечен меткой done. В результате происходит выход из всех трех циклов.
// Еще один пример применения оператора break с меткой
class Break5 {
о
1
2
3
4
5
puЬlic static void main (String args []) {
done:
for (int i=O; i<lO; i++) {
for (int j=O; j<lO; j++)
for(int k=O; k<lO; k++)
System.out.println(k + " ");
if(k == 5) break done; // переход по метке done
System.out.println("Пocлe цикла по k"); // не выполнится
System.out.println("Пocлe цикла по j"); // не выполнится
System.out.println("Пocлe цикла по i");
Ниже приведен результат выполнения данного фрагмента кода.
После цикла i
Расположение метки имеет большое значение, особенно когда речь идет о циклах.
Рассмотрим в качестве примера следующий фрагмент кода.
// Расположение метки имеет большое значение
class Breakб {
puЬlic static void main(String args[]) {
int х= О, у= О;
// Здесь метка располагается перед оператором for
stopl: for(x=O; х < 5; х++) {
for(y = О; у < 5; у++) {
if(y == 2) break stopl;
118 Java 8: руководство для начинающих, 6-е издание
System.out.println("x и у: " + х + " " +у};
System.out.println();
// А здесь метка располагается непосредственно перед
// открывающей фигурной скобкой
for(x=O; х < 5; х++)
stop2: {
for(у О; у < 5; у++) {
if(y == 2) break stop2;
System.out.println("x и у: " + х + " " + у);
Ниже приведен результат выполнения данной программы.
х и у: о о
х и у: о 1
х и у: о о
х и у: о 1
х и у: 1 о
х и у: 1 1
х и у: 2 о
х и у: 2 1
х и у: 3 о
х и у: 3 1
х и у: 4 о
х и у: 4 1
В данной программе наборы вложенных циклов идентичны, за исключением того,
что в первом наборе метка находится перед внешним циклом for. В таком случае при
выполнении оператора break управление передается в конец всего блока цикла for, а
оставшиеся итерации внешнего цикла пропускаются. Во втором наборе метка находится
перед открывающей фигурной скобкой кодового блока, определяющего тело внешнего
цикла. Поэтому при выполнении оператора break stop2 управление передается в конец
тела внешнего цикла for, и далее выполняется очередной ero шаг.
Не следует, однако, забывать, что в операторе break нельзя использовать метку, не
определенную в охватывающем ero цикле. Например, приведенный ниже фрагмент кода
некорректен и не пройдет компиляцию.
// Этот фрагмент кода содержит ошибку
class BreakErr {
puЬlic static void main(String args[]}
one: for (int i=O; i<З; i++) {
System.out.print("Пpoxoд " + i + "· ");
for (int j=O; j<lOO; j++) {
Глава 3. Управляющие операторы 119
if(j == 10) break one; // НЕВЕРНО!
System.out.print(j + " ");
Блок кода, обозначенный меткой one, не содержит оператор break, и поэтому управление
не может быть передано этому блоку.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как пояснялось выше, оператор goto нарушает структуру программы,
и поэтому более подходящим вариантом является оператор break с меткой.
Но не нарушает ли структуру программы переход в конец внешнего цикла,
т.е. в точку, далеко отстоящую от оператора break?
ОТВЕТ. Действительно, нарушает. Но если явный переход все-таки необходим, то
передача управления в конец кодового блока сохраняет хоть какое-то подобие
структуры, чего нельзя сказать об операторе goto.
Применение оператора continue
С помощью оператора continue можно организовать досрочное завершение шага
итерации цикла в обход обычной структуры управления циклом. Оператор continue
осуществляет принудительный переход к следующему шагу цикла, пропуская оставшийся
невыполненным код. Таким образом, оператор continue служит своего рода дополнением
оператора break. В приведенном ниже примере программы оператор continue
используется в качестве вспомогательного средства для вывода четных чисел в пределах
ОТ O ДО 100.
// Применение оператора continue
class ContDemo {
puЬlic static void main(String args[]) {
int i;
// Вывести четные числа в пределах от О до 100
for(i = О; i<=lOO; i++) {
if((i%2) != О) continue; // завершить шаг итерации цикла
System.out.println(i);
В данном примере выводятся только четные числа, поскольку при обнаружении
нечетного числа шаг итерации цикла завершается досрочно в обход вызова метода
println ().
120 Java 8: руководство для начинающих. 6-е издание
В циклах while и do-while оператор continue вызывает передачу управления непосредственно
условному выражению, после чего продолжается процесс выполнения
цикла. А в цикле for сначала вычисляется итерационное выражение, затем условное
выражение, после чего цикл продолжается.
Как и в операторе break, в операторе continue может присутствовать метка, обозначающая
тот охватывающий цикл, выполнение которого должно быть продолжено. Ниже
приведен пример программы, демонстрирующий применение оператора continue с
меткой.
// Применить оператор continue с меткой
class ContToLabel {
puЫic static void main(String args(J)
outerloop:
for (int i=l; i < 10; i++) {
System.out.print("\nBнemний цикл: проход " + i +
", внутренний цикл: ");
for (int j = 1; j < 10; j++) {
)
if(j == 5) continue outerloop; // продолжить внешний цикл
System.out.print(j);
Выполнение этой программы дает следующий результат.
Внешний цикл: проход 1, Внутренний цикл: 1234
Внешний цикл: проход 2, Внутренний цикл: 1234
Внешний цикл: проход 3, Внутренний цикл: 1234
Внешний цикл: проход 4, Внутренний цикл: 1234
Внешний цикл: проход 5, Внутренний цикл: 1234
Внешний цикл: проход 6, Внутренний цикл: 1234
Внешний цикл: проход 7, Внутренний цикл: 1234
Внешний цикл: проход 8, Внутренний цикл: 1234
Внешний цикл: проход 9, Внутренний цикл: 1234
Как следует из приведенного выше примера, при выполнении оператора continue
управление передается внешнему циклу, и оставшиеся итерации внутреннего цикла пропускаются.
В реальных программах оператор continue применяется очень редко. И объясняется
это, в частности, богатым набором в Java операторов цикла, удовлетворяющих большую
часть потребностей в написании прикладных программ. Но в особых случаях, когда требуется
преждевременное прекращение цикла, оператор continue позволяет сделать это,
не нарушая структуру кода.
Упражнение 3.3 Завершение построения
справочной системы Java
В этом проекте предстоит завершить построение справочной системы
Java, начатое в предыдущих проектах. Данная версия будет дополне-
на сведениями о синтаксисе операторов break и continue, а также даст пользователю
возможность запрашивать сведения о синтаксисе нескольких операторов. Эта цель
Глава 3. Управляющие операторы 121
достигается путем добавления внешнего цикла, который выполняется до тех пор, пока
пользователь не введет с клавиатуры букву q вместо номера пункта меню. Поэтапное
описание процесса создания программы приведено ниже.
1. Скопируйте файл Help2. j ava в новый файл НеlрЗ. j ava.
2. Поместите весь исходный код программы в бесконечный цикл for. Выход из этого
цикла будет осуmествлятъся с помощью оператора break, который получит управление
тогда, когда пользователь введет с клавиатуры букву q. А поскольку этот
цикл включает в себя весь код, то выход из него означает завершение программы.
3. Измените цикл отображения меню.
do {
Systern.out.println("Cпpaвкa:");
Systern.out.println(" 1. if");
Systern.out.println(" 2. switch");
Systern.out.println(" 3. for");
Systern.out.println(" 4. while");
Systern.out.println(" 5. do-while");
Systern.out.println(" 6. break");
Systern.out.println(" 7. continue\n");
Systern.out.print("Bыбepитe (q - выход): ");
choice = (char) Systern.in.read();
do {
ignore = (char) Systern.in.read();
} while(ignore != '\n');
while( choice < '1' 1 choice > '7' & choice != 'q');
Как видите, теперь цикл включает в себя операторы break и continue. Кроме
того, буква q воспринимается в нем как допустимый вариант выбора.
4. Дополните оператор switch вариантами выбора для операторов break и
continue.
case '6':
Systern.out.println("Oпepaтop break:\n");
Systern.out.println("break; или break метка;");
break;
case '7':
Systern.out.println("Oпepaтop continue:\n");
Systern.out.println("continue; или continue метка;");
break;
5. Ниже приведен весь исходный код программы из файла НеlрЗ. j ava.
/*
Упражнение 3.3
Завершенная справочная система по управляющим
операторам Java, обрабатывающая многократные запросы
*/
class Help3 {
puЬlic static void rnain(String args[])
throws java.io.IOException
char choice, ignore;
122 Java 8: руководство для начинающих. 6-е издание
for (;;) {
do {
Systern.out.println("Cпpaвкa:");
Systern.out.println(" 1. if");
Systern.out.println(" 2. switch");
Systern.out.println(" 3. for");
Systern.out.println(" 4. while");
Systern.out.println(" 5. do-while");
Systern.out.println(" 6. break");
Systern.out.println(" 7. continue\n");
Systern.out.print("Bыбepитe (q to quit): ");
choice = (char) Systern.in.read();
do {
ignore = (char) Systern.in.read();
} while(ignore != '\n');
while( choice < '1' 1 choice > '7' & choice != 'q');
if(choice == 'q') break;
Systern.out.println("\n");
swi tch ( choice) {
case '1':
Systern.out.println("Oпepaтop if:\n");
Systern.out.println("if(ycлoвиe) оператор;");
Systern.out.println("else оператор;");
break;
case '2':
Systern.out.println("Oпepaтop switch:\n");
Systern. out. println ( "swi tch (выражение) {") ;
Systern.out.println(" case константа:");
Systern.out.println(" последовательность операторов");
Systern.out.println(" break;");
Systern.out.println(" // ... ");
Systern.out.println("J");
break;
case 'З':
Systern.out.println("Oпepaтop for:\n");
Systern.out.print("for(init; условие; итерация}");
Systern.out.println(" оператор;");
break;
case '4':
Systern.out.println("Oпepaтop while:\n");
Systern.out.println("while(ycлoвиe) оператор;");
break;
case '5':
System.out.println("Oпepaтop do-while:\n");
System.out.println("do {");
Systern.out.println(" оператор;");
System.out.println("} while (условие);");
break;
case 1 6 1
:
Глава 3. Управляющие операторы 123
System.out.println("Oпepaтop break:\n");
System.out.println("break; или break метка;");
break;
case 1 7 1 :
System.out.println("Oпepaтop continue:\n");
System.out.println("continue; или continue метка;");
break;
System.out.println();
6. Ниже приведен один из возможных вариантов выполнения данной проrраммы в
диалоговом режиме.
Справка:
l. if
2. switch
3. for
4. while
5. do-while
6. break
7. Continue
Выберите (q - выход: l
Оператор if:
if(условие) оператор;
else оператор;
Справка:
l. if
2. switch
3. for
4. while
5. do-while
6. break
7. Continue
Выберите (q - выход): 6
Оператор break:
break; или break метка;
Справка:
l. if
2. switch
3. for
4. while
5. do-while
6. break
7. Continue
Выберите (q - выход): q
124 Java 8: руководство для начинающих. 6-е издание
Вложенные циклы
Как следует из предыдущих примеров программ, один цикл может быть вложен в
другой. С помощью вложенных циклов решаются самые разные задачи. Поэтому, прежде
чем завершить рассмотрение циклов в Java, уделим еще немного внимания вложенным
циклам. Ниже приведен пример программы, содержащей вложенные циклы for.
С помощью этих циклов для каждого числа от 2 до 100 определяется ряд множителей,
на которые данное число делится без остатка.
/*
Использовать вложенные циклы для нахождени я
делителей чисел о т 2 до 100
*/
class FindFac {
puЫic static void main(String args(])
for (int i=2; i <= 100; i++) {
System.out.print("Дeлитeли " + i + ": ");
for(int j = 2; j < i; j++)
if((i%j) == О) System.out.print(j + " ");
System.out.println{);
Ниже приведена часть результата выполнения данной программы.
Делители 2:
Делители 3:
Делители 4: 2
Делители 5:
Делители 6: 2 3
Делители 7:
Делители 8: 2 4
Делители 9: 3
Делители 10: 2 5
Делители 11:
Делители 12: 2 3 4 6
Делители 13:
Делители 14: 2 7
Делители 15: 3 5
Делители 16: 2 4 8
Делители 17:
Делители 18: 2 3 6 9
Делители 19:
Делители 20: 2 4 5 10
В данной программе переменная i из внешнего цикла последовательно принимает
значения до 2 до 100. А во внутреннем цикле для каждого числа от 2 до текущего значения
переменной i выполняется проверка, является ли оно делителем i. В качестве
упражнения попробуйте сделать данную программу более эффективной. (Подсказка:
число итераций во внутреннем цикле можно уменьшить.)
Глава 3. Управляющие операторы 125
fl
Вопросы н упражнення дпя самопроверкн
1. Напишите программу, которая получает символы, введенные с клавиатуры, до
тех пор, пока не встретится точка. Предусмотрите в программе счетчик пробелов.
Сведения о количестве пробелов должны выводиться в конце программы.
2. Каков общий синтаксис многоступенчатой конструкции if-else-if?
3. Допустим, имеется следующий фрагмент кода.
if(x < 10)
if(y > 100)
if ( ! done) х z;
else у = z;
else System.out.println("error");// к какому оператору if относится?
С каким из операторов if связан последний оператор else?
4. Напишите цикл for, в котором перебирались бы значения от 1000 до О с шагом
-2.
5. Корректен ли следующий фрагмент кода?
for(int i = О; i < num; i++)
sum += i;
count = i;
6. Какие действия выполняет оператор break? Опишите оба варианта этого оператора.
7. Какое сообщение будет выведено после выполнения оператора break в приведенном
ниже фрагменте кода?
for(i = О; i < 10; i++) {
while(running) {
if (х<у) break;
/ / . . .
System.out.println("Пocлe while");
System.out.println("Пocлe for");
8. Что будет выведено на экран в результате выполнения следующего фрагмента
кода?
for (int i = О; i<lO; i++) {
System.out.print(i + " ");
if((i%2) == О) continue;
System.out.println();
9. Итерационное выражение для цикла for не обязательно должно изменять значение
переменной цикла на фиксированную величину. Эта переменная может принимать
произвольные значения. Напишите программу, использующую цикл for
для вывода чисел в геометрической прогрессии: 1, 2, 4, 8, 16, 32 и т.д.
126 Java 8: руководство для начинающих. 6-е издание
10. Код ASCII символов нижнего регистра отличается от кода соответствующих символов
верхнего регистра на величину 32. Следовательно, для преобразования
строчной буквы в прописную нужно уменьшить ее код на 32. Используйте это обстоятельство
для написания программы, осуществляющей получение символов с
клавиатуры. При выводе результатов данная программа должна преобразовывать
строчные буквы в прописные, а прописные - в строчные. Остальные символы не
должны изменяться. Работа программы должна завершаться после того, как пользователь
введет с клавиатуры точку. И наконец, сделайте так, чтобы программа
отображала число символов, для которых бьш изменен регистр.
11. Что такое бесконечный цикл?
12. Должна ли метка, используемая вместе с оператором break, быть определена в
блоке кода, содержащем этот оператор?
Глава 4
Введение в классы,
объекты и методы
128 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
􀂑 Основные сведения о классах
􀂒 Создание объектов
* Присваивание ссылок на объекты
О Создание методов, возврат значений и использование параметров
􀂓 Применение ключевого слова return
tJit Возврат значения из метода
& Добавление параметров в метод
􀂔 Применение конструкторов
􀂕· Создание параметризированных конструкторов
* Ключевое слово new
􀂖 Сборка мусора и методы завершения
􀂗 Применение ключевого слова this
п режде чем продолжить изучение Java, следует ознакомиться с классами. Классы
составляют саму сущность Java, фундамент, на котором зиждется весь язык, поскольку
класс определяет природу объекта. Следовательно, классы служат прочным основанием
для объектно-ориентированного программирования на Java. В классе определяются
данные и код, который выполняет действия над этими данными. Код находится
внутри методов. Эта глава посвящена классам, объектам и методам, ибо они играют в
Java ведущую роль. Имея представление о классах, объектах и методах, вы сможете писать
более сложные программы и сумеете уяснить те элементы языка Java, которые будут
описаны в последующих главах.
Основные сведения о классах
Код любой программы, написанной на Java, находится в пределах класса. Именно
поэтому мы начали использовать классы уже с первых примеров программ в книге.
Разумеется, мы ограничивались лишь самыми простыми классами и не пользовались
большинством их возможностей. Как станет ясно в дальнейшем, классы - намного
более эффективное языковое средство, чем можно было бы предположить, имея о них
лишь самое ограниченное представление, почерпнутое из предыдущих глав.
Начнем рассмотрение классов с основных положений. Класс представляет собой шаблон,
по которому определяется вид объекта. В нем указываются данные и код, который
будет оперировать этими данными. Java использует спецификацию класса для конструирования
объектов. Объекты - это экземпляры классов. Таким образом, класс фактически
представляет собой описание, в соответствии с которым должны создаваться объекты.
Очень важно, чтобы вы понимали: класс - это логическая абстракция. Физическое
представление класса в оперативной памяти появится лишь после того, как будет создан
объект этого класса.
Глава 4. Введение в классы, объекты и методы 129
Следует также иметь в виду, что методы и переменные, составляющие класс, принято
называть членами класса. Для данных - членов класса существует также другое название:
переменные экземпляра.
Общая форма определения класса
Определяя класс, вы объявляете его конкретный вид и поведение. Для этого указываются
содержащиеся в нем переменные экземпляра и оперирующие ими методы. Если
самые простые классы могут содержать только код или только данные, то большинство
реальных классов содержат и то и другое.
Класс создается с помощью ключевого слова class. Ниже приведена упрощенная
общая форма определения класса.
class имя_класса {
// объявление переменных экземпляра
тип переменнаяl;
тип переменная2;
// . . .
тип переменнаяN;
// объявление методов
тип методl (параметры)
// тело метода
тип метод2(параметры)
// тело метода
// . . .
тип методN(параметры)
// тело метода
Несмотря на отсутствие соответствующего правила в синтаксисе Java, правильно
сконструированный класс должен определять одну и только одну логическую сущность.
Например, класс, в котором хранятся имена абонентов и номера их телефонов, обычно
не будет содержать сведения о фондовом рынке, среднем уровне осадков, периодичности
солнечных пятен или другую не относящуюся к делу информацию. Таким образом,
в хорошо спроектированном классе должна быть сгруппирована логически связанная
информация. Если же в один и тот же класс помещается логически несвязанная информация,
то структурированность кода быстро нарущается.
Классы, использовавшиеся в приведенных ранее примерах программ, содержали
только один метод: main (). Но в представленной выше общей форме описания класса
метод main () не указывается. Этот метод надо указывать в классе лишь в том случае,
если выполнение программы начинается с данного класса. Кроме того, в некоторых
приложениях Java, в том числе в аплетах, метод main () вообще не требуется.
Определение класса
Для того чтобы проиллюстрировать особенности создания классов, создадим
класс, инкапсулирующий сведения о транспортных средствах, например, о легковых
130 Java 8: руководство для начинающих. 6-е издание
автомобилях, фургонах и грузовиках. Назовем этот класс Vehicle. В нем будут храниться
следующие сведения: количество пассажиров, емкость тоrтивноrо бака и среднее потребление
топлива (в милях на галлон).
Ниже приведен первый вариант класса Vehicle. В нем определены три переменные
экземrmяра: passengers, fuelcap и mpg. Обратите внимание на то, что в классе Vehicle
пока еще отсутствуют методы. Они будут добавлены в последующих разделах, а до тех
пор в этом классе содержатся только данные.
class Vehicle {
int passengers; // количество пассажиров
int fuelcap; // емкость топливного бака
int mpg; // потребление топлива в милях на галлон
Объявление класса создает новый тип данных. В данном случае этот тип называется
Vehicle. Мы будем использовать это имя для объявления объектов типа Vehicle.
Вспомните, что объявление класса - это всего лишь описание типа данных, и реальный
объект при этом не создается. Следовательно, приведенный выше код не приводит к
появлению объектов типа Vehicle.
Для фактического создания реального объекта Vehicle потребуется примерно следующий
код.
Vehicle minivan = new Vehicle(); // создать объект minivan
// типа Vehicle
В результате создается объект minivan, представляющий собой экземпляр класса
Vehicle. Иными словами, абстрактная оболочка класса обретает физическую форму.
О деталях мы поговорим позже.
Всякий раз, когда вы создаете экземпляр класса, вы создаете объект, содержащий
собственные копии всех переменных экземrmяра, определенных в классе. Иными словами,
каждый объект типа Vehicle будет содержать свои копии переменных passengers,
fuelcap и mpg. Для обращения к этим переменным используется так называемая точечная
нотация, в соответствии с которой имя переменной указывается после имени объекта
и отделяется от него точкой:
объект. член
В этой форме объект указывается слева, а член - справа от точки. Так, если переменной
fuelcap объекта minivan требуется присвоить значение 16, это можно сделать
следующим образом:
minivan.fuelcap = 16;
Вообще говоря, точечной нотацией можно пользоваться для обращения как к переменным
экземrmяра, так и к методам.
Ниже приведен пример программы, в которой используется класс Vehicle.
/* Программа, в которой используется класс Vehicle
Присвойте файлу с исходным кодом имя VehicleDemo.java
*/
class Vehicle {
int passengers; // количество пассажиров
int fuelcap; // емкость топливного бака
int mpg;
Глава 4. Введение в классы. объекты и методы 1 З 1
// потребление топлива в милях на галлон
// В этом классе объявляется объект типа Vehicle
class VehicleDerno {
puЫic static void main(String args[])
Vehicle minivan = new Vehicle(};
int range;
// Присвоить значения полям в объекте minivan
minivan.passengers = 7;
minivan.fuelcap = 16;
minivan.mpg = 21;
,. ___ Обратите аннманне но нспопьзоаонне точечной
нотацнн дnSI доступа к nеременнwм экземnn•ра
// Рассчитать дальность поездки при полном баке
range = minivan.fuelcap * minivan.mpg;
System.out.println(11 Mини-фypгoн может перевезти 11 +
minivan.passengers + 11 пассажиров на расстояние 1 1 + range +
II миль");
Файлу, содержащему приведенный выше код, следует присвоить имя VehicleDemo.
java, поскольку метод main () находится не в классе Vehicle, а в классе VehicleDemo.
В результате компиляции программы будут созданы два файла с расширением . class:
один - для класса Vehicle, а другой - для класса VehicleDemo. Компилятор Java автоматически
помещает каждый класс в отдельный файл с расширением . class. Совсем не
обязательно, чтобы классы Vehicle и VehicleDemo находились в одном и том же исходном
файле. Их можно расположить в двух файлах: Vehicle. j ava и VehicleDemo. j ava.
Для того чтобы привести эту программу в действие, следует запустить на выполнение
файл VehicleDemo. class. В итоге на экран будет выведен следующий результат:
Мини-фургон может перевезти 7 пассажиров на расстояние 336 миль
Прежде чем двигаться дальше, рассмотрим следующий основополагающий принцип:
каждый объект содержит собственные копии переменных экземпляра, определенных в
его классе. Следовательно, содержимое переменных в одном объекте может отличаться
от содержимого тех же самых переменных в другом объекте. Между объектами нет никакой
связи, за исключением того, что они относятся к одному и тому же типу. Так, если
имеются два объекта типа Vehicle, каждый из них содержит собственную копию переменных
passengers, fuelcap и mpg, причем значения одноименных переменных в этих
двух объектах могут отличаться. Продемонстрируем это на примере приведенной ниже
программы (обратите внимание на то, что класс, содержащий метод main (), на этот раз
назван TwoVehicles).
// В этой программе создаются два объекта класса Vehicle
class Vehicle {
int passengers; // количество пассажиров
int fuelcap; // емкость топливного бака
int mpg; // потребление топлива в милях на галлон}
// В этом классе объявляется объект типа Vehicle
class TwoVehicles {
132 Java 8: руководство для начинающих, 6-е издание
puЫic static void main(S tring args [)] {
Vehicle minivan = new Vehic􀂵e (); ]-Помните, что переменнwе minivan
Vehicle sportscar = new Vehicle () ; н sportscar ccwnaioтcя на разнwе 061,ектw
int rangel, range2;
// Присвоит ь значенипя олям в объекте minivan
minivan.passengers = 7;
minivan.fuelcap = 16;
minivan.mpg = 21;
// Присвоить значенипя олям в объекте sportscar
sportscar.passengers = 2;
sportscar.fuelcap = 14;
sportscar.mpg = 12;
// Рассчитат ь даль ность поездкип рпи олном баке
rangel minivan.fuelcap * minivan.mpg;
range2 = sportscar.fuelcap * sportscar.mpg;
System.out.println("Мини-фypгoн можетп еревезти"+
minivan.passenger+s "пассажиров на расстояние"+ rangel +
" миль");
System.out.println("Cпopтивный автомобил ь можетп еревезти"+
sportcar.passenger+s " пассажиров на расстояние"+ range2 +
" миль") i
Ниже приведен результат выполнения данной программы.
Мини-фургон можепт еревезти п7 ассажиров на расстояние 336 миль
пС ортивный автомобиль можетп еревезти п2 ассажиров на расстояние
168 миль
Как видите, данные из объекта mini van отличаются от соответствующих данных из
объекта sportscar. Это обстоятельство иллюстрирует приведенный ниже рисунок.
minivan
passengers 7
.
fuelcap 16
mpg 21
sportscar -
passengers 2
.
fuelcap 14
mpg 12
Порядок создания объектов
В рассмотренных ранее примерах программ для объявления объекта типа Vehicle
использовалась следующая строка кода:
Vehicle minivan = new Vehicle();
Глава 4. Введение в классы. объекты и методы 133
Это объявление выполняет две функции. Во-первых, в нем объявляется переменная
класса Vehicle под именем mini van. Эта переменная еще не определяет объект, она
просто дает возможность ссылаться на объект. И во-вторых, в этой строке кода создается
физическая копия объекта, а ссьтка на него присваивается переменной mini van.
И делается это с помощью оператора new.
Оператор new динамически (т.е. во время выполнения программы) выделяет память
для объекта и возвращает ссылку на него. Эта ссьтка, по суrи, представляет собой адрес
области памяти, выделяемой для объекта оператором new. Ссылка на объект сохраняется
в переменной. Таким образом, память для объектов всех классов в Java вьщеляется
динамически.
Приведенный выше код можно разбить на две строки, соответствующие отдельным
этапам создания объекта.
Vehicle rninivan; // объявить ссылку на объект
rninivan = new Vehicle(); // выделить память для объекта типа Vehicle
В первой строке кода переменная minivan объявляется как ссьтка на объект типа
Vehicle. Следует иметь в виду, что minivan - это переменная, которая может ссьтаться
на объект, а не сам объект. В данный момент переменная mini van пока еще не ссьтается
на объект. Во второй строке кода создается новый объект типа Vehicle , а ссьтка на
него присваивается переменной minivan. С этого момента переменная minivan оказывается
ассоциированной с объектом.
Переменные ссылочного типа и присваивание
В операции присваивания переменные ссьточного типа ведут себя иначе, чем переменные
примитивных типов, например int. Когда одна переменная простого типа присваивается
другой, ситуация оказывается довольно простой. Переменная, находящаяся
в левой части оператора присваивания, получает копию значения переменной, находящейся
в правой части этого оператора. Когда же одна ссьточная переменная присваивается
другой, ситуация несколько усложняется, поскольку такое присваивание приводит
к тому, что переменная, находящаяся в левой части оператора присваивания, ссьтается
на тот же самый объект, что и переменная, находящаяся в правой части этого оператора.
Сам же объект не копируется. В силу этого отличия присваивание переменных ссьточноrо
типа может привести к несколько неожиданным результатам. В качестве примера
рассмотрим следующий фрагмент кода.
Vehicle carl new Vehicle();
Vehicle car2 = carl;
На первый взгляд, переменные carl и car2 ссылаются на совершенно разные
объекты, но на самом деле это не так. Переменные carl и car2, напротив, ссьтаются на
один и тот же объект. Когда переменная carl присваивается переменой car2 , в конечном
итоге переменная car2 просто ссьтается на тот же самый объект, что и переменная
carl. Следовательно, этим объектом можно оперировать с помощью переменной carl
или car2. Например, после очередного присваивания
carl.rnpg = 26;
оба метода println ()
134 Java 8: руководство для начинающих. 6-е издание
System.out.println(carl.mpg);
System.out.println(car2.mpg);
выводят одно и то же значение: 26.
Несмотря на то что обе переменные, carl и car2, ссылаются на один и тот же объект,
они никак иначе не связаны друг с другом. Например, в результате приведенной
ниже последовательности операций присваивания просто изменяется объект, на который
ссьmается переменная car2.
Vehicle carl new Vehicle();
Vehicle car2 = carl;
Vehicle саrЗ = new Vehicle();
car2 = саrЗ; // теперь переменные car2 и саrЗ
// ссылаются на один и тот же объект
После выполнения этой последовательности операций присваивания переменная
car2 ссьmается на тот же самый объект, что и переменная саrЗ. А ссьmка на объект в
переменной carl не меняется.
Методы
Как пояснялось выше, переменные экземпляра и методы являются двумя основными
составляющими классов. До сих пор класс Vehicle, рассматриваемый здесь в качестве
примера, содержал только данные, но не методы. Хотя классы, содержащие только
данные, вполне допустимы, у большинства классов должны быть также методы. Методы
представляют собой подпрограммы, которые манипулируют данными, определенными
в классе, а во многих случаях они предоставляют доступ к этим данным. Как правило,
другие части программы взаимодействуют с классом посредством его методов.
Метод состоит из одной или нескольких инструкций. В правильно написанной программе
на Java каждый метод выполняет только одну функцию. У каждого метода имеется
свое имя, которое используется для его вызова. В целом в качестве имени метода
можно использовать любой действительный идентификатор. Следует, однако, иметь в
виду, что идентификатор main () зарезервирован для метода, с которого начинается выполнение
программы. Кроме того, в качестве имен методов нельзя использовать ключевые
слова Java.
При упоминании методов в тексте данной книги используется соглашение, ставшее
общепринятым в литературе по Java: после имени метода стоит пара круглых скобок.
Так, если методу присвоено имя getval, то в тексте книги он упоминается как
getval () . Такая форма записи позволяет отличать имена методов от имен переменных
при чтении книги.
Ниже приведен общий синтаксис объявления метода.
возращаемый_тип имя(список_параметров)
// тело метода
Здесь возращаемый _ тип обозначает тип данных, возвращаемых методом. Им может
быть любой допустимый тип, в том числе и тип класса, который вы создаете. Если метод
не возвращает значение, то для него указывается тип void. Далее, имя обозначает конкретное
имя, присваиваемое методу. В качестве имени метода может быть использован
любой допустимый идентификатор, не приводящий к конфликтам в текущей области
действия. И наконец, список_ параметров - это последовательность разделенных
Глава 4. Введение в классы. объекты и методы 135
запятыми параметров, для каждого из которых указывается тип и имя. Параметры представляют
собой переменные, которые получают значения, передаваемые им в виде аргументов
при вызове метода. Если у метода отсутствуют параметры, список параметров
оказывается пустым.
Добавление метода в класс Vehicle
Как пояснялось ранее, обычно методы класса выполняют действия над данными,
входящими в состав класса, и предоставляют доступ к этим данным. Напомним, что метод
main () в предыдущих примерах вычислял дальность поездки транспортного средства,
умножая емкость топливного бака на число миль, которые оно может проехать,
потребив единичный объем топлива (в данном случае - галлон). И хотя такой расчет
формально считается правильным, его лучше всего производить в пределах самого
класса Vehicle. Аргументы в пользу такого решения очевидны: дальность поездки
транспортного средства зависит от потребления топлива в милях на галлон и емкости
топливного бака, а обе эти величины инкапсулированы в классе Vehicle. Благодаря добавлению
в класс Vehicle метода, предназначенного для расчета искомой величины,
улучшается объектно-ориентированная структура кода.
Для того чтобы добавить метод в класс Vehicle, его следует объявить в пределах
этого класса. Например, приведенный ниже вариант класса Vehicle содержит метод
range () , определяющий и отображающий дальность поездки транспортного средства.
// Добавление метода range() в класс Vehicle
class Vehicle
// количество пассажиров
// емкость топливного бака
int passengers;
int fuelcap;
int mpg; // потребление топлива в милях на галлон
// Отобразить дальность поездки
void range() {
System.out.println("Дaльнocть
транспортного средства
---------------- Метод ronge() со держится в классе Vehicle
- " + fuelcap * mpg + "миль.");
+ •
1
class AddMeth {
Обратите внимание но непосредственное указание переменных fuelcap
н mpg без нсnоn•зовоння точечной нотации
puЬlic static void main(String args[])
Vehicle minivan = new Vehicle();
Vehicle sportscar = new Vehicle();
int rangel, range2;
// Присвоить значения полям в объекте minivan
minivan.passengers = 7;
minivan.fuelcap = 16;
minivan.mpg = 21;
// Присвоить значения полям в объекте sportscar
sportscar.passengers = 2;
sportscar.fuelcap = 14;
sportscar.mpg = 12;
136 Java 8: руководство для начинающих. 6-е издание
System.out.print("Мини-фypгoн может перевезти " +
minivan.passengers + " пассажиров. ");
minivan.range(); // отобразить дальность поездки мини-фургона
System.out.print("Cпopтивный автомобиль может перевезти " +
sportscar. passengers + " пассажиров. ") ;
sportscar.range(); // отобразить дальность поездки
// спортивного автомобиля
Ниже приведен результат выполнения данной программы.
Мини-фургон может перевезти 7 пассажиров. Дальность - 336 миль.
Спортивный автомобиль может перевезти 2 пассажиров. Дальность -
168 миль.
Рассмотрим основные элементы данной программы. Начнем с метода range () . Первая
строка кода этого метода выглядит так:
void range () {
В этой строке объявляется метод с именем range, для которого не предусмотрены
параметры. В качестве типа, возвращаемого этим методом, указано ключевое слово
void. Таким образом, метод range () не возвращает вызывающей части программы никаких
данных. И завершается строка открывающей фигурной скобкой, обозначающей
начало тела метода.
Тело метода range () состоит из единственной строки кода.
System.out.println("Дaльнocть поездки - " + fuelcap * mpg +
.. миль.");
В этой строке на экран выводится дальность поездки транспортного средства как результат
перемножения переменных fuelcap и mpg. А поскольку у каждого объекта типа
Vehicle имеются свои копии переменных fuelcap и mpg, то при вызове метода range ()
используются данные текушеrо объекта.
Действие метода range () завершается по достижении закрывающей фигурной скобки
его тела. При этом управление возвращается вызывающей части программы.
А теперь рассмотрим подробнее следующую строку кода в методе main ():
minivan.range();
В этой строке кода вызывается метод range () для объекта mini van. Чтобы вызвать
метод для конкретного объекта, следует указать имя этого объекта перед именем метода,
используя точечную нотацию. При вызове метода ему передается управление потоком
выполнения программы. Когда метод завершит свое действие, управление будет возвращено
вызывающей части программы, и ее выполнение продолжится со строки кода,
следующей за вызовом метода.
В данном случае в результате вызова mini van. range () отображается дальность поездки
транспортного средства, определяемого объектом minivan. Точно так же при
вызове sportscar. range () на экран выводится дальность поездки транспортного
средства, определяемого объектом sportscar. При каждом вызове метода range () выводится
дальность поездки для указанного объекта.
Глава 4. Введение в классы, объекты и методы 137
Необходимо отметить следующую особенность метода range (): обращение к переменным
экземпляра fuelcap и mpg осуществляется в нем без использования точечной
нотации. Если в методе используется переменная экземпляра, определенная в его классе,
обращаться к ней можно напрямую, не указывая объект. По зрелом размышлении
следует признать, что такой подход вполне логичен. Ведь метод всегда вызывается относительно
некоторого объекта своего класса, а следовательно, при вызове метода объект
известен и нет никакой необходимости определять его еще раз. Это означает, что переменные
fuelcap и mpg, встречающиеся в теле метода range (), неявно обозначают их
копии, находящиеся в том объекте, для которого вызывается метод range ().
Возврат из метода
Возврат из метода осуществляется при выполнении одного из двух условий. Первое
из них вам уже знакомо по методу range () , а именно: признаком завершения метода
и возврата из него служит закрывающая фигурная скобка. Вторым условием является
выполнение оператора return. Существуют две разновидности оператора return:
одна - для методов типа void, не возвращающих значение, а другая - для методов,
возвращающих значение вызывающей части программы. Здесь мы рассмотрим первую
разновидность оператора return, а о возвращаемых значениях речь пойдет в следующем
разделе.
Организовать немедленное завершение метода типа void и возврат из него можно с
помощью следующей формы оператора return:
return ;
При выполнении этого оператора управление будет возвращено вызывающей части
программы, а оставшийся в методе код будет проигнорирован. Рассмотрим в качестве
примера следующий метод.
void myMeth() {
int i;
for (i=O; i<lO; i++) {
if(i == 5) return; // завершить цикл на значении 5
System.out.println();
Здесь переменная цикла for принимает лишь значения от О до 5. Как только значение
переменной i становится равным 5, цикл завершается и осуществляется возврат
из метода. В одном методе допускается несколько операторов return. Необходимость в
них возникает в том случае, если в методе организовано несколько ветвей выполнения,
как в приведенном ниже примере.
void myMeth() {
/ / . . .
if(done) return;
// . . .
if(error) return;
// . . .
138 Java 8: руководство для начинающих. 6-е издание
В данном примере метод возвращает управление вызывающей части программы либо
по завершении всех необходимых действий, либо при возникновении ошибки. Применяя
операторы return, следует соблюдать осторожность: слишком большое количество
точек возврата из метода нарушает структуру кода. В хорошо спроектированном методе
точки выхода из него находятся в хорошо продуманных местах.
Итак, метод с возвращаемым значением типа void может быть завершен одним из
двух способов: по достижении закрывающей фигурной скобки тела метода или при выполнении
оператора return.
Возврат значения
Несмотря на то что методы типа void встречаются довольно часто, большинство методов
все же возвращают значения. Способность возвращать значение относится к одним
из самых полезных свойств метода. Пример возврата значения уже встречался ранее,
когда для вычисления квадратного корня использовался метод sqrt ().
В программировании возвращаемые значения применяются для самых разных целей.
В одних случаях, как, например, при обращении к методу sqrt () , возвращаемое значение
представляет собой результат некоторых расчетов, тогда как в других оно лишь
сообщает, успешно ли были выполнены действия, предусмотренные в методе. При этом
возвращаемое значение нередко содержит код состояния. Независимо от конкретного
способа применения, возвращаемые значения являются неотъемлемой частью программирования
на Java.
Методы возвращают значения вызывающей части программы, используя следующую
форму оператора return:
return значение;
где значение - конкретное возвращаемое значение. Данная форма оператора return
может быть использована только в тех методах, тип которых отличается от типа void.
Более того, подобные методы обязаны возвращать значение, используя данную форму
оператора return.
Теперь мы можем немного видоизменить метод range () с учетом возвращаемых значений.
Вместо того чтобы выводить дальность поездки в методе range (), лучше ограничиться
ее расчетом и возвратом полученного значения. Преимущество такого подхода
заключается, в частности, в том, что возвращаемое значение может быть использовано
при выполнении других расчетов. Ниже приведен код видоизмененного метода range ().
// Использование возвращаемого значения
class Vehicle {
int passengers;
int fuelcap;
int mpg;
// количество пассажиров
// емкость топливного бака
// потребление топлива в милях на галлон
// Возврат дальности поездки.
int range () {
re t urn mpg * f ue 1 с ар; 4 Возврат даnьностн поездкн дпя заданноrо тронспортноrо средства
class RetMeth {
puЫic static void main(String args[]) {
Глава 4. Введение в классы. объекты и методы 139
Vehicle minivan
Vehicle sportscar
new Vehicle();
new Vehicle();
int rangel, range2;
// Присвоить значения полям в объекте minivan
minivan.passengers = 7;
minivan.fuelcap = 16;
minivan.mpg = 21;
// Присвоить значения полям в объекте sportscar
sportscar.passengers = 2;
sportscar.fuelcap = 14;
sportscar.mpg = 12;
// Получить дальности поездки для разных транспортных средств
rangel = rninivan.range(); --i
range2 = sportscar. range (); J>-----Прнсвоенне переменной эночення,
возвращаемого методом
Systern.out.println("Мини-фypгoн может перевезти " +
minivan.passengers + " на расстояние " + rangel + "миль");
Systern.out.println("Cпopтивный автомобиль может перевезти " +
sportscar.passengers + " на расстояние " + range2 + "миль");
Ниже приведен результат выполнения данной программы.
Мини-фургон может перевезти 7 пассажиров на расстояние 336 миль
Спортивный автомобиль может перевезти 2 пассажиров на расстояние
168 миль
Обратите внимание на то, что вызов метода range () в данной программе указывается
в правой части оператора присваивания, тогда как в левой его части - переменная,
которая принимает значение, возвращаемое методом range (). Таким образом, после
выполнения следующей строки кода значение дальности поездки для объекта mini van
сохраняется в переменной rangel:
rangel = rninivan.range();
Следует иметь в виду, что в данном случае метод range () возвращает значение типа
int, т.е. вызывающая часть программы получает целочисленное значение. Тип возвращаемого
значения - очень важная характеристика метода, поскольку возвращаемые
данные должны соответствовать типу, указанному в определении метода. Иными словами,
если метод должен возвращать значение типа douЫe, то именно таким и следует
объявить его тип.
Несмотря на то что приведенная выше программа компилируется и выполняется без
ошибок, ее эффективность можно повысить. В частности, переменные rangel и range2
в ней не нужны. Вызов метода range () можно непосредственно указать в качестве параметра
метода println (), как показано ниже.
System.out.println("Мини-фypгoн может перевезти " +
minivan.passengers + " на расстояние " + minivan.range() +
" миль");
140 Java 8: руководство для начинающих. 6-е издание
В данном случае при выполнении метода println () будет автоматически осуществляться
вызов mini van. range () , а полученное в итоге значение - передаваться методу
println (). Более того, к методу range () можно обратиться в любой момент, когда понадобится
значение дальности поездки для объекта типа Vehicle. В качестве примера
ниже приведено выражение, в котором сравнивается дальность поездки двух транспортных
средств.
if(vl.range() > v2.range()) System.out.println("vl больше v2");
Использование параметров
При вызове метода ему можно передать одно или несколько значений. Значение,
передаваемое методу, называется аргументом, тогда как переменная, получающая аргумент,
называется формальным параметром, или просто параметром. Параметры объявляются
в скобках после имени метода. Синтаксис объявления параметров такой же, как
и у переменных. Областью действия параметров является тело метода. За исключением
особых случаев передачи аргументов методу параметры действуют так же, как и любые
другие переменные.
Ниже приведен простой пример программы, демонстрирующий использование параметров.
В классе ChkNum метод isEven () возвращает логическое значение true, если
значение, передаваемое при вызове этого метода, является четным числом. В противном
случае метод возвращает логическое значение false. Таким образом, метод isEven ()
возвращает значение типа boolean.
// Простой пример применения параметра в методе
class ChkNum {
// вернуть логическое значение true,
!/ если х содержит четное число
boolean isEven(int х) { Здесьх-цеnочисnенныйпарометрметодаisЕvеn()
if((x%2) == О) return true;
else return false;
class ParmDemo {
puЫic static void main(String args[]) {
ChkNum е = new ChkNum();
􀁷-------------Передача арrумента методу isEven ()
if(e.isEven(lO)) System.out.println("lO - четное число");
if(e.isEven(9)) System.out.println("9 - четное число");
if(e.isEven(B)) System.out.println("B - четное число");
Выполнение этой программы дает следующий результат.
10 - четное число
8 - четное число
Глава 4. Введение в классы. объекты и методы 141
В данной программе метод isEven () вызывается трижды, и каждый раз ему передается
новое значение. Рассмотрим подробнее исходный код. Прежде всего обратите внимание
на то, каким образом вызывается метод isEven () . Его параметр указывается в
крутлых скобках. При первом вызове методу isEven () передается значение 10. Следовательно,
когда метод isEven () начинает выполняться, параметр х получает значение 10.
При втором вызове в качестве аргумента этому методу передается значение 9, которое
и принимает параметр х. А при третьем вызове методу isEven () передается значение
8, которое опять же присваивается параметру х. Какое бы значение вы ни указали при
вызове метода isEven () , его все равно получит параметр х.
В методе может быть определено несколько параметров, и в этом случае они разделяются
запятыми. Допустим, в классе Factor имеется метод isFactor (), который определяет,
является ли первый его параметр делителем второго:
class Factor {
boolean isFactor(int а, int Ь) {
if ( (Ь % а) == О) return true;
else return false;
class IsFact {
4---- Этот метод имеет два параметра
puЫic static void main(String args[J) {
Factor х = new Factor();
.􀀗----------- Передача двух арrумеитов методу isFactor ()
if(x.isFactor(2, 20)) System.out.println("2 - делитель");
if(x.isFactor(З, 20))
System.out.println("этa строка не будет выведена");
Обратите внимание на то, что при вызове метода isFactor () передаваемые ему значения
также разделяются запятыми.
При использовании нескольких параметров для каждого из них определяется тип,
причем типы параметров могут отличаться. Например, следующее объявление метода
является корректным.
int myMeth(int а, douЫe Ь, float с) {
/ / . . .
Добавление параметризированного
метода в класс Vehicle
Параметризированный метод позволяет реализовать в классе Vehicle новую возможность:
расчет объема топлива, необходимого для преодоления заданного расстояния.
Назовем этот новый метод fuelneeded () . Он получает в качестве параметра
расстояние в милях, которое должно проехать транспортное средство, а возвращает необходимое
для этого количество галлонов топлива. Метод fuelneeded () определяется
следующим образом.
douЫe fuelneeded(int miles) {
return (douЫe) miles / mpg;
142 Java 8: руководство для начинающих. 6-е издание
Обратите внимание на то, что этот метод возвращает значение типа douЫe. Это важно,
поскольку объем потребляемого топлива не всегда можно выразить целым числом.
Ниже приведен исходный код программы для расчета дальности поездки транспортных
средств с классом Vehicle, содержащим метод fuelneeded (} .
/*
*/
Добавление параметризированного метода, в котором производится
расчет объема топлива, необходимого транспортному средству для
преодоления заданного расстояния.
class Vehicle
int passengers; // количество пассажиров
int fuelcap; // емкость топливного бака
int mpg; // потребление топлива в милях на галлон
// Определить дальность поездки транспортного средства
int range () {
return mpg * fuelcap;
// Рассчитать объем топлива, необходимого транспортному
// средству для преодоления заданного расстояния
douЫe fuelneeded(int miles} {
return (douЫe} miles / mpg;
class CompFuel {
puЫic static void main(String args[])
Vehicle minivan = new Vehicle();
Vehicle sportscar = new Vehicle();
douЫe gallons;
int dist = 252;
// Присвоить значения полям в объекте minivan
minivan.passengers = 7;
minivan.fuelcap = 16;
minivan.mpg = 21;
// Присвоить значения полям в объекте sportscar
sportscar.passengers = 2;
sportscar.fuelcap = 14;
sportscar.mpg = 12;
gallons = minivan.fuelneeded(dist);
System.out.println("Для преодоления " + dist +
" миль мини-фургону требуется " +
gallons + " галлонов топлива");
gallons = sportscar.fuelneeded(dist};
Глава 4. Введение в классы. объекты и методы 143
System.out.println("Для преодоления " + dist +
" миль спортивному автомобилю требуется " +
gallons + " галлонов топлива");
Выполнение этой программы дает следующий результат.
Для преодоления 252 миль мини-фургону требуется 12.0 галлонов топлива
Для преодоления 252 миль спортивному автомобилю требуется 21.О
галлонов топлива
Упражнение 4.1 Создание справочноrо класса
= ................................................ : Если попытаться кратко выразить суть понятия класс, то для
1 .. Н..е.􀀇􀀈-􀀉-1-􀂘􀂙-􀂚􀂛-􀂜􀂝-􀂞-}􀂟.:.􀂟_.: этого потребуется всего одно предложение: класс инкапсулирует
функциональные возможности. Иногда трудно определить, где оканчиваются одни
функциональные возможности и начинаются другие. Общее правило можно сформулировать
так: класс должен служить стандартным блоком для компоновки приложения.
Для этой цели класс необходимо спроектировать таким образом, чтобы он представлял
собой одну функциональную единицу, выполняющую строго определенные действия.
Следовательно, нужно стремиться к тому, чтобы классы были как можно более компактными,
но в разумных пределах! Ведь классы, реализующие лишние функциональные
возможности, делают код сложным для понимания и плохо структурированным,
но классы со слишком ограниченными функциональными возможностями приводят к
тому, что программа становится неоправданно фрагментированной. Как же найти золотую
середину? В поисках ее наука программирования превращается в искусство программирования.
Многие программисты считают, что соответствующие навыки приходят
с опытом.
В качестве упражнения для приобретения нужных навыков работы с классами в этом
проекте вам предстоит преобразовать в класс Help справочную систему, созданную в
упражнении 3.3. Но прежде рассмотрим, какие для этого имеются основания. Во-первых,
справочная система представляет собой один логический блок. Эта система отображает
лишь синтаксис управляющих операторов Java. Ее функциональные возможности
четко определены. Во-вторых, реализация справочной системы в виде класса представляет
собой довольно изящное решение. Всякий раз, когда требуется отобразить подсказку
для пользователя, достаточно создать экземпляр объекта справочной системы.
И наконец, справочную информацию можно дополнить или изменить, не затрагивая
остальные части программы, поскольку она инкапсулирована в классе. Поэтапное описание
процесса создания программы приведено ниже.
1. Создайте новый файл HelpClassDemo. j ava. Чтобы сэкономить время и усилия,
скопируйте файл НеlрЗ. j ava, созданный вами в процессе работы с упражнением
3.3, и сохраните его под именем HelpClassDemo. j ava.
2. Для того чтобы преобразовать справочную систему в класс, нужно сначала четко
определить ее составные части. Так, в исходном файле НеlрЗ. j ava программы,
реализующей справочную систему, имеется код, отвечающий за отображение
меню, получение информации от пользователя, проверку достоверности ответа
и отображение данных, соответствующих выбранному пункту меню. В этой программе
имеется также цикл, который завершается при вводе символа q. По зрелом
размышлении становится ясно, что средства организации меню, проверки
144 Java 8: руководство для начинающих. 6-е издание
корректности запроса и отображения информации являются составными частями
справочной системы. В то же время порядок получения данных от пользователя
и обработки многократных запросов не имеет к системе непосредственного отношения.
Таким образом, нужно создать класс, который отображает справочную
информацию, меню для ее выбора и проверяет правильность сделанного выбора.
Соответствующие методы класса можно назвать helpon (), showmenu () и
isvalid ().
3. Создайте метод helpon (), исходный код которого приведен ниже.
void helpon{int what)
switch {what) {
case '1':
System.out.println{"Oпepaтop if:\n");
System.out.println{"if{ycлoвиe) оператор;");
System.out.println{"else оператор;");
break;
case '2':
System.out.println{"Oпepaтop switch:\n");
System.out.println{"switch{выpaжeниe) {");
System.out.println{" case константа:");
System.out.println{" последовательность операторов");
System.out.println{" break;");
System.out.println{" // ... ");
System.out.println{"}");
break;
case '3':
System.out.println{"Oпepaтop for:\n");
System.out.print{"for{инициaлизaция; условие; итерация)");
System.out.println{" оператор;");
break;
case '4':
System.out.println{"Oпepaтop while:\n");
System.out.println{"while(ycлoвиe) оператор;");
break;
case '5':
System.out.println{"Oпepaтop do-while:\n");
System.out.println{"do {");
System.out.println{" оператор;");
System.out.println{"} while {условие;");
break;
case '6':
System.out.println{"Oпepaтop break:\n");
System.out.println{"break; или break метка;");
break;
case • 7':
System.out.println{"Oпepaтop continue:\n");
System.out.println("continue; или continue метка;");
break;
System.out.println{);
Глава 4. Введение в классы, объекты и методы 145
4. Создайте метод showmenu ( ) , исходный код котороrо приведен ниже.
void showmenu() {
System.out.println("Cпpaвкa:");
System.out.println(" 1. if");
System.out.println(" 2. switch");
System.out.println(" 3. for");
System.out.println(" 4. while");
System.out.println(" 5. do-while");
System.out.println(" 6. break");
System.out.println(" 7. continue\n");
System.out.print("Bыбepитe (q - выход): ");
5. И наконец, создайте метод isvalid ().
boolean isvalid(int ch) {
if(ch < '1' 1 ch > '7' & ch != 'q') return false;
else return true;
6. Добавьте созданные выше методы в класс Help.
class Help {
void helpon(int what)
switch(what) {
case '1':
System.out.println("Onepaтop if:\n");
System.out.println("if(ycлoвиe) оператор;");
System.out.println("else оператор;");
break;
case '2':
System.out.println("Oпepaтop switch:\n");
System.out.println("switch(выpaжeниe) {");
System.out.println(" case константа:");
Systern.out.println(" последовательность операторов");
System.out.println(" break;");
Systern.out.println(" // ... ");
Systern.out.println("}");
break;
case '3':
Systern.out.println("Onepaтop for:\n");
Systern.out.print("for(инициaлизaция; условие; итерация)");
Systern.out.println(" оператор;");
break;
case '4':
System.out.println("Onepaтop while:\n");
Systern.out.println("while(ycлoвиe) оператор;");
break;
case '5':
Systern.out.println("Oпepaтop do-while:\n");
Systern.out.println("do {");
Systern.out.println(" оператор;");
Systern.out.println("} while (условие;");
break;
146 Java 8: руководство дnя начинающих. 6-е издание
case '6':
System.out.println("Oпepaтop break:\n");
System.out.println("break; или break метка;");
break;
case '7':
System.out.println("Oпepaтop continue:\n");
System.out.println("continue; или continue метка;");
break;
System.out.println(};
void showmenu() {
System.out.println("Cпpaвкa:");
System.out.println(" 1. if"};
System.out.println(" 2. switch");
System.out.println(" 3. for"};
System.out.println(" 4. while");
System.out.println(" 5. do-while"};
System.out.println(" 6. break");
System.out.println(" 7. continue\n");
System.out.print("Bыбepитe (q - выход): "};
boolean isvalid(int ch} {
if(ch < '1' 1 ch > '7' & ch != 'q'} return false;
else return true;
7. Перепишите метод main () из упражнения 3.3 таким образом, чтобы использовать
в нем новый класс Help. Сохраните новый исходный код в файле HelpClassDemo.
j ava. Ниже приведен весь исходный код программы, реализующей справочную
систему в файле HelpClassDemo. java.
/*
*/
Упражнение 4.1
Преобразование в класс Help справочной системы
из упражнения 3.3
class Help {
void helpon(int what)
switch(what} {
case '1':
System.out.println("Oпepaтop if:\n");
System.out.println("if(ycлoвиe} оператор;"};
System.out.println("else оператор;"};
break;
case '2':
System.out.println("Oпepaтop switch:\n");
System. out. println ( "switch (выражение} { "};
System.out.println(" case константа:"};
Глава 4. Введение в классы. объекты и методы 147
System.out.println(" последовательность операторов");
System.out.println(" break;");
System.out.println(" // ... ");
System.out.println("}");
break;
case '3':
System.out.println("Oпepaтop for:\n");
System.out.print("for(инициaлизaция; условие; итерация)");
System.out.println(" оператор;");
break;
case '4':
System.out.println("Oпepaтop while:\n");
System.out.println("while(ycлoвиe) оператор;");
break;
case '5':
System.out.println("Oпepaтop do-while:\n");
System.out.println("do {");
System.out.println(" оператор;");
System.out.println("} while (условие;");
break;
case '6':
System.out.println("Oпepaтop break:\n");
System.out.println("break; или break метка;");
break;
case '7':
System.out.println("Oпepaтop continue:\n");
System.out.println("continue; или continue метка;");
break;
System.out.println();
void showmenu() {
System.out.println("Cпpaвкa:");
System.out.println(" 1. if");
System.out.println(" 2. switch");
System.out.println(" З. for");
System.out.println(" 4. while");
System.out.println(" 5. do-while");
System.out.println(" 6. break");
System.out.println(" 7. continue\n");
System.out.print("Bыбepитe (q - выход): ");
boolean isvalid(int ch) {
if(ch < '1' 1 ch > '7' & ch != 'q') return false;
else return true;
class HelpClassDemo {
puЫic static void main(String args[])
throws java.io.IOException {
148 Java 8: руководство для начинающих. 6-е издание
char choice, ignore;
Help hlpobj = new Help();
for (;;) {
do {
hlpobj.showmenu();
choice = (char) System.in.read();
do {
ignore = (char) System.in.read();
} while(ignore != '\n');
while( !hlpobj.isvalid(choice) );
if(choice == 'q') break;
System.out.println("\n");
hlpobj.helpon(choice);
Запустив эту программу на выполнение, вы увидите, что она ведет себя точно так же,
как и предыдущая ее версия. Преимущество нынешней версии заключается лишь в том,
что теперь справочная система может быть использована повторно всякий раз, когда в
этом возникнет потребность.
Конструкторы
В предьщущем примере программы мы вынуЖДены бьmи вручную устанавливать значения
переменных экземпляра для каждого объекта типа Vehicle, как показано ниже.
minivan.passengers = 7;
minivan.fuelcap = 16;
minivan.mpg = 21;
Но в профессионально написанных на Java программах такой подход вообще не применяется,
и на то есть причины. Во-первых, существует большая вероятность допустить
ошибку (например, не установить значение одного из полей). И во-вторых, существует
гораздо более простой и надежный способ решения подобной задачи: использование
конструкторов.
Конструктор инициализирует объект при его создании. Имя конструктора совпадает
с именем класса, а с точки зрения синтаксиса он подобен методу. Но у конструкторов
нет возвращаемого типа, указываемого явно. Как правило, конструкторы используются
для задания первоначальных значений переменных экземпляра, определенных в классе,
или же для выполнения любых других установочных процедур, которые требуются для
создания полностью сформированного объекта.
Конструкторы имеются у всех классов, независимо от того, определите вы их или
нет, поскольку Java автоматически предоставляет конструктор, используемый по умолчанию
и инициализирующий все переменные экземпляра их значениями по умолчанию.
Глава 4. Введение в классы. объекты и методы 149
Для большинства типов данных значением по умолчанию является нулевое, для типа
bool - логическое значение false, а для ссылочных типов - пустое значение null. Но
как только вы определите свой собственный конструктор, конструктор по умолчанию
предоставляться не будет.
Ниже приведен простой пример, демонстрирующий применение конструктора.
// Простой конструктор
class MyClass
int х;
MyClass ()
х = 10;
----- Конструктор класса MyClass
class ConsDerno (
puЬlic static void rnain(String args[]) (
MyClass tl new MyClass();
MyClass t2 = new MyClass();
Systern.out.println(tl.x + " " + t2.x);
В данном примере конструктор класса MyClass объявляется следующим образом.
MyClass ()
х = 10;
В этом конструкторе переменной экземплярах, определяемой в классе MyClass,
присваивается значение 10. Этот конструктор вызывается оператором new при создании
объекта данного класса. Ниже приведена строка кода, в которой используется оператор
new.
MyClass tl = new MyClass();
В этой строке кода для объекта tl вызывается конструктор MyClass (), в котором
переменной экземпляра tl.х присваивается значение 10. То же самое происходит и для
объекта t2. После вызова данного конструктора переменная экземпляра t2.х также получает
значение 10. Таким образом, выполнение приведенного выше примера программы
дает следующий результат:
10 10
Параметризированные конструкторы
В предыдущем примере использовался конструктор без параметров. В некоторых
случаях этого оказывается достаточно, но зачастую конструктор должен принимать один
или несколько параметров. В конструктор параметры вводятся таким же образом, как и
в метод. Для этого достаточно объявить их в скобках после имени конструктора. Ниже
приведен пример применения параметризированноrо конструктора класса MyClass.
150 Java 8: руководство для начинающих. 6-е издание
// Параметризированный конструктор
class MyClass
int х;
MyClass(int i) {
х = i;
class ParmConsDemo {
..---- Этот конструктор нмеет nарометр
puЬlic static void main(String args[])
MyClass tl new MyClass(lO);
MyClass t2 = new MyClass(88);
System.out.println(tl.x + " " + t2.x);
Результат выполнения данной программы выглядит следующим образом:
10 88
В данной версии программы в конструкторе класса MyClass определяется единственный
параметр i, который используется для инициализации переменной экземпляра х.
При выполнении следующей строки кода значение 10 сначала передается параметру i
данного конструктора, а затем присваивается переменной х:
MyClass tl = new MyClass(lO);
Добавление конструктора в класс Vehicle
Теперь мы можем усовершенствовать класс Vehicle, добавив в него конструктор, в
котором будут автоматически инициализироваться поля passengers, fuelcap и mpg при
построении объекта. Обратите особое внимание на то, каким образом со:щаются объекты
типа Vehicle.
// Добавление конструктора
class Vehicle
int passengers; // количество пассажиров
int fuelcap; // емкость топливного бака
int mpg; // потребление топлива в милях на галлон
// Это конструктор класса Vehicle
Vehicle (int р, int f, int m) {
passengers = р;
----- Конструктор кnасса Vehicle
fuelcap = f;
mpg = m;
// Определить дальность поездки транспортного средства
int range () {
return mpg * fuelcap;
Глава 4. Введение в классы. объекты и методы 151
// Рассчитать объем топлива, необходимого транспортному
// средству для преодоления заданного расстояния
douЫe fuelneeded(int miles) {
return (douЫe) miles / mpg;
class VehConsDemo {
puЫic static void main(String args(J) {
// Полностью сконструировать объекты транспортных средств
Vehicle minivan = new Vehicle(7, 16, 21);
Vehicle sportscar = new Vehicle(2, 14, 12);
douЬle gallons;
int dist = 252;
gallons = minivan.fuelneeded(dist);
System.out.println("Для преодоления " + dist +
"миль мини-фургону требуется " +
gallons + " галлонов топлива");
gallons = sportscar.fuelneeded(dist);
System.out.println("Для преодоления " + dist +
"миль спортивному автомобилю требуется " +
gallons + " галлонов топлива");
При создании объекты minivan и sportscar инициализируются конструктором
Vehicle (). Каждый такой объект инициализируется параметрами, указанными в конструкторе
его класса. Например, в строке кода
Vehicle minivan = new Vehicle(7, 16, 21);
значения 7, 16 и 21 передаются конструктору Vehicle () при создании нового объекта
mini van с помощью оператора new.
В итоге копии переменных passengers, fuelcap и mpg в объекте minivan будут содержать
значения 7, 16 и 21 соответственно. Рассмотренная здесь версия программы
дает такой же результат, как и ее предьшущая версия.
Еще раз об операторе new
Теперь, когда вы ближе познакомились с классами и их конструкторами, вернемся
к оператору new, чтобы рассмотреть его более подробно. Ниже приведена общая форма
этого оператора в контексте присваивания:
переменная_класса = new имя_класса(список_аргументов)
где переменная_ класса обозначает тип переменной создаваемого класса, а имя_ кла сса
- конкретное имя класса, реализуемого в виде экземпляра его объекта. Имя класса и
список_ аргументов в скобках, который может быть пустым, обозначают конструктор
этого класса. Если в классе не определен его собственный конструктор, то в операторе new
будет использован конструктор, предоставляемый в Java по умолчанию. Следовательно,
152 Java 8: руководство для начинающих. 6-е издание
оператор new может быть использован для создания объекта, относящегося к классу
любого типа. Оператор new возвращает ссьmку на вновь созданный объект, который
получает переменная
_
класса в результате присваивания в данной форме записи.
Оперативная память не бесконечна, и поэтому вполне возможно, что оператору new
не удастся выделить память для объекта из-за нехватки доступной памяти. В этом случае
генерируется исключение времени выполнения (подробнее об обработке исключений
речь пойдет в главе 9). В примерах программ, представленных в книге, ситуаuия, связанная
с исчерпанием оперативной памяти, не учитывается, но при написании реальных
программ такую возможность, вероятно, придется принимать во внимание.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Почему оператор new не указывается для переменных таких простых типов,
как int или float?
ОТВЕТ. В Java простые типы не реализованы в виде объектов. Ради повышения
эффективности кода они реализованы как обычные переменные. Переменная
простого типа фактически содержит присвоенное ей значение. Как пояснялось
ранее, объектные переменные ссылочного типа представляют собой ссьmки на
объекты. Такая косвенная адресаuия (а также другие особенности объектов)
вносят дополнительные накладные расходы при работе с объектами. Но подобные
издержки не возникают при обращении с простыми типами данных.
Сборка мусора и методы завершения
Как было показано выше, при использовании оператора new свободная память для
создаваемых объектов динамически вьщеляется из пула свободной оперативной памяти.
Разумеется, оперативная память не бесконечна, и поэтому свободная память рано или
поздно исчерпывается. Это может привести к невозможности выполнения оператора
new из-за нехватки памяти для создания требуемого объекта. Именно по этой причине
одной из главных функuий любой схемы динамического распределения памяти является
своевременное освобождение памяти от неиспользуемых объектов, чтобы сделать
ее доступной для последующего перераспределения. Во многих языках программирования
освобождение распределенной ранее памяти осуществляется вручную. Например,
в С++ для этой uели служит оператор delete. Но в Java применяется другой, более надежный
подход: сборка мусора.
Система сборки мусора Java освобождает память от лишних объектов автоматически,
действуя прозрачно, "за кулисами", и без всякого вмешательства со стороны программиста.
Эта система работает следующим образом. Если ссылки на объект отсутствуют, то
такой объект считается больше ненужным, и занимаемая им память в итоге возвращается
в пул. Эта возвращенная память может быть затем распределена для других объектов.
Сборка мусора осуществляется лишь время от времени по ходу выполнения программы.
Она не выполняется сразу же после того, как обнаруживается, что существует
один или несколько объектов, которые больше не используются. Обычно, во избежание
снижения производительности, сборка мусора выполняется лишь при выполнении двух
условий: существуют объекты, подлежащие удалению, и есть необходимость освободить
Глава 4. Введение в классы. объекты и методы 153
занимаемую ими память. Не забывайте о том, что сборка мусора требует определенных
затрат времени, и исполнительная система Java при выполнении этой операции руководствуется
принципом целесообразности. Следовательно, вы никогда не можете знать
точно, когда именно произойдет сборка мусора.
Метод f inalize ()
В Java предусмотрена возможность определить метод, так называемый финализатор,
который будет вызван непосредственно перед окончательным удалением объекта из
памяти. Этот метод называется finalize (). Он позволяет убедиться в том, что объект
можно безболезненно удалить. Например, его можно использовать для закрытия файла,
ранее открытого удаляемым объектом.
Для того чтобы добавить в класс финализатор, достаточно определить метод
finalize (). Исполняющая система Java вызовет этот метод перед фактическим удалением
объекта. В теле метода finalize () следует предусмотреть действия, которые
должны быть выполнены непосредственно перед удалением объекта.
Ниже приведена общая форма метода finalize ().
protected void finalize()
(
// здесь указывается код метода завершения
Ключевое слово protected - это спецификатор, предотвращающий доступ к методу
finalize () за пределами класса. Этот и другие спецификаторы доступа более подробно
рассматриваются в главе 6.
Важно понимать, что метод finalize () вызывается тогда, когда система сборки мусора
принимает решение об освобождении памяти, занимаемой данным объектом. Но
если объект в это время оказывается вне области видимости, то метод finalize () не
будет вызван. Поэтому невозможно предсказать, когда именно и при каких условиях
метод finalize () будет выполнен. Например, если программа успеет завершиться еще
до того, как будет запуmена процедура сборки мусора, то вызова метода finalize () не
произойдет. Поэтому нормальная работа программы не должна зависеть от того, вызван
или не вызван метод finalize (), а для освобождения ресурсов, которые программе
больше не нужны, следует использовать другие средства.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Мне известно, что в языке С++ определены так называемые деструкторы,
автоматически выполняющиеся при удалении объектов. Подобен ли метод
finalize () деструктору?
ОТВЕТ. В языке Java деструкторы не определены. Метод finalize () действительно
выполняет функции деструктора, но не равнозначен ему. Например, деструктор
С++ всегда вызывается перед тем, как объект исчезает из области видимости,
а предсказать момент выполнения метода finalize () для конкретного объекта
невозможно. Но, поскольку в Java используется автоматическая сборка мусора,
особой надобности в деструкторе не суmествует.
154 Java 8: руководство для начинающих, 6-е издание
Упражнение 4.2 Демонстрация работы сборщика мусора
и финализатора
В связи с тем что сборка мусора начинается в неопределенные моменты
времени и выполняется в фоновом режиме, продемонстри-
ровать ее действие не так-то просто, но все же это можно сделать с помощью метода
finalize (). Напомним, данный метод вызывается непосредственно перед удалением
объекта. Но, как ранее уже отмечалось, объект удаляется не сразу же после того, как необходимость
в нем отпадает. Вместо этого система сборки мусора выбирает момент времени,
когда освобождение памяти может быть произведено наиболее эффективно. Чаще
всего для этого должно накопиться достаточно большое количество неиспользуемых
объектов. Поэтому для демонстрации сборки мусора с помощью метода finalize ()
нужно создать и удалить как можно больше объектов, что и предстоит сделать в данном
проекте. Поэтапное описание процесса создания программы приведено ниже.
1. Создайте новый файл Finalize. java.
2. Создайте класс FDemo, как показано ниже.
class FDemo
int х;
FDemo (int i) {
х = i;
// Вызывается при удалении объекта
protected void finali ze () {
System.out.println("Финaлизaция " + х);
// Генерирует объект, который тотчас уничтожается
void generator(int i) {
FDemo о = new FDemo(i);
В конструкторе данного класса устанавливается значение переменной экземпляра
х, определяемое передаваемым параметром. В данном примере переменная
экземпляра х используется в качестве идентификатора объекта. При утилизации
объекта метод finalize () отображает значение переменной х. Обратите внимание
на метод generator (). В нем создается объект типа FDemo, который сразу же
уничтожается. Этот метод будет использован в дальнейшем.
3. Создайте класс Finalize, как показано ниже.
class Finalize {
puЫic static void main {String args []) {
int count;
FDemo оЬ = new FDemo(O);
/* Генерируется большое количество объектов.
В какой-то момент времени должна начаться сборка мусора.
Глава 4. Введение в классы, объекты и методы 155
Примечание: возможно, для того чтобы активизировать
систему сборки мусора, количество генерируемых объектов
придется увеличить. */
for(count=l; count < 100000; count++)
ob.generator(count);
В классе Finalize сначала создается исходный объект оЬ типа FDemo. Затем из
данного объекта формируется 100000 других аналогичных объектов. С этой целью
вызывается метод generator () для объекта оЬ. На различных этапах процесса
вступает в действие процедура сборки мусора. Частота активизации процедуры
зависит от целого ряда факторов, в том числе от объема свободной памяти и типа
операционной системы. Но в любом случае в какой-то момент времени вы увидите
сообщения, выводимые на экран в процессе выполнения метода finalize ().
Если ни одного сообщения не появится, попробуйте увеличить число создаваемых
объектов, изменив условие завершения цикла for.
4. Ниже приведен полный исходный код программы из файла Finalize. java.
/*
Упражнение 4.2
Демонстрация сборки мусора и метода finalize()
*/
class FDemo
int х;
FDemo(int i) {
х = i;
// Вызывается при удалении объекта
protected void finalize() {
System.out.println("Финaлизaция " + х);
// Генерирует объект, который тотчас же уничтожается
void generator(int i) {
FDemo о = new FDemo(i);
class Finalize {
puЬlic static void main(String args[]) {
int count;
FDemo оЬ = new FDemo(O);
/* Генерируется большое количество объектов.
В какой-то момент должна начаться сборка мусора.
Примечание: возможно, для того чтобы активизировать
156 Java 8: руководство для начинающих, 6-е издание
систему сборки мусора, количество генерируемых объектов
придется увеличить. */
for(count=l; count < 100000; count++)
ob.generator(count);
Ключевое слово this
И в завершение рассмотрим ключевое слово this. При вызове метода ему автоматически
передается ссылка на вызывающий объект. Эта ссылка обозначается ключевым
словом this. Следовательно, ключевое слово this обозначает именно тот объект, по
ссылке на который действует вызываемый метод. Поясним назначение ключевого слова
this на примере программы, в которой создается класс Pwr, предназначенный для вычисления
целочисленной степени заданного числа.
class Pwr {
douЫe Ь;
int е;
douЫe val;
Pwr(douЫe base, int ехр) {
Ь base;
е = ехр;
val = 1;
if(exp==O) return;
for( ; ехр>О; ехр--) val
douЫe get_pwr()
return val;
class DemoPwr {
val * base;
puЫic static void main(String args[]) {
Pwr х new Pwr(4.0, 2);
Pwr у new Pwr(2.5, 1);
Pwr z = new Pwr(S.7, О);
System.out.println(x.b + 11 в степени 11 + х.е +
II равно 11 + x.get_pwr());
System.out.println(y.b + 11 в степени the 11 + у.е +
II равно 11 + y.get_pwr());
System.out.println(z.b + 11 в степени 11 + z.e +
II равно 11 + z.get_pwr());
Глава 4. Введение в классы. объекты и методы 157
Как вам уже известно, в теле метода можно непосредственно обращаться к другим
членам класса, не указывая имя объекта или класса. Так, в методе get pwr () имеется
оператор
return val;
который возвращает копию значения переменной val, связанной с вызывающим объектом.
Этот оператор можно переписать в таком виде:
return this.val;
где ключевое слово this ссылается на объект, для которого был вызван метод get
pwr (). Следовательно, this. val - это ссылка на копию переменной val в данном
объекте. Таким образом, если бы метод get pwr () бьш вызван для объекта х, ключевое
слово this в приведенном выще операторе ссьшалось бы на объект х. Оператор, в котором
отсутствует ключевое слово this, на самом деле является не более чем сокращенной
записью.
Ниже приведен исходный код класса Pwr, написанный с использованием ключевого
слова this.
class Pwr {
douЫe Ь;
int е;
douЫe val;
Pwr(douЫe base, int ехр) {
this.b base;
this.e = ехр;
this.val = 1;
if(exp==O) return;
for( ; ехр>О; ехр--) this.val
douЫe get_pwr() {
return this.val;
this.val * base;
На самом деле ни один программист не напишет класс Pwr подобным образом, поскольку
добавление ключевого слова this не дает никаких преимушеств. В то же время
стандартная форма записи тех же операторов выглядит значительно проще. Но в ряде
случаев ключевое слово this может оказаться очень полезным. Например, синтаксис
языка Java не запрещает использовать имена параметров или локальных переменных,
совпадающие с именами глобальных переменных. В этом случае говорят, что локальная
переменная или параметр скрывает переменную экземпляра. При этом доступ к скрытой
переменной экземпляра обеспечивается использованием ключевого слова this. Так,
приведенный ниже пример конструктора класса Pwr () синтаксически правилен, но подобного
стиля программирования рекомендуется все же избегать.
Pwr(douЫe Ь, int е) {
this.b Ь;
this.e = е;
158 Java 8: руководство для начинающих, 6-е издание
val = l;
if(e== O) return;
for( ; е>О; е--) val = val * Ь;
В данной версии конструктора класса Pwr имена параметров совпадают с именами
переменных экземпляра, скрывая их. А ключевое слово this используется здесь для
того, чтобы "открыть" переменные экземпляра.
"fl(
Вопросы н упраж.нення ДJ1Я самопроверки
1. Чем отличается класс от объекта?
2. Как определяется класс?
З. Чью собственную копию содержит каждый объект?
4. Покажите, как объявить объект counter класса MyCounter, используя два отдельных
оператора.
5. Как должен быть объявлен метод myMeth, принимающий два параметра, а и Ь,
типа int и возвращающий значение типа douЫe?
6. Как должно завершаться выполнение метода, возвращающего некоторое значе-
ние?
7. Каким должно быть имя конструктора?
8. Какие действия выполняет оператор new?
9. Что такое сборка мусора и какие действия она выполняет? Когда вызывается ме-
тод finalize ()?
10. Что означает ключевое слово this?
11. Может ли конструктор иметь один или несколько параметров?
12. Если метод не возвращает значения, то как следует объявить тип этого метода?
Глава 5
Дополнительные
сведения о типах
данных и операциях
160 Java 8: руководство для начинающих, 6-е издание
В этой главе ...
􀂸 Представление о массивах
*' Создание многомерных массивов
􀂹 Создание нерегулярных массивов
@f Альтернативный синтаксис объявления массивов
􀂺 Присваивание ссылок на массивы
􀂻 Применение переменной экземпляра length массивов
Ф Использование расширенного цикла for
􀂼 Манипулирование символьными строками
3 Использование аргументов командной строки
􀂽 Использование поразрядных операторов
􀂾 Применение оператора ?
в этой главе мы возвращаемся к обсуждению типов данных и операторов Java. В частности,
речь пойдет о массивах, классе String, поразрядных операторах и тернарном
операторе?. Кроме того, мы рассмотрим разновидность цикла for, реализованную
лишь в самых последних версиях языка. Внимание также будет уделено аргументам
командной строки.
Массивы
Массив представляет собой совокупность однотипных переменных с общим именем.
В Java массивы могут быть как одномерными, так и многомерными, хотя чаще всего используются
одномерные массивы. Массивы могут применяться для самых разных целей,
поскольку они предоставляют удобные средства для объединения связанных вместе переменных.
Например, в массиве можно хранить максимальные суточные температуры,
зарегистрированные в течение месяца, перечень биржевых курсов или же названия книг
по программированию из домашней библиотеки.
Главное преимуmество массива - возможность организации данных таким образом,
чтобы ими было проще манипулировать. Так, если имеется массив данных о дивидендах,
выплачиваемых по избранной группе акций, то, организовав циклическое обращение
к элементам этого массива, можно без особого труда рассчитать приносимый этими
акциями средний доход. Кроме того, массивы позволяют организовать данные таким
образом, чтобы облегчить их сортировку.
Массивами в Java можно пользоваться практически так же, как и в других языках программирования.
Тем не менее у них имеется одна особенность: они реализованы в виде
объектов. Именно поэтому их рассмотрение было отложено до тех пор, пока не будут
представлены объекты. Реализация массивов в виде объектов дает ряд суmественных преимуmеств,
и далеко не самым последним среди них является возможность освобождения памяти,
занимаемой массивами, которые больше не испооьзуются, средствами сборки мусора.
Глава 5. Дополнительные сведения о типах данных и операциях 161
Одномерные массивы
Одномерный массив представляет собой список связанных переменных. Такие списки
часто применяются в программировании. Например, в одномерном массиве можно хранить
номера учетных записей активных пользователей сети или текущие средние результаты
достижений бейсбольной команды.
Для объявления одномерного массива обычно применяется общий синтаксис следующего
вида:
тип имя_массива [] = new тип[размер];
где тип объявляет конкретный тип массива. Тип массива, называемый также базовым
типом, одновременно определяет тип данных каждого элемента, составляющего массив,
а размер определяет число элементов массива. В связи с тем что массивы реализованы
в виде объектов, создание массива происходит в два этапа. Сначала объявляется переменная,
ссылающаяся на массив, а затем выделяется память для массива, и ссылка на
нее присваивается переменной массива. Следовательно, память для массивов в Java выделяется
динамически с помощью оператора new.
Проиллюстрируем все сказанное выше на конкретном примере. В следующей строке
кода создается массив типа int, состоящий из 10 элементов, а ссылка на него присваивается
переменной sample:
int sample[] = new int[lO];
Объявление массива работает точно так же, как и объявление объекта. В переменной
sample сохраняется ссылка на область памяти, вьщеляемую для массива оператором
new. Этой памяти должно быть достаточно для размещения 10 элементов типа int.
Как и объявление объектов, приведенное выше объявление массива можно разделить
на две отдельные составляющие.
int sample[J;
sample = new int[lOJ;
В данном случае сначала создается переменная sample, которая пока что не ссылается
на конкретный объект. А затем переменная sample получает ссылку на конкретный
массив.
Доступ к отдельным элементам массива осуществляется с помощью индексов.
Индекс обозначает позицию элемента в массиве. В Java индекс первого элемента массива
равен нулю. Так, если массив sample содержит 10 элементов, их индексы находятся в
пределах от О до 9. Индексирование массива осуществляется по номерам его элементов,
заключенным в квадратные скобки. Например, для доступа к первому элементу массива
sarnple следует указать sarnple [ О J, а для доступа к последнему элементу этого массива
- sarnple [ 9 J. В приведенном ниже примере программы в массиве sarnple сохраняются
числа от О до 9.
// Демонстрация одномерного массива
class ArrayDemo {
puЫic static void main(String args[])
int sample[J = new int[lO];
int i;
for(i = О; i < 10; i
sample[i] = i;
i+l)
for(i = О; i < 10; i i+l)
Индексация массивов начинается с нуnя
162 Java 8: руководство для начинающих. 6-е издание
System.out.println("Элeмeнт[" + i + "]: " +
sample[i));
Результат выполнения данной программы выглядит следующим образом.
Элемент sample[OJ: о
Элемент sample[l]: 1
Элемент sample[2]: 2
Элемент sample[3]: 3
Элемент sample[4]: 4
Элемент sample[5]: 5
Элемент sample [ 6] : 6
Элемент sample [7]: 7
Элемент sample[8]: 8
Элемент sample[9]: 9
Структура массива sample наглядно показана на рисунке ниже.
о 1 2 3 4 5 6 7 8 9
5 􀀅
с::. 􀀆 м 􀀇 􀀈 Ъ' Е: §: 􀀉
QJ Q) Q) 11) QJ 11) QJ QJ QJ о. о. р., о. о. о. о. о.
Е е 􀀊 Е Е s s=. Е
<U <1S "' "' с; ;;; <U
V) V) V) V) ;л ;л V) V) V)
Массивы часто используются в программировании, поскольку они позволяют обрабатывать
в цикле большое количество переменных. Например, в результате выполнения
следующего примера программы определяется минимальное и максимальное значения
из всех, хранящихся в массиве nums. Элементы этого массива перебираются в цикле for.
!/ Нахождение минимального и максимального значений в массиве
class MinMax {
puЫic static void main(String args[]) {
int nums[J = new int[lOJ;
int min, max;
nums[OJ 99;
nums[l] -10;
nums[2] 100123;
nums[3] 18;
nums[4] -978;
nums[5] 5623;
nurns[6] 463;
nums[7] -9;
nums[8] 287;
nums[9] 49;
min = max = nums[OJ;
for(int i=l; i < 10; i++)
if(nums[i] < min) min nums[i];
if(nums[i] > max) max = nums[i];
Глава 5. Дополнительные сведения о типах данных и операциях 163
System.out.println("min и max: " + min + " " + max);
)
Вот результат выполнения данной программы:
min и max: -978 100123
В показанном выше примере массив nums заполняется вручную в десяти операторах
присваивания. И хотя в этом нет ничего неверного, существует более простой способ
решения этой задачи. Массивы можно инициализировать в процессе их создания. Для
этой цели служит приведенная ниже общая форма инициализации массива:
тип имя_массива[] = {vall, val2, valЗ, . . . , valN};
где va 11-va lN обозначают начальные значения, которые поочередно присваиваются
элементам массива слева направо в направлении роста индексов. Java автоматически
выделяет объем памяти, достаточный для хранения инициализаторов массивов.
При этом необходимость в использовании оператора new явным образом отпадает сама
собой. В качестве примера ниже приведена улучшенная версия программы, в которой
определяются максимальное и минимальное значения в массиве.
// Применение инициализаторов массива
class MinMax2 {
puЫic static void main(String args[J)
int nums[J = { 99, -10, 100123, 18, -978,
5623, 463, -9, 287, 49 } ;
int min, max;
min = max = nums[OJ;
for(int i=l; i < 10; i++)
if (nums [i) < min) min nums[i];
if(nums[il > max) max nums[i];
4---- Иннцноnнэоторы мосснво
System.out.println("min и max: " + min + " " + max);
Границы массива в Java строго соблюдаются. В случае выхода индекса за верхнюю
или нижнюю границу массива при выполнении программы возникает ошибка. Для того
чтобы убедиться в этом, попробуйте выполнить приведенную ниже программу, в которой
намеренно превышаются границы массива.
// Демонстрация превЫПiения границ массива
class ArrayErr {
puЫic static void main(String args[J) {
int sample[J = new int[lOJ;
int i;
// Искусственно создать выход индекса за границы массива
for(i = О; i < 100; i = i+l)
sample[i] = i;
164 Java 8: руководство дпя начинающих. 6-е издание
Как только значение переменной i достигнет 10, будет сгенерировано исключение
ArrayindexOutOfBoundsException, и выполнение программы прекратится.
Упражнение 5.1 Сортировка массива
.....................................
: вuьые. j аvа) Как пояснялось выше, данные в одномерном массиве организова- v : ................................... : ны в виде индексируемого линеиного списка. т,􀀛а кая структура как
нельзя лучше подходит для сортировки. В этом проекте предстоит реализовать простой
алгоритм сортировки массива. Вам, вероятно, известно, что существуют разные алгоритмы
сортировки, в том числе быстрая сортировка, сортировка перемешиванием, сортировка
методом Шелла и т.п. Но самым простым и общеизвестным алгоритмом является
пузырьковая сортировка. Этот алгоритм не очень эффективен, но отлично подходит для
сортировки небольших массивов. Поэтапное описание процесса создания программы
приведено ниже.
1. Создайте новый файл ВuЬЫе. j ava.
2. В алгоритме пузырьковой сортировки соседние элементы массива сравниваются
между собой и, если требуется, меняются местами. При этом меньшие значения
сдвигаются к одному краю массива, а большие - к другому. Этот процесс напоминает
всплывание пузырьков воздуха на разные уровни в емкости с жидкостью,
откуда и произошло название данного алгоритма. Пузырьковая сортировка предполагает
обработку массива в несколько проходов. Элементы, взаимное расположение
которых отличается от требуемого, меняются местами. Число проходов,
необходимых для упорядочения элементов этим способом, на единицу меньше
количества элементов в массиве.
Ниже приведен исходный код, составляющий основу алгоритма пузырьковой сортировки.
Сортируемый массив называется nums.
// Пример реализации алгоритма пузырьковой сортировки
for(a= l; а< size; а++)
for (b=size-1; Ь >= а; Ь--) {
if(nums[b-1] > nums[b]) { // если требуемый порядок следования
// не соблюдается, поменять элементы
// местами
t = nums[b-1];
nums[b-1] = nums[b];
nums[b] = t;
Как видите, в приведенном выше фрагменте кода используются два цикла for.
Во внутреннем цикле сравниваются соседние элементы массива и выявляются
элементы, находящиеся не на своих местах. При обнаружении элемента, нарушающего
требуемый порядок, два соседних элемента меняются местами. На каждом
проходе наименьший элемент перемещается на одну позицию в нужное положение.
Внешний цикл обеспечивает повторение описанного процесса до завершения
всего процесса сортировки.
3. Ниже приведен полный исходный код программы из файла ВuЬЫе. j ava.
/*
Упражнение 5.1
Глава 5. Дополнительные сведения о типах данных и операциях 165
Демонстрация алгоритма пузырьковой сортировки
*/
class ВuЬЫе {
puЬlic static void main(String args[]) {
int nums[] = 99, -10, 100123, 18, -978,
5623, 463, -9, 287, 49 } ;
int а, Ь, t;
int size;
size = 10; // количество сортируемь􀁣 элементов
// Отобразить исходный массив
System.out.print("Иcxoдный массив:");
for(int i=O; i < size; i++)
System.out.print(" " + nums[i]);
System.out.println();
// Реализовать алгоритм пузырьковой сортировки
for(a=l; а < size; а++)
for (b=size-1; Ь >= а; Ь--) {
if(nums[b-1] > nums[b]) { // если требуемый порядок
t = nums[b-1];
nums[b-1] = nums[b];
nums[b] = t;
// следования не соблюдается,
// поменять элементы местами
// Отобразить отсортированный массив
System.out.print("Oтcopтиpoвaнный массив:");
for(int i=O; i < size; i++)
System.out.print(" " + nums[i]);
System.out.println();
Ниже приведен результат выполнения данной программы.
Исходный массив: 99 -10 100123 18 -978 5623 463 -9 287 49
Отсортированный массив: -978 -10 -9 18 49 99 287 463 5623 100123
4. Как упоминалось выше, пузырьковая сортировка отлично подходит для обработки
небольших массивов, но при большом числе элементов массива она становится
неэффективной. Более универсальным является алгоритм быстрой сортировки,
но для его эффективной реализации необходимы языковые средства Java,
которые рассматриваются далее.
166 Java 8: руководство для начинающих, 6-е издание
Многомерные массивы
Несмотря на то что одномерные массивы применяются чаще всего, в программировании,
безусловно, применяются и многомерные (двух-, трехмерные и т.д.) массивы.
В Java многомерные массивы представляют собой массивы массивов .
Двумерные массивы
Среди многомерных массивов наиболее простыми являются двумерные массивы.
Двумерный массив, по существу, представляет собой ряд одномерных массивов. Для
того чтобы объявить двумерный целочисленный табличный массив tаЫе с размерами
l0x20, следует использовать следующую строку:
int tаЫе[] [] = new int[lO] [20];
Внимательно посмотрите на это объявление. В отличие от некоторых других языков
программирования, где размеры массива разделяются запятыми, в Java они заключаются
в отдельные квадратные скобки. Так, для обращения к элементу массива tаЫе по
индексам 3 и 5 следует указать tаЫе [ 3 J [ 5] .
В следующем примере двумерный массив заполняется числами от 1 до 12.
// Демонстрация использования двумерного массива
class TwoD {
puЫic static void main(String args[])
int t, i;
int tаЫе[] [] = new int[З] [4);
for (t=O; t < 3; ++t) {
for(i=O; i < 4; ++i)
tаЫе [t] [i] = (t*4) +i+l;
System.out.print(taЬle[t] [i] + " ");
System.out.println();
В данном примере элемент tаЫе [О] [О] будет содержать значение 1, элемент
tаЫе[О] [1] - значение 2, элемент taЫe[OJ [21 - значение 3 и так далее, а элемент
tаЫе [2 J [3 J - значение 12. Структура данного массива представлена в наглядном виде
на рис. 5.1.
о 2 З+-- правый индекс
о 1 2 3 4
5 6 􀀁 8
2 9 10 11 12
i
левый ин деке
tаЫе(1][2]
Рис. 5.1. Структура массива tаЫе из программы TwoD
Глава 5. Дополнительные сведения о типах данных и операциях 167
Нерегулярные массивы
При выделении памяти для мноrомерноrо массива достаточно указать лишь первый
(крайний слева) размер. Память, соответствующую остальным измерениям массива,
можно будет выделять отдельно. Например, в приведенном ниже фрагменте кода память
выделяется только под первый размер двумерного массива tаЫе. Дальнейшее выделение
памяти, соответствующей второму измерению, осуществляется вручную .
int tаЫе[] [] = new int[ЗJ [];
tаЫе[О] new int[4];
taЫe[l] = new int[4);
tаЫе[2] = new int[4];
Объявляя массив подобным способом, мы не получаем никаких преимушеств, но в
некоторых случаях такое объявление оказывается вполне оправданным. В частности,
это дает возможность установить разную длину массива по каждому индексу. Как упоминалось
выше, многомерный массив реализован в виде массива массивов, что позволяет
контролировать размер каждого из них . Допустим, требуется написать программу,
в процессе работы которой будет сохраняться число пассажиров, перевезенных автобусом-
экспрессом в аэропорт. Если автобус делает по десять рейсов в будние дни и по
два рейса в субботу и воскресенье, то массив riders можно объявить так, как показано
в приведенном ниже фрагменте кода. Обратите внимание на то, что длина массива по
второму индексу для первых пяти элементов равна 10, а для двух последних - 2.
// Выделение памяти по второму индексу массива
class Ragged {
puЫic static void main(String args[])
int riders[J [] = new int[7] [];
riders[OJ new int[lOJ;
вручную
riders[l] new int[lO];
riders[2] new int[lOJ;
riders[З] new int[lO];
riders[4] new int[lOJ;
, ___ Дnя первых пяти эnементов АПИИа
массива по второму индексу равна 1 О
riders[5]
riders (6)
int i, j;
new int[2]􀁳·
new · t [ 2] . Дnя остаnьных двух эnементов АПИНа
l. n ' массива по второму индексу равна 2
// Сформировать произвольные данные
for(i=O; i < 5; i++)
for(j=O; j < 10; j++)
riders[i] [j] = i + j + 10;
for(i=5; i < 7; i++)
for (j=O; j < 2; j++)
riders[i) [j) = i + j + 10;
System.out.println("Koличecтвo пассажиров, перевезенных каждым
рейсом, в будние дни недели:");
for(i=O; i < 5; i++) {
for(j=O; j < 10; j++)
System.out.print(riders[i][j] +" ");
System.out.println();
168 Java 8: руководство для начинающих. 6-е издание
System.out.println();
System.out.println("Koличecтвo пассажиров, перевезенных каждым
рейсом, в выходные дни:");
for(i:5; i < 7; i++) {
for(j:O; j < 2; j++)
System.out.print(riders[i)[j) + " ");
System.out.println();
Для большинства приложений использовать нереrулярные массивы не рекомендуется,
поскольку это затрудняет восприятие кода другими программистами. Но в некоторых
случаях такие массивы вполне уместны и могут существенно повысить эффективность
программ. Так, если вам требуется создать большой двумерный массив, в котором
используются не все элементы, нереrулярный массив позволит существенно сэкономить
память.
Трехмерные, четырехмерные и многомерные массивь1
В Java допускаются массивы размерностью больше двух. Ниже приведена общая
форма объявления многомерного массива.
тип имя_массива[) [) ... [) : new тип[размер_l) [размер_2) •.. [размер_N);
В качестве примера ниже приведено объявление трехмерного целочисленного массива
с размерами 4х \Ох3.
int multidim[) (] [) : new int (4) [10) (3);
Инициализация многомерных массивов
Многомерный массив можно инициализировать, заключая инициализирующую последовательность
для каждого размера массива в отдельные фигурные скобки, как показано
ниже.
тип имя_массива[) [) : {
};
{ val, val, val, val },
{ val, val, val, ... , val },
{ val, val, val, ... , val }
Здесь val обозначает начальное значение, которым инициализируются элементы
многомерного массива. Каждый внутренний блок многомерного массива соответствует
отдельной строке. В каждой строке первое значение сохраняется в первом элементе подмассива,
второе значение - во втором элементе и т.д. Обратите внимание на запятые,
разделяющие блоки инициализаторов многомерного массива, а также на точку с запятой
после закрывающей фигурной скобки.
Глава 5. Дополнительные сведения о типах данных и операциях 169
В следующем фрагменте кода двумерный массив sqrs инициализируется числами от
1 до 10 и их квадратами.
// Инициализация двумерного массива
class Squares {
1
2
3
4
5
6
7
8
9
puЬlic static void main(String args[])
int sqrs[] [] = {
1, l } ,
2 f 4 } /
3, 9 },
4, 16 },
5, 25 },
6, 36 },
7, 49 },
8, 64 },
9, 81 },
10, 100
} ;
Обратите аннмонне но то, что у каждой
строки свой набор нннЦ/iоnнзоторо•
int i, j;
for (i=O; i < 10; i++) {
for(j=O; j < 2; j++)
System.out.print(sqrs[i][j] + " ");
System.out.println();
Выполнение этого фрагмента кода дает следующий результат.
1
4
9
16
25
36
49
64
81
10 100
Альтернативный синтаксис объявления массивов
Помимо рассмотренной выше общей формы, для объявления массива можно также
пользоваться следующей синтаксической конструкцией:
тип [ ] имя_ переменной;
Здесь квадратные скобки указываются после спецификатора типа, а не после имени
переменной. Поэтому следующие два объявления равнозначны.
int counter[] new int[3];
int[] counter = new int[3];
170 Java 8: руководство для начинающих. 6-е издание
Равнозначными являются и приведенные ниже строки кода.
char tаЫе[] [] = new char(З] [4];
char [] [] tаЫе = new char [ 3] [ 4] ;
Альтернативная форма объявления массива оказывается удобной в тех случаях, когда
требуется объявить несколько массивов одного типа. Например:
int[] nums, nums2, numsЗ; // создать три массива
В этом объявлении создаются три переменные, ссылающиеся на массивы типа int.
Тот же результат можно получить с помощью следующей строки кода:
int nums[], nums2[], numsЗ[J; // создать три массива
Альтернативный синтаксис объявления массива оказывается удобным и в тех случаях,
когда в качестве типа, возвращаемого методом, требуется указать массив. Например:
int [ J someMeth ( ) { ...
В этой строке кода объявляется метод someMeth () , возвращающий целочисленный
массив.
Обе рассмотренные выше формы объявления массивов широко распространены в
программировании на Java, и поэтому они используются в примерах, представленных
в данной книге.
Присваивание ссылок на массивы
Присваивание значения одной переменной, ссылающейся на массив , другой переменной,
по сути, означает, что обе переменные ссьmаются на один и тот же массив,
и в этом отношении массивы ничем не отличаются от любых других объектов. Такое
присваивание не приводит ни к созданию копии массива, ни к копированию содержимого
одного массива в другой. Это продемонстрировано в приведенном ниже примере
программы.
// Присваивание ссылок на массивы
class AssignARef {
puЬlic static void main(String args[J)
int i;
int numsl []
int nums2 []
new int[lOJ;
new int[lO];
for(i=O; i < 10; i++)
numsl(i] i;
for(i=O; i < 10; i++)
nums2[i] -i;
System.out.print("Maccив numsl: ");
for(i=O; i < 10; i++)
System.out.print(numsl[i] + " ");
System.out.println();
Глава 5. Дополнительные сведения о типах данных и операциях 171
System.out.print("Maccив nums2: ");
for(i=O; i < 10; i++)
System.out.print(nums2[i] + " ");
System.out.println();
nums2 = numsl; // теперь обе переменные ссылаются на массив numsl
System.out.print("Maccив nums2 после присвоения: ");
for(i=O; i < 10; i++)
System.out.print(nums2[i] + " ");
System.out.println();
// Выполнить операции над массивом numsl
// через переменную nums2
nums2[3] = 99;
System.out.print("Maccив numsl после изменения через nums2: ");
for(i=O; i < 10; i++)
System.out.print (numsl [i] + " ");
System.out.println();
Выполнение этой проrраммы дает следующий результат.
Массив numsl: О 1 2 3 4 5 6 7 8 9
Массив nums2: О -1 -2 -3 -4 -5 -6 -7 -8 -9
Массив nums2 после присвоения: О 1 2 3 4 5 б 7 8 9
Массив numsl после изменения через nums2: О 1 2 99 4 5 б 7 8 9
Нетрудно заметить, что в результате присваивания ссьmки на массив numsl переменной
nums2 обе переменные ссьmаются на один и тот же массив.
Применение переменной экземпляра length
В связи с тем что массивы реализованы в виде объектов, в каждом массиве содержится
переменная экземпляра length. Значением этой переменной является число
элементов, которые может содержать массив. (Иными словами, в переменной length
содержится размер массива.) Ниже приведен пример проrраммы, демонстрирующий
данное свойство массивов.
// Использование переменной экземпляра length
class LengthDemo {
puЬlic static void main(String args[]) {
int list[J = new int[lOJ;
int nums[] = { 1, 2, 3 };
int tаЫе[] [] = { // таблица со строками переменной длины
{1, 2, 3) t
{ 4, 5} t
{ б, 7 t 8, 9)
};
172 Java 8: руководство для начинающих. 6-е издание
System.out.println("Paзмep списка: " + list.length);
System.out.println("Paзмep nums: " + nums.length);
System.out.println("Paзмep tаЫе: " + taЫe.length);
System.out.println("Paзмep tаЫе[О]: " + tаЫе[О] .length);
System.out.println("Paзмep taЫe[l]: " + taЫe[l] .length);
System.out.println("Paзмep tаЫе[2]: " + tаЫе[2] .length);
System.out.println();
// Использовать переменную length для инициализации списка
for(int i=O; i < list.length; i++)
list[i] = i * i;
System.out.print("Coдepжимoe списка:
for(int i=O; i < list.length; i++)
System.out.print(list[i] + " ");
System.out.println();
} Испоnьзовонне переменной length
,. ) ; дnя упровnения цикnом for
Выполнение этой программы дает следующий результат.
Размер списка: 10
Размер nums: 3
Размер tаЫе: 3
Размер tаЫе [О]: 3
Размер taЫe[l]: 2
Размер tаЫе[2]: 4
Содержимое списка: О 1 4 9 16 25 36 49 64 81
Обратите внимание на то, каким образом переменная length используется в двумерном
массиве. Как пояснялось ранее, двумерный массив представляет собой массив массивов.
Поэтому приведенное ниже выражение позволяет определить число массивов,
содержащихся в массиве tаЫе:
taЫe.length
Число таких массивов равно 3. Для того чтобы получить размер отдельного массива,
содержащегося в массиве tаЫе, потребуется выражение, аналогичное следующему:
tаЫе[О] .length
Это выражение возвращает размер первого массива.
Анализируя код класса LengthDemo, следует также заметить, что выражение list.
length используется в цикле for для определения требуемого количества итераций.
Учитывая то, что у каждого подмассива своя длина, пользоваться таким выражением
удобнее, чем отслеживать вручную размеры массивов. Но не следует забывать, что переменная
length не имеет никакого отношения к количеству фактически используемых
элементов массива. Она содержит лишь данные о том, сколько элементов может содержать
массив.
Использование переменной экземпляра length позволяет упростить многие алгоритмы.
Так, в приведенном ниже примере программы эта переменная используется при
копировании одного массива в другой и предотвращает возникновение исключений
времени исполнения в связи с выходом за границы массива.
Глава 5. Дополнительные сведения о типах данных и операциях 173
// Использование переменной length для копирования массивов
class АСору {
puЫic static void main(String args[]) {
int i;
int numsl []
int nums2 []
new int[lOJ;
new int[lO];
for(i=O; i < numsl.length; i++)
numsl[i] i;
// Копировать массив numsl в массив nums2
if (nums2. length >= nums 1. length) Исnоnьэованне переменной length
for(i = О; i < nums2.length; i++) дnясравненняраэмеров массивов
nums2[i] = numsl[i];
for(i=O; i < nums2.length; i++)
System.out.print(nums2[i] + " ");
В данном примере переменная экземпляра length помогает решить две важные задачи.
Во-первых, позволяет убедиться в том, что размера целевого массива достаточно
для хранения содержимого исходного массива. И во-вторых, с ее помощью формируется
условие завершения цикла, в котором выполняется копирование массива. Конечно, в
столь простом примере размеры массивов нетрудно отследить и без переменной экземпляра
length, но подобный подход может быть применен для решения более сложных
задач.
Упражнение 5.2 Создание класса очереди
: ............................... : Вам, вероятно, известно, что структура данных - это способ их opra- j QDemo. j ava \
, ............................... , низации. О дной из самых простых структур является массив, который
представляет собой линейный список элементов, допускающий произвольный доступ
к ним. Нередко массивы используются в качестве основы для создания более сложных
структур вроде стеков или очередей. Стек - это набор элементов с организацией доступа
по принципу "первым пришел - последним обслужен", а очередь - это набор
элементов с организацией доступа по принципу "первым пришел - первым обслужен".
Стек можно сравнить со стопкой тарелок на столе: первая тарелка снизу стопки используется
последней. А очередь можно сравнить с выстроившейся очередью к окошку в
банке: клиент, стоящий в очереди первым, обслуживается первым.
В очередях и стеках нас больше всего интересует способ хранения информации и обращения
к ней. И стеки, и очереди представляют собой механизмы доступа к данным,
в которых хранение и извлечение информации поддерживается самой структурой, а не
реализуется в программе. Такое сочетание способов хранения и обработки данных лучше
всего реализуется в рамках класса, поэтому в данном проекте предстоит создать простой
класс очереди.
В очереди поддерживаются две основные операции: размещение и извлечение. При
выполнении операции размещения новый элемент помещается в конец очереди, а при
операции извлечения очередной элемент извлекается из начала очереди. Операции с
очередью являются разрушающими: элемент, однажды извлеченный из очереди, не может
быть извлечен из нее повторно. Очередь может быть переполнена, когда в ней не
17 4 Java 8: руководство для начинающих. 6-е издание
остается места для новых элементов. Но очередь может быть и пуста, когда в ней нет ни
одного элемента.
И последнее замечание: существуют два типа очередей - циклические и нециклические.
В циклической очереди элементы массива, на основе которого она создана, могут использоваться
повторно по мере удаления данных. Нециклическая очередь не позволяет
повторно использовать элементы, поэтому со временем пространство для хранения новых
элементов исчерпывается. Нециклическую очередь создать много проще, чем циклическую,
поэтому именно ее мы и реализуем в данном примере для опробования. Но
если немного подумать, то нециклическую очередь можно без особого труда превратить
в циклическую. Поэтапное описание процесса создания программы приведено ниже.
1. Создайте новый файл QDemo. j ava.
2. Очередь можно организовать разными способами. Мы создадим ее на основе
массива, выступающего в роли хранилища данных, помещаемых в очередь. Для
доступа к массиву будут использованы два индекса. Индекс вставки данных в очередь
определяет, в какое место будет помещен следующий элемент очереди. А индекс
извлечения данных указывает место, откуда должен быть извлечен очередной
элемент очереди. Напомним, что операция извлечения является разрушающей и
не позволяет извлечь один и тот же элемент дважды. Создаваемая здесь очередь
предназначена для хранения символов, но та же самая логика ее организации может
быть использована для размещения данных любых типов, в том числе объектов.
Итак, начните создание класса очереди Queue со следующих строк кода.
class Queue {
char q[]; // массив для хранения элементов очереди
int putloc, getloc; // индексы для вставки и извлечения
// элементов очереди
3. Конструктор класса Queue создает очередь заданного размера. Его код приведен
ниже.
Queue (int size) {
q = new char[size+l]; // вьшелить память для очереди
putloc = getloc = О;
Обратите внимание на то, что размер очереди на единицу превышает размер, задаваемый
параметром size. Особенности реализации очереди таковы, что один
элемент массива остается неиспользованным, поэтому размер массива должен
быть на единицу больше размера очереди, создаваемой на его основе. Первоначально
индексы вставки и извлечения данных равны нулю.
4. Метод put (), помещающий элемент в очередь, имеет следующий вид.
// Поместить символ в очередь
void put(char ch) {
if(putloc==q.length-1)
System.out.println(" - Очередь заполнена");
return;
putloc++;
q[putloc] ch;
Глава 5. Дополнительные сведения о типах данных и операциях ] 75
Прежде всего в теле данного метода проверяется, не переполнена ли очередь.
Если значение переменной putloc соответствует последней позиции в массиве
q, то места для размещения новых элементов в очереди нет. В противном случае
переменная putloc инкрементируется, и новый элемент располагается в указанном
месте массива. Следовательно, переменная putloc всегда содержит индекс
элемента, помещенного в очередь последним.
5. Для извлечения элементов из очереди служит метод get () , код которого приведен
ниже.
// Извлечь символ из очереди
char get () {
if(getloc == putloc) {
System.out.println(" - Очередь пуста");
return (char) О;
getloc++;
return q[getloc];
Сначала в данном методе проверяется, пуста ли очередь. Если значения индексов
в переменных getloc и putloc совпадают, то в очереди нет ни одного элемента.
Именно поэтому в конструкторе Queue переменные getloc и putloc инициализируются
нулевыми значениями. Если очередь не пуста, то переменная getloc
инкрементируется и из нее извлекается очередной элемент. Следовательно, переменная
getloc содержит индекс последнего извлеченного элемента.
6. Ниже приведен полный исходный код программы из файла QDemo. j ava.
/*
Упражнение 5.2
Класс, реализующий очередь для хранения символов
*/
class Queue {
char q(J; // массив для хранения элементов очереди
int putloc, getloc; // индексы для вставки и извлечения
// элементов очереди
Queue (int size) {
q = new char[size+l]; // выделить память для очереди
putloc = getloc = О;
// Поместить символ в очередь
void put(char ch) {
if(putloc==q.length-1)
System.out.println(" - Очередь заполнена");
return;
putloc++;
q[putloc] ch;
176 Java 8: руководство для начинающих. 6-е издание
// Извлечь символ из очереди
char get () {
if(getloc == putloc) {
Systern.out.println(" - Очередь пуста");
return (char) О;
getloc++;
return q[getloc];
//Демонстрация использования класса Queue
class QDerno {
puЫic static void rnain(String args[]) {
Queue bigQ = new Queue(lOO);
Queue srnallQ = new Queue(4);
char ch;
int i;
Systern.out.println("Иcпoльзoвaниe очереди ЬigQ для
сохранения алфавита");
// Поместить буквенные символы в очередь ЬigQ
for(i=O; i < 26; i++)
ЬigQ.put((char) ('А' + i));
// Извлечь буквенные символы из очереди ЬigQ и отобразить
Systern.out.print("Coдepжимoe очереди ЬigQ: ");
for (i=O; i < 26; i++) {
ch = ЬigQ.get();
if(ch != (char) 0) Systern.out.print(ch);
Systern.out.println("\n");
Systern.out.println("Иcпoльзoвaниe очереди srnallQ
для генерации ошибок");
// Использовать очередь srnallQ для генерации ошибок
for(i=O; i < 5; i++) {
Systern.out.print("Пoпыткa сохранения " +
( char) ( 'z' - i) ) ;
srnallQ.put((char) ('Z' - i));
Systern.out.println();
Systern.out.println();
// Дополнительные ошибки при обращении к очереди srnallQ
Systern.out.print("Coдepжимoe srnallQ: ");
for(i=O; i < 5; i++) {
ch = srnallQ.get();
Глава 5. Дополнительные сведения о типах данных и операциях 1 П
if(ch != (char) О) System.out.print(ch);
7. Ниже приведен результат выполнения данной программы.
Использование очереди bigQ для сохранения алфавита
Содержимое очереди bigQ: ABCDEFGHIJKLMNOPQRSTUVWXYZ
Использование очереди smallQ для генерации ошибок
Попытка сохранения Z
Попытка сохранения У
Попытка сохранения Х
Попытка сохранения W
Попытка сохранения V - Очередь заполнена
Содержимое очереди smallQ: ZYXW - Очереь пуста
8. Попытайтесь самостоятельно усовершенствовать класс Queue таким образом, чтобы
в очереди можно было хранить другие типы данных, например значения типа
int или douЫe.
Разновидность f or-each цикла f or
При выполнении операций с массивами очень часто возникают ситуации, когда должен
быть обработан каждый элемент массива. Например, для расчета суммы всех значений,
содержащихся в массиве, нужно обратиться ко всем его элементам. То же самое
приходится делать при расчете среднего значения, поиске элемента и решении многих
других задач. В связи с тем что задачи, предполагающие обработку всего массива, встречаются
очень часто, в Java была реализована еще одна разновидность цикла for, рационализирующая
подобные операции с массивами.
Вторая разновидность оператора for реализует цикл типа for-each. В этом цикле
происходит последовательное обращение к каждому элементу совокупности объектов
(например, массива). За последние годы циклы for-each появились практически во
всех языках программирования. Изначально в Java подобный цикл не был предусмотрен
и бьm реализован лишь в пакете JDK 5. Разновидность for-each цикла for называется
также расширенным циклом for. В данной книге употребляются оба эти термина.
Ниже приведена общая форма разновидности for-each цикла for.
fоr(тип итр_пер : коллекция) блок_операторов
Здесь тип обозначает конкретный тип итр_пер - итерационной переменной, в которой
сохраняются поочередно перебираемые элементы набора данных, обозначенного
как коллекция. В данной разновидности цикла for могут быть использованы разные
типы коллекций, но в этой книге рассматриваются только массивы. На каждом шаге
цикла очередной элемент извлекается из коллекции и сохраняется в итерационной переменной.
Выполнение цикла продолжается до тех пор, пока не будут получены все элементы
коллекции. Таким образом, при обработке массива размером N в расширенном
цикле for будут последовательно извлечены элементы с индексами от О до N-1.
178 Java 8: руководство для начинающих. 6-е издание
Итерационная переменная получает значения из коллекции, и поэтому ее тип должен
совпадать (или, по крайней мере, быть совместимым) с типом элементов, которые
содержит коллекция. В частности, при обработке массива тип итерационной переменной
должен совпадать с типом массива.
Для того чтобы стали понятнее причины, побудившие к внедрению разновидности
for-each цикла for в Java, рассмотрим приведенный ниже фрагмент кода, в котором
традиционный цикл for используется для вычисления суммы значений элементов
массива.
int nums[J = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = О;
for (int i=O; i < 10; i++) sum += nums [i];
Для того чтобы вычислить упомянутую выше сумму, придется перебрать все элементы
массива nums от начала до конца. Перебор элементов осуществляется благодаря использованию
переменной цикла i в качестве индекса массива nums. Кроме того, нужно
явно указать начальное значение переменной цикла, шаг ее приращения на каждой итерации
и условие завершения цикла.
При использовании разновидности for-each данного цикла некоторые перечисленные
выше действия выполняются автоматически. В частности, отпадает необходимость
в использовании переменной цикла, задании ее исходного значения и условия завершения
цикла, а также в индексировании массива. Вместо этого массив автоматически обрабатывается
в цикле от начала до конца. Код, позволяющий решить ту же самую задачу
с помощью разновидности for-each цикла for, выглядит следующим образом.
int nums[J = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = О;
for(int х: nums) sum += х;
На каждом шаге этого цикла переменная х автоматически принимает значение, равное
очередному элементу массива nums. Сначала ее значение равно 1, на втором шаге
цикла итерации оно становится равным 2 и т.д. В данном случае не только упрощается
синтаксис, но и исключается ошибка, связанная с превышением границ массива.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Какие типы коллекций, помимо массивов, можно обрабатывать с помощью
разновидности for-each цикла for?
ОТВЕТ. Наиболее важное применение разновидность for-each цикла for находит
в обработке содержимого коллекции, определенной в Co\lections Framework -
библиотеке классов, реализующих различные структуры данных, в том числе
списки, векторы, множества и отображения. Рассмотрение библиотеки
Collections Framework выходит за рамки этой книги, а дополнительные сведения
о ней можно найти в другой книге автора: Java 8. Полное руководство, 9-е
издание (Ид "Вильяме", 2015 r.).
Глава 5. Дополнительные сведения о типах данных и операциях 179
Ниже приведен весь исходный код программы, демонстрирующей решение описанной
выше задачи с помощью разновидности for-each цикла for.
// Использование разновидности for-each цикла for
class ForEach {
puЫic static void main(String args[J) {
int nums[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = О;
// Использовать разновидность for-each цикла for
// для суммирования и отображения значений
for(int х : nums) {
System.out.println("Знaчeниe: " + х);
sum += х;
System.out.println("Cyммa: " + sum);
Результат выполнения данной программы выглядит следующим образом.
Значение: 1
Значение: 2
Значение: 3
Значение: 4
Значение: 5
Значение: 6
Значение: 7
Значение: 8
Значение: 9
Значение: 10
Сумма: 55
Нетрудно заметить, что в данной разновидности цикла for элементы массива автоматически
извлекаются один за другим в порядке возрастания индекса.
Несмотря на то что в расширенном цикле for обрабатываются все элементы массива,
этот цикл можно завершить преждевременно, используя оператор brea k. Так, в
цикле, используемом в следующем примере, вычисляется сумма только пяти элементов
массива nums.
// Суммирование первых 5 элементов массива
for (int х : nums) {
System.out.println("Знaчeниe: " + х);
sum += х;
if(x == 5) break; // прервать цикл по достижении значения 5
Следует, однако, иметь в виду одну важную особенность разновидности for-each
цикла for. Итерационная переменная в этом цикле обеспечивает только чтение элементов
массива, но ее нельзя использовать для записи значения в какой-либо элемент
массива. Иными словами, изменить содержимое массива, присвоив итерационной переменной
новое значение, не удастся. Рассмотрим в качестве примера следующую программу.
180 Java 8: руководство для начинающих, 6-е издание
// Циклы for-each предназначены только для чтения
class NoChange {
puЫic static void main(String args[]) {
int nums[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
for(int х : nums)
System.out.print(x + " ");
х = х * 1 О ; Эта аnерацня не изменяет содержнмое массива nums
System.out.println();
for(int х : nums)
System.out.print(x + " ");
System.out.println();
В первом цикле for значение итерационной переменной увеличивается на 10, но это
не оказывает никакого влияния на содержимое массива nums, что и демонстрирует второй
цикл for. Это же подтверждает и результат выполнения программы.
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
Циклическое обращение к элементам
многомерных массивов
Расширенный цикл for используется также при работе с многомерными массивами.
Выше уже говорилось, что в Java многомерный массив представляет собой массив массивов.
(Например, двумерный массив - это массив, элементами которого являются одномерные
массивы.) Эту особенность важно помнить, организуя циклическое обращение
к многомерным массивам, поскольку на каждом шаге цикла извлекается очередной
массив, а не отдельный элемент. Более того, итерационная переменная в расширенном
цикле for должна иметь тип, совместимый с типом извлекаемого массива. Так, при обращении
к двумерному массиву итерационная переменная должна представлять собой
ссылку на одномерный массив. При использовании разновидности for-each цикла for
для обработки N-мерного массива извлекаемый объект представляет собой (N-J)-мерный
массив. Для того чтобы сказанное стало более понятным, рассмотрим приведенный
ниже пример программы, где для извлечения элементов двумерного массива используются
вложенные циклы for. Обратите внимание на то, каким образом объявляется переменная
х.
// Использование расширенного цикла for
// для обработки двумерного массива
class ForEach2 {
puЫic static void main(String args[])
int sum = О;
int nums[] [] = new int[З] [5];
Глава 5. Дополнительные сведения о типах данных и операциях 181
// Ввести ряд значений в массив nums
for(int i = О; i < 3; i++)
for(int j=O; j < 5; j++)
nums [ i J [ j J ( i + 1) * ( j + 1) ;
// Использовать разновидность for-each цикла for
// для суммирования и отображения значений.
// Обратите внимание на объявление переменной х.
for ( int х [] : nums) { Обратите внимание на способ объявnения переменной х
for(int у : х) {
System.out.println( 11 Знaчeниe: 11 + у);
sum += у;
System.out.println( 11 Cyммa: 11 + sum);
Выполнение этой программы дает следующий результат.
Значение: 1
Значение: 2
Значение: 3
Значение: 4
Значение: 5
Значение: 2
Значение: 4
Значение: 6
Значение: 8
Значение: 10
Значение: 3
Значение: 6
Значение: 9
Значение: 12
Значение: 15
Сумма: 90
Обратите внимание на следующую строку кода:
for(int х[) : nums) {
Заметьте, каким образом объявлена переменная х. Она представляет собой ссылку на
одномерный целочисленный массив. Это очень важно, поскольку на каждом шаге цикла
for из двумерного массива nums извлекается очередной массив, начиная с nums [ О J.
А во внутреннем цикле for перебираются элементы полученного массива и отображаются
их значения.
Использование расширенного цикла f or
Разновидность for-each цикла for обеспечивает лишь последовательный перебор
элементов от начала до конца массива, поэтому может создаться впечатление, будто
такой цикл имеет ограниченное применение. Но это совсем не так. Данный механизм
циклического обращения применяется в самых разных алгоритмах. Один из самых
характерных тому примеров - организация поиска. В приведенном ниже примере
182 Java 8: руководство для начинающих. 6-е издание
программы расширенный цикл for используется для поиска значения в неотсортированном
массиве. Выполнение цикла прерывается, если искомый элемент найден.
// Поиск в массиве с использованием расширенного цикла for
class Search {
puЫic static void main(String args[]) {
int nums[] = { 6, 8, 3, 7, 5, 6, 1, 4 };
int val = 5;
boolean found = false;
// Использовать цикл for-each для поиска значения
// переменной val в массиве nums
for(int х : nums)
if (х == val) {
found = true;
break;
if(found)
System.out.println("Знaчeниe найдено!");
В данном случае применение расширенного цикла for вполне оправданно, поскольку
найти значение в неотсортированном массиве можно лишь, перебрав все его элементы.
(Если бы содержимое массива было предварительно отсортировано, то лучше было
бы применить более эффективный алгоритм поиска, например двоичный поиск. В этом
случае нам пришлось бы использовать другой цикл.) Расширенным циклом for удобно
также пользоваться для расчета среднего значения, нахождения минимального и максимального
элементов множества, выявления дубликатов значений и т.п.
Теперь, когда разновидность for-each цикла for представлена в достаточной степени,
она будет еще не раз использоваться там, где это уместно, в примерах программ,
представленных в остальной части книги.
Символьные строки
В повседневной работе каждый программист обязательно встречается с объектами
типа String. Объект типа String определяет символьную строку и поддерживает операции
над ней. Во многих языках программирования символьная строка (или просто строка)
- это массив символов, но в Java строки - это объекты.
Возможно, вы и не заметили, но класс String фактически уже использовался в примерах
программ, начиная с главы l. При создании строкового литерала на самом деле
генерировался объект типа String. Рассмотрим приведенный ниже оператор:
System.out.println("B Java строки - объекты.");
Наличие в нем строки "В Java строки - объекты. " автоматически приводит к созданию
объекта типа String. Следовательно, класс String незримо присутствовал в
предьщущих примерах программ. В последующих разделах будет показано, как этим
классом пользоваться явным образом. Следует, однако, отметить, что класс String
Глава 5. Дополнительные сведения о типах данных и операциях 183
настолько обширен, что мы сможем рассмотреть лишь незначительную его часть. Большую
часть функциональных возможностей класса String вам предстоит изучить самостоятельно.
Создание строк
Объекты типа String создаются таким же образом, как и объекты других типов. Для
этой цели используется конструктор, как показано в следующем примере:
String str = new String("Пpивeт");
В данном примере создается объект str типа String, содержащий строку "Привет".
Объект типа String можно создать и на основе другого объекта такого же типа, как показано
ниже.
String str = new String("Пpивeт");
String str2 = new String(str);
После выполнения этих строк кода объект str2 будет также содержать строку
"Привет".
Ниже представлен еще один способ создания объекта типа String.
String str = "Строки Java эффективны.";
В данном случае объект str инициализируется последовательностью символов
"Строки Java эффективны.".
Создав объект типа String, можете использовать его везде, где допускается строковый
литерал (последовательность символов, заключенная в кавычки). Например, объект
типа String можно передать в качестве параметра методу println () при его вызове.
// Знакомство с классом String
class StringDemo {
puЫic static void main(String args[JI {
// Различные способы объявления строк
String strl new String("B Java строки - объекты.");
String str2 "Их можно создавать разными способами.";
String strЗ new String(str2);
System.out.println(strl);
System.out.println(str2);
System.out.println(strЗ);
Выполнение этой программы дает следующий результат.
В Java строки - объекты.
Их можно создавать разными способами.
Их можно создавать разными способами.
Операции над символьными строками
Класс String содержит ряд методов, предназначенных для манипулирования строками.
Ниже описаны некоторые из них.
184 Java 8: руководство для начинающих. 6-е издание
boolean equals (str)
int length ( )
char charAt ( index)
int compareTo (String str)
int indexOf(String str)
int lastindexOf (String str)
Возвращает логическое значение true, если текущая строка
содержит ту же последовательность символов, что и параметр
str
Возвращает длину строки
Возвращает символ, занимающий в строке позицию, укозывоемую
параметром index
Возвращает отрицательное значение, если текущая строка
меньше строки str; нуль, если эти строки ровны, и положительное
значение, если текущая строка больше строки s t r
Выполняет в текущей строке поиск подстроки, определяемой
параметром s tr. Возвращает индекс первого вхождения
подстроки s tr или -1, если поиск завершается неудачно
Производит в текущей строке поиск подстроки, определяемой
параметром s tr. Возвращает индекс последнего
вхождения подстроки s t r или -1, если поиск завершается
неудачно
В приведенном ниже примере программы демонстрируется применение перечисленных
выше методов, оперирующих строками.
// Некоторые операции над строками
class StrOps {
puЫic static void main(String args[J)
String strl
"Java - лидер Интернета!";
String str2 = new String(strl);
String strЗ = "Строки Java эффективны.";
int result, idx;
char ch;
System.out.println("Длинa strl: " +
strl.length());
// Отобразить строку strl посимвольно
for(int i=O; i < strl.length(); i++)
System.out.print(strl.charAt(i));
System.out.println();
if(strl.equals(str2))
System.out.println("strl эквивалентна str2");
else
System.out.println("strl не эквивалентна str2");
if(strl.equals(strЗ))
System.out.println("strl эквивалентна strЗ");
else
System.out.println("strl не эквивалентна strЗ");
Глава 5. Дополнительные сведения о типах данных и операциях 185
result = strl.compareTo(strЗ);
if (result == О)
System.out.println("strl и strЗ равны");
else if(result < О)
System.out.println("strl меньше str3");
else
System.out.println("strl больше strЗ");
// Присвоить переменной str2 новую строку
str2 = "One Two Three One";
idx = str2.index0f("One");
System.out.println("Индeкc первого вхождения One: " + idx);
idx = str2.lastindexOf("One");
System.out.println("Индeкc последнего вхождения One: " + idx);
Выполнение этой программы дает следующий результат.
Длина strl: 45
Java - лидер Интернета!
strl эквивалентна str2
strl не эквивалентна strЗ
strl больше strЗ
Индекс первого вхождения One: О
Индекс последнего вхождения One: 14
Конкатенация - это операция, позволяющая объединить две строки. В коде она обозначается
знаком "плюс" (+). Например, в приведенном ниже коде переменная str4
инициализируется строкой "OneTwoThree".
String strl "One";
String str2 "Two";
String strЗ "Three";
String str4 strl + str2 + strЗ;
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Зачем в классе String определен метод equals ()? Не проще ли использовать
вместо него операцию == ?
ОТВЕТ. Метод equals () сравнивает последовательности символов, содержащиеся
в двух объектах типа String, и проверяет, совпадают ли они, тогда как операция
== позволяет лишь определить, указывают ли две ссылки типа String на
один и тот же объект.
186 Java 8: руководство для начинающих. 6-е издание
Массивы строк
Подобно другим типам данных, строки можно объединять в массивы. Ниже приведен
соответствующий демонстрационный пример.
!/ Демонстрация использования массивов строк
class StringArrays {
puЫic static void main (String args []) {
String strs[] = { "Эта", "строка", "является", "тестом." );
System.out.println("Иcxoдный массив: ");
for(String s : strs)
System.out.print(s + " ");
System.out.println("\n");
// Изменить строку
strs[2] "также является";
strs[З] = "тестом!";
System.out.println("Измeнeнный массив: ");
for(String s : strs)
System.out.print(s + " ");
Выполнение этого фрагмента кода дает следующий результат.
Исходный массив:
Эта строка является тестом.
Измененный массив:
Эта строка также является тестом!
Неизменяемость строк
Объекты типа string являются неизменяемыми объектами. Это означает, что состояние
такого объекта не может быть изменено после его создания. Такое ограничение
способствует наиболее эффективной реализации строк. Поэтому на первый взгляд очевидный
недостаток на самом деле превращается в преимущество. Так, если требуется
видоизменение уже существующей строки, дЛя этой цели следует создать новую строку,
содержащую все необходимые изменения. А поскольку неиспользуемые строковые объекты
автоматически удаляются сборщиком мусора, то о дальнейшей судьбе ненужных
строк можно не беспокоиться. Следует, однако, иметь в виду, что содержимое ссылочных
переменных типа String может изменяться, приводя к тому, что переменная будет
ссылаться на другой объект, но содержимое самих объектов типа String остается неизменным
после того, как они бьmи созданы.
Для того чтобы стало понятнее, почему неизменяемость строк не является помехой,
воспользуемся еше одним способом обработки строк класса String. Здесь имеется в
виду метод substring (), возвращающий новую строку, которая содержит часть вызывающей
строки. В итоге создается новый строковый объект, содержащий выбранную
подстроку, тогда как исходная строка не меняется, а следовательно, соблюдается
Глава 5. Дополнительные сведения о типах данных и операциях 187
СПРОСИМ У ЭКСПЕРТ А
ВОПРОС. Как пояснялось выше, содержимое однажды созданного объекта типа
String не может быть изменено после ero создания. С практической точки
зрения это не является серьезным ограничением, но что если мне нужно создать
строку, которая может изменяться?
ОТВЕТ. Можете считать, что вам повезло. В Java предоставляется класс
StringBuffer, который создает символьные строки, способные изменяться.
Так, в дополнение к методу charAt (), возвращающему символ из указанного
места в строке, в классе StringBuffer определен метод setCharAt (), вставляющий
символ в строку. Но для большинства целей вполне подходит класс
String, так что особой необходимости в использовании класса StringBuffer
не возникает.
принцип постоянства строк. Ниже приведен общий синтаксис объявления метода
substring ():
string substring(int начальный_индекс, int конечный_индекс)
rде начальный
_
индекс обозначает начало извлекаемой подстроки, а конечный
_
индекс
- ее окончание. Ниже приведен пример программы, демонстрирующий применение
метода substring () и принцип неизменяемости строк.
// Применение метода substring()
class SubStr {
puЬlic static void rnain(String args[]) {
String orgstr = ".Java - двигатель Интернета.";
// Сформировать подстроку
String substr = orgstr.substring(7, 25);
Systern.out.println("orgstr: " + orgstr);
Systern.out.println("substr: " + substr);
4-----Здесь создается новая строка,
содержащая нужную подстроку
Результат выполнения данной программы выглядит так.
orgstr: Java - двигатель Интернета.
substr: двигатель Интернета
Как видите, исходная строка orgstr остается неизменной, а новая строка substr содержит
сформированную подстроку.
Использование строк для управления
оператором swi tch
Как пояснялось в главе 3, до появления версии JDK 7 для управления оператором
swi tch приходилось использовать только константы целочисленных типов, таких как
188 Java 8: руководство для начинающих. 6-е издание
int или char. Это препятствовало применению оператора switch в тех случаях, когда
выбор варианта определялся содержимым строки. В качестве выхода из этого положения
зачастую приходилось обращаться к многоступенчатой конструкции if-else-if.
И хотя эта конструкция семантически правильна, для организации подобного выбора
более естественным бьmо бы применение оператора swi tch. К счастью, этот недостаток
бьm исправлен. После выпуска комплекта JDK 7 появилась возможность управлять оператором
swi tch с помощью объектов типа String. Во многих ситуациях это способствует
написанию более удобочитаемого и рационально организованного кода.
Ниже приведен пример программы, демонстрирующий управление оператором
switch с помощью объектов типа String.
// Использование строк для управления оператором switch
class StringSwitch {
puЬlic static void main(String args[]) {
String command = "cancel";
switch(command) {
case "connect":
System.out.println("Пoдключeниe");
break;
case "cancel":
System.out.println("Oтмeнa");
break;
case "disconnect":
System.out.println("Oтключeниe");
break;
default:
System.out.println("Heвepнaя команда!");
break;
Как и следовало ожидать, выполнение этой программы приводит к следующему результату:
Отмена
Строка, содержащаяся в переменной command, а в данном примере это строка
"cancel" (отмена), проверяется на совпадение со строковыми константами в ветвях
case оператора switch. Если совпадение обнаружено, как это имеет место во второй
ветви case, выполняется код, связанный с данным вариантом выбора.
Возможность использования строк в операторе swi tch очень удобна и позволяет
сделать код более удобочитаемым. В частности, применение оператора swi tch, управляемого
строками, является более совершенным решением по сравнению с эквивалентной
последовательностью операторов if-else. Но если учитывать накладные расходы,
то использование строк для управления переключателями оказывается менее эффективным
по сравнению с целочисленными значениями. Поэтому использовать строки для
данной цели целесообразно лишь в тех случаях, когда управляющие данные уже являются
строками. Иными словами, пользоваться строками в операторе swi tch без особой
надобности не следует.
Глава 5. Дополнительные сведения о типах данных и операциях 189
Использование аргументов командной строки
Теперь, когда вы уже познакомились с классом String, можно пояснить назначение
параметра args метода main () в исходном коде большинства рассмотренных ранее
примеров программ. Многие программы получают параметры, задаваемые в командной
строке. Это так называемые аргументы командной строки. Они представляют собой данные,
указываемые непосредственно после имени запускаемой на выполнение программы.
Для того чтобы получить доступ к аргументам командной строки из программы на
Java, достаточно обратиться к массиву объектов типа String, который передается методу
main (). Рассмотрим в качестве примера программу, отображающую параметры командной
строки. Ее исходный код приведен ниже.
// Отображение всех данных, указываемых в командной строке
class CLDemo {
puЫic static void main (String args []) {
System.out.println("Пpoгpaммe передано " + args.length +
" аргументов командной строки.");
System.out.println("Cnиcoк аргументов: ");
for(int i=O; i<args.length; i++)
System.out.println("arg[" + i + "]: " + args[i]);
Допустим, программа CLDemo была запущена на выполнение из командной строки
следующим образом:
java CLDemo one two three
Тогда ее выполнение приведет к следующему результату.
Программе передано 3 аргумента командной строки.
Список аргументов:
arg[OJ: one
arg[l]: two
arg[2]: three
Обратите внимание на то, что первый аргумент содержится в строке, хранящейся в
элементе массива с индексом О. Для доступа ко второму аргументу следует воспользоваться
индексом 1 и т.д.
Для того чтобы стало понятнее, как пользоваться аргументами командной строки,
рассмотрим следующую программу. Эта программа принимает один аргумент, определяющий
имя абонента, а затем производит поиск имени в двумерном массиве строк. Если
имя найдено, программа отображает телефонный номер указанного абонента.
// Простейший автоматизированный телефонный справочник
class Phone {
puЬlic static void main(String args[]) {
String numЬers(][J = {
{ "Tom", "555-3322" ) ,
{ "Mary", "555-8976" 1,
{ "Jon", "555-1037" } ,
{ "Rachel", "555-1400" }
} ;
int i;
190 Java 8: руководство для начинающих. 6-е издание
// Для того чтобы воспользоваться программой,
// ей нужно передать один аргумент командной строки
if{args.length != 1)
System.out.println{"Иcпoльзoвaниe: java Phone <имя>");
else {
for{i=O; i<numЬers.length; i++) {
if {numЬers [i] [О] .equals (args [О]))
System.out.println(numЬers[i] [О] + ": " +
numЬers [i] [1]);
break;
if(i == numЬers.length)
System.out.println("Имя не найдено.");
Выполнение этой программы может дать, например, следующий результат.
C>java Phone Mary
Mary: 555-8976
Поразрядные операции
В главе 2 были рассмотрены арифметические и логические операции, а также операции
сравнения (отношения). Эти три вида операций используются наиболее часто, но в
Java предусмотрены также поразрядные (побитовые) операции, существенно расширяющие
возможности языка. В поразрядных операциях в роли операндов могут выступать
только значения типа long, int, short, char и byte; к типам boolean, float, douЫe
поразрядные операции неприменимы. Эти операции носят название поразрядных, поскольку
они в основном используются дпя проверки, установки и сдвига отдельных
разрядов числа. Поразрядные операции играют чрезвычайно важную роль в системных
программах, предназначенных дпя управления обменом данными с устройствам. Перечень
доступных в Java поразрядных операций приведен в табл. 5.1.
Таблица 5.1. Поразрядные операции
Операция
&
>>
>>>
<<
Выполняемые действия
Поразрядное И
Поразрядное ИЛИ
Поразрядное исключающее ИЛИ
Сдвиг вправо
Сдвиг вправо без знака
Сдвиг влево
Дополнение до 1 (унарная операция НЕ)
Глава 5. Дополнительные сведения о типах данных и операциях 191
Поразрядные операции И, ИЛИ, исключающее ИЛИ и НЕ
Поразрядные операции И(&), ИЛИ ( 1 ), исключающее ИЛИ ( л ) и НЕ(􀁟) выполняют
те же функции, что и их логические аналоги, которые были рассмотрены в главе 2. Однако,
в отличие от логических операций, поразрядные операции оперируют с отдельными
двоичными разрядами. Ниже приведены результаты выполнения поразрядных операций,
операндами которых являются единицы и нули.
р q p&q pfq р" q -р
о о о о о 1
1 о о о
о о 1
о о
С точки зрения наиболее распространенного применения поразрядную операцию И
можно рассматривать как способ сброса единиц в отдельных двоичных разрядах (битов).
Это означает, что если какой-либо бит в любом из операндов равен О, то соответствующий
бит результата всегда будет нулевым.
1101 0011
& 1010 1010
1000 0010
Ниже приведен пример программы, демонстрирующий применение операции &.
В этом примере строчные буквы английского алфавита преобразуются в прописные путем
сброса шестого бита в коде символа. Коды строчных букв английского алфавита в
кодировках ASCII и Unicode отличаются от кодов соответствующих прописных букв на
величину 32. Поэтому для преобразования строчных букв в прописные достаточно сбросить
в нуль шестой бит в кодах их символов.
// Преобразование строчных букв английского алфавита в прописные
class UpCase {
puЫic static void main(String args[]) {
char ch;
for(int i=O; i < 10; i++)
ch = ( cha r) ( ' а ' + i ) ;
System.out.print(ch);
// В следующем операторе сбрасывается шестой бит.
// После этого в переменной ch будет храниться код
// символа прописной буквы.
ch = (char) ( (int) ch & 65503);
System.out.print(ch + " ");
192 Java 8: руководство для начинающих. 6-е издание
Результат выполнения данной программы выглядит следующим образом:
аА ьв се dD еЕ fF gG hH iI jJ
Значение 65503, используемое в поразрядной операции И, является десятичным
представлением двоичного числа 1111111111011111. Таким образом, при выполнении
данной операции все биты кода символа в переменой ch, за исключением шестого,
остаются прежними, тогда как шестой бит сбрасывается в нуль.
Поразрядная операция И оказывается удобной и в том случае, если требуется выяснить,
установлен или сброшен отдельный бит числа. Например, в приведенной ниже
строке кода проверяется, установлен ли четвертый бит значения переменной status.
if(status & 8) System.out.println("бит 4 установлен");
Выбор числа 8 обусловлен тем, что в данном примере нас интересует состояние четвертого
бита в переменной status, а в двоичном представлении числа 8 все биты, кроме
четвертого, нулевые. Таким образом, в условном операторе if логическое значение true
будет получено только в том случае, если четвертый бит значения переменной status
также установлен в единицу. Подобный подход можно применить и для преобразования
значения типа byte в двоичный формат.
// Отображение битов, составляющих байт
class ShowBits {
puЫic static void main(String args[])
int t;
byte val;
val = 123;
for(t=l28; t > О; t = t/2) {
if((val & t) != О) System.out.print("l ");
else System.out.print("O ");
Выполнение этой программы дает следующий результат:
О 1 1 1 1 О 1 1
Здесь в цикле for последовательно проверяется каждый бит значения переменной
val. Для выяснения того, установлен ли бит, выполняется операция поразрядного И.
Если бит установлен, отображается цифра 1, иначе - О. В упражнении 5.3 будет показано,
как расширить этот элементарный пример для создания класса, в котором будут
отображаться биты двоичного представления целого числа любого типа.
Поразрядная операция ИЛИ выполняет действия, противоположные поразрядной
операции И, и служит для установки отдельных битов. Любой бит, значение которого
равно единице хотя бы в одном из двух операндов, в результирующем значении будет
установлен в l.
1101 0011
1010 1010
1111 1011
Глава 5. Дополнительные сведения о типах данных и операциях 193
Поразрядную операцию ИЛИ можно использовать для преобразования прописных
букв английского алфавита в строчные. Ниже приведен пример программы, решающей
эту задачу.
// Преобразование прописных букв английского алфавита в строчные
class LowCase {
puЫic static void main(String args[]J {
char ch;
for(int i=O; i < 10; i++)
ch = (char) ( 'А' + i);
System.out.print(ch);
// В результате установки в единицу шестого бита значения
// переменной ch она всегда будет содержать прописную букву
ch = (char) ( (int) ch 1 32);
System.out.print(ch + " ");
Выполнение этой программы дает следующий результат:
Аа ВЬ Се Dd Ее Ff Gg Hh Ii Jj
В приведенном выше примере операндами поразрядной операции ИЛИ являются
код символа и значение 32 (двоичное представление - 0000000000100000). Как видите,
в двоичном представлении значения 32 установлен только шестой бит. Используя это
значение в качестве одного операнда в поразрядной операции ИЛИ с любым другим
значением в качестве другого операнда, получим результат, в котором устанавливается
шестой бит, а состояние всех остальных битов остается без изменения. Таким образом,
любая прописная буква будет преобразована в строчную.
Поразрядная операция исключающего ИЛИ дает результат, в котором отдельный бит
устанавливается в том и только в том случае, если соответствующие биты в двух операндах
имеют разные значения. Ниже приведен пример выполнения поразрядной операции
исключающего ИЛИ.
л
0111 1111
1011 1001
1100 0110
Поразрядная операция исключающего ИЛИ имеет одну интересную особенность,
которая позволяет очень просто шифровать сообщения. Если выполнить данную операцию
сначала над некоторыми значениями х и У, а затем над ее результатом и значением
У, то мы снова получим значение Х. Например, при выполнении приведенной ниже последовательности
операций переменная R2 получит то же значение, что и х. Таким образом,
последовательное применение двух поразрядных операций исключающего ИЛ И
восстанавливает исходное значение:
Rl = Х л У; R2 = Rl л У;
Эту особенность поразрядной операции исключающего ИЛИ можно использовать
для создания простейшей шифрующей программы, в которой некоторое целое число
194 Java 8: руководство для начинающих. 6-е издание
будет выполнять роль ключа, применяемого как при шифровании, так и дешифровании
сообщений. Над всеми символами сообщения и данным числом будет выполняться поразрядная
операция исключающего ИЛИ. Сначала данная операция будет выполняться
при шифровании, формируя зашифрованный текст, а затем - при дешифровании,
которое восстановит исходный текст сообщения. Ниже приведен пример простой программы,
выполняющей шифрование и дешифрование коротких сообщений.
// Использование поразрядной операции исключающего ИЛИ
// для шифрования и дешифрования сообщений
class Encode {
puЫic static void main(String args[])
String msg = "This is а test";
String encmsg "";
String decmsg "";
int key = 88;
System.out.print("Иcxoднoe сообщение: ");
System.out.printlп(msg);
// Зашифровать сообщение
for(int i=O; i < msg.length(); i++)
// Построение зашифрованной строки сообщения
encmsg = encmsg + (char) (msg.char+t(i) л key);
􀀚----Соэдание эаwифрованной строки
System.out.print("Зamифpoвaннoe сообщение: ");
System.out.println(encmsg);
// Дешифровать сообщение
for(int i=O; i < msg.length(); i++)
// Построение дешифрованной строки сообщения
decmsg = decmsg + (char) (encmsg.charAt(i) л key);
·􀀚---Саэданне деwифрованной строки
System.out.print("Дeшифpoвaннoe сообщение: ");
System.out.println(decmsg);
Выполнение этой программы дает следующий результат.
Исходное сообщение: This is а test
Зашифрованное сообщение: Ol+xl+x9x, =+,
Дешифрованное сообщение: This is а test
Как видите, в результате двух поразрядных операций исключающего ИЛИ с одним и
тем же ключом получается дешифрованное сообщение, совпадающее с исходным.
Унарная поразрядная операция НЕ (или дополнения до l) изменяет на обратное состояние
всех битов операнда. Так, если некоторая целочисленная переменная А содержит
значение с двоичным представлением 10010110, то в результате поразрядной операции
-А получится двоичная комбинация 01101001.
Ниже приведен пример программы, демонстрирующий применение поразрядной
операции НЕ. Эта программа отображает число и его дополнение в двоичном представлении.
Глава 5. Дополнительные сведения о типах данных и операциях 195
// Демонстрация поразрядной операции НЕ
class NotDemo {
puЫic static void main(String args[])
byte Ь = -34;
for (int t=l28; t > О; t = t/2) {
if((b & t) != О) System.out.print("l ");
else System.out.print("O ");
System.out.println();
// Обратить состояние всех битов
Ь = (byte) -Ь;
for (int t=l28; t > О; t = t/2) {
if( (Ь & t) != О) System.out.print("l ");
else System.out.print("O ");
Выполнение этой программы дает следующий результат.
1 1 О 1 1 1 1 О
О О 1 О О О О 1
Операции сдвига
В Java предусмотрена возможность сдвига битов, составляющих числовое значение,
влево или вправо на заданное количество позиций. Для этой цели в Java предоставляются
три перечисленных ниже оператора сдвига.
<< Сдвиг влево
>> Сдвиг вправо
>>> Сдвиг вправо без знака
Ниже приведен общий синтаксис для этих операторов.
значение << число битов
значение >> число битов
значение >>> число битов
Здесь число
_
битов - это число позиций двоичных разрядов, на которое сдвигается
указанное значение.
При сдвиге влево освободившиеся младшие разряды заполняются нулями. А при
сдвиге вправо дело обстоит немного сложнее. Как известно, признаком отрицательного
целого числа является единица в старшем разряде, поэтому при сдвиге вправо старший
(знаковый) разряд сохраняется. Если число положительное, то в него записывается
нуль, а если отрицательное - единица.
Помимо сохранения знакового разряда, необходимо помнить еще об одной особенности
операции сдвига вправо. Отрицательные числа в Java (как, впрочем, и в других
196 Java 8: руководство для начинающих. 6-е издание
языках программирования) представляются в виде дополнения до двух. Для того чтобы
преобразовать положительное число в отрицательное, нужно изменить на обратное состояние
всех битов его двоичного представления, а к полученному результату прибавить
единицу. Так, значение -1 имеет байтовое представление 11111111. Сдвинув это значение
вправо на любое число позиций, мы снова получим -1!
Если при сдвиге вправо не требуется сохранять знаковый разряд, то можно воспользоваться
операцией сдвиг вправо без знака(>»). В этом случае освободившиеся старшие
разряды всегда будут заполняться нулями. Именно поэтому такую операцию иногда называют
сдвигом с заполнением нулями. Сдвигом вправо без знака удобно пользоваться для
обработки нечисловых значений, в том числе кодов состояния.
При любом сдвиге те биты, которые выходят за пределы ячейки памяти, теряются.
Циклический сдвиг в Java не поддерживается, и поэтому восстановить утерянные разряды
невозможно.
Ниже приведен пример программы, демонстрирующий эффект применения операций
сдвига влево и вправо. В двоичном представлении исходного целочисленного значения
1 установлен лишь младший разряд. К этому значению восемь раз применяется
операция сдвига влево. После каждого сдвига на экран выводится восемь младших
разрядов числа. Затем единица устанавливается в восьмом двоичном разряде числа, и
выполняются его сдвиги вправо.
// Демонстрация использования операций<< и >>
class ShiftDerno {
puЫic static void rnain(String args[]) {
int val 1;
for(int i = О; i < 8; i++) {
for(int t=l28; t > О; t = t/2)
if((val & t) != 0) Systern.out.print("l ");
else System.out.print("O ");
System.out.println();
val = val << 1; // сдвинуть влево
System.out.println();
val = 128;
for(int i = О; i < 8; i++) {
for(int t=l28; t > О; t = t/2)
if((val & t) != О) Systern.out.print("l ");
else Systern.out.priпt("O ");
System.out.println();
val = val >> 1; // сдвинуть вправо
Результат выполнения данной программы выглядит следующим образом.
О О О О О О О 1
О О О О О О 1 О
О О О О О 1 О О
о о о
о о о
о о 1
о 1 о
1 о о
1 о о
о 1 о
о о 1
о о о
о о о
о о о
о о о
о о о
Глава 5. Дополнительные сведения о типах данных и операциях 197
о 1 о о о
1 о о о о
о о о о о
о о о о о
о о о о о
о о о о о
о о о о о
о о о о о
1 о о о о
о 1 о о о
о о 1 о о
о о о 1 о
о о о о 1
Выполняя сдвиг значений типа byte и short, необходимо соблюдать осторожность,
поскольку исполняющая система Java автоматически преобразует их в тип int и лишь
затем вычисляет выражение с операцией сдвига. Так, если сдвинуть вправо значение
типа byte, оно будет сначала повышено до типа int, а результат сдвига будет также отнесен
к типу int. Обычно такое преобразование не влечет за собой никаких последствий.
Но если попытаться сдвинуть отрицательное значение типа byte или short, то
при повышении до типа int оно будет дополнено знаком, а следовательно, старшие его
разряды будут заполнены единицами. Это вполне оправдано при обычном сдвиге вправо.
Но при выполнении сдвига с заполнением нулями в байтовом представлении числа
неожиданно появятся 24 единицы, которые придется дополнительно сдвинуть, прежде
чем в нем появятся нули.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Известно, что последовательные разряды двоичного представления числа
соответствуют возрастающим степеням двойки. Значит ли это, что операторы
сдвига можно использовать для умножения или деления числа на два?
ОТВЕТ. Совершенно верно. Операторы сдвига часто используются именно для этой
цели. При сдвиге влево число умножается на два, а при сдвиге вправо - делится
на два. Нужно лишь не забывать о том, что при сдвиге могут исчезнуть
установленные биты, что приведет к потере точности.
Поразрядные составные операции присваивания
Для всех двоичных поразрядных операций имеются соответствующие составные операции
присваивания. Например, в двух приведенных ниже строках кода переменной х
присваивается результат выполнения операции "исключающее ИЛИ", операндами которой
служат первоначальное значение переменной х и числовое значение 127.
х = х л 127;
Х л= 127;
198 Java 8: руководство для начинающих. 6-е издание
Упражнение 5.3 Создание класса ShowBi ts
, ................................................... , В данном проекте предстоит создать класс ShowBi ts, кото-
:..􀀓.􀀔􀀕-􀀖􀀗􀀘-􀀙􀀚.?.􀀛􀀜.°..:.?.􀀝􀀞-􀀟---··' рый позволит отображать любое целочисленное значение
в двоичном виде. Этот класс может вам очень пригодиться при разработке некоторых
программ. Так, если требуется отладить код драйвера устройства, возможность контролировать
поток данных в двоичном виде будет весьма кстати. Поэтапное описание процесса
создания программы приведено ниже.
1. Создайте новый файл ShowBi tsDemo. j ava.
2. Создайте класс ShowBits, начав его со следующего кода.
class ShowBits
int numЬits;
ShowBits(int n)
numЬits = n;
Конструктор класса ShowBits позволяет создавать объекты, отображающие заданное
число битов. Например, для создания объекта, отображающего 8 младших
битов некоторого значения, служит следующее выражение:
ShowBits byteval = new ShowBits(B)
Число битов, которые должны отображаться, сохраняется в переменной экземпляра
numЬi ts.
З. Для вывода двоичных значений в классе ShowBi ts определен метод show () , код
которого приведен ниже.
void show(long val)
long mask = l;
// Сдвинуть значение 1 влево на нужную позицию
mask <<= numЬits-1;
int spacer = О;
for(; mask != О; mask »>= 1) {
if((val & mask) != О) System.out.print("l");
else System.out.print("O");
spacer++;
if ( ( spacer % 8) == О) {
System.out.print(" ");
spacer = О;
System.out.println();
Обратите внимание на то, что данному методу передается один параметр типа
long. Но это совсем не означает, что при вызове ему нужно всегда передавать
значение типа long. Правила автоматического преобразования типов в Java допускают
передавать методу show () любое целочисленное значение, а количество
отображаемых битов определяется переменной numЬits. Группы из 8 битов разделяются
в методе show () пробелами. Это упрощает чтение длинных двоичных
комбинаций.
Глава 5. Дополнительные сведения о типах данных и операциях 199
4. Ниже приведен полный исходный код программы из файла ShowBitsDemo. java.
/*
Упражнение 5.3
Создание класса для отображения значений в двоичном виде
*/
class ShowBits
int nurnЬits;
ShowBits (int n)
numЬits = n;
void show(long val)
long mask = l;
!/ Сдвинуть значения 1 влево на нужную позицию
mask <<= nurnЬits-1;
int spacer = О;
for(; mask != О; mask »>= 1) {
if((val & mask) != О) System.out.print("l");
else System.out.print("O");
spacer++;
if((spacer % 8) == О) {
System.out.print(" ");
spacer = О;
System.out.println();
// Демонстрация использования класса ShowBits
class ShowBitsDemo {
puЫic static void main(String args[])
ShowBits Ь = new ShowBits(8);
ShowBits i = new ShowBits(32);
ShowBits li = new ShowBits(64);
System.out.println("l23 в двоичном представлении: ");
b.show(l23);
System.out.println("\n87987 в двоичном представлении: ");
i.show(87987);
System.out.println("\n237658768 в двоичном представлении: ");
li.show(237658768);
!/ Можно также отобразить младшие разряды любого целого числа
System.out.println("\nМлaдшиe 8 битов числа 87987
в двоичном представлении: ");
b.show(87987);
200 Java 8: руководство для начинающих. 6-е издание
5. Результат выполнения программы ShowBi tsDemo выглядит следующим образом.
123 в двоичном представлении:
01111011
87987 в двоичном представлении:
00000000 00000001 01010111 10110011
237658768 в двоичном представлении:
00000000 00000000 00000000 00000000 00001110 00101010 01100010 10010000
Младшие 8 битов числа 87987 в двоичном представлении:
10110011
Оператор?
Оператор ? - один из самых удобных в Java. Он часто используется вместо операторов
if-else следующего вида.
if (условие)
переменная выражение_ 1;
else
переменная = выражение_2;
Здесь значение, присваиваемое переменной, определяется условием оператора if.
Оператор? называется тернарным, поскольку он обрабатывает три операнда. Этот оператор
записывается в следующей общей форме:
выражение_] ? выражение_2 : выражение_З;
где выражение_l должно быть логическим, т.е. возвращать тип boolean, а выражение_
2 и выражение_ 3, разделяемые двоеточием, могут быть любого типа, за исключением
void. Но типы второго и третьего выражений непременно должны совпадать.
Значение выражения ? определяется следующим образом. Сначала вычисляется выражение_
1. Если оно дает логическое значение true, то вычисляется выражение_2,
а его значение становится результирующим для всего выражения ?. Если же выражение_
l дает логическое значение false, то вычисляется выражение_ 3, а его значение
становится результирующим для всего выражения ? . Рассмотрим пример, в котором
сначала вычисляется абсолютное значение переменной val, а затем оно присваивается
переменной absval.
absval = val <О? -val : val; // получить абсолютное значение
// переменной val
В данном примере переменной absval присваивается значение переменной val,
если это значение больше или равно нулю. А если значение переменной val отрицательное,
то переменной absval присваивается значение val со знаком "минус", что в
итоге дает положительную величину. Код, выполняющий ту же самую функцию, но с
помощью логической конструкции if-else, будет выглядеть следующим образом.
if(val < О) absval = -val;
else absval = val;
Глава 5. Дополнительные сведения о типах данных и операциях 201
Рассмотрим еще один пример применения оператора?. В этом примере программы
выполняется деление двух чисел, но не допускается деление на нуль.
// Предотвращение деления на нуль с помощью оператора?
class NoZeroDiv {
puЬlic static void rnain(String args[]} {
int result;
for (int i = -5; i < 6; i++} {
// Деление на нуль предотвращается
result = i != О? 100 / i О;
if(i != О)
Systern.out.println("lOO /" + i + " равно " + result};
Ниже приведен результат выполнения данной программы.
100 / -5 равно -20
100 / -4 равно -25
100 / -3 равно -33
100 / -2 равно -50
100 / -1 равно -100
100 / 1 равно 100
100 / 2 равно 50
100 / 3 равно 33
100 / 4 равно 25
100 / 5 равно 20
Обратите внимание на следующую строку кода:
result = i != О? 100 / i : О;
где переменной result присваивается результат деления числа 100 на значение переменной
i. Но деление выполняется только в том случае, если значение переменной i не
равно нулю. В противном случае переменной resul t присваивается нулевое значение.
Значение, возвращаемое оператором ? , не обязательно присваивать переменной. Его
можно, например, использовать в качестве параметра при вызове метода. Если же все
три выражения оператора ? имеют тип boolean, то сам оператор ? может быть использован
в качестве условия для выполнения цикла или оператора if. Ниже приведена немного
видоизмененная версия предыдущего примера программы. Ее выполнение дает
такой же результат, как и прежде.
// Предотвращение деления на нуль с помощью оператора?
class NoZeroDiv2 {
puЫic static void rnain(String args[]} {
for(int i = -5; i < б; i++)
if(i != О? true : false}
Systern.out.println("lOO /" + i +
" равно " + 100 / i};
202 Java 8: руководство для начинающих. 6-е издание
Обратите внимание на выражение, определяющее условие выполнения оператора if.
Если значение переменной i равно нулю, то оператор ? возвращает логическое значение
false, что предотвращает деление на нуль, и результат не отображается. В противном
случае осуществляется обычное деление.
ct'i/[
Вопросы н упражнения для саме>nроверкн
1. Покажите два способа объявления одномерного массива, состоящего из 12 элементов
типа douЫe.
2. Покажите, как инициализировать одномерный массив целочисленными значениями
ОТ 1 ДО 5.
З. Напишите программу, в которой массив используется для нахождения среднего
арифметического десяти значений типа douЫe. Используйте любые десять чисел.
4. Измените программу, написанную в упражнении 5.1, таким образом, чтобы она
сортировала массив символьных строк. Продемонстрируйте ее работоспособность.
5. В чем состоит разница между методами indexOf () и l as tindexOf () класса
String?
6. Все строки являются объектами типа String. Покажите, как вызываются методы
length () и charAt () для строкового литерала "Мне нравится Java ".
7. Расширьте класс Encode таким образом, чтобы в качестве ключа шифрования использовалась
строка из восьми символов.
8. Можно ли применять поразрядные операции к значениям типа douЫe?
9. Перепишите приведенную ниже последовательность операторов, воспользовавшись
оператором ? .
if(x < О) у= 10;
else у= 20;
10. В приведенном ниже фрагменте кода содержится знак&. Какой операции он соответствует:
поразрядной или логической? Обоснуйте свой ответ.
boolean а, Ь;
// . . .
if (а & Ь) •••
11. Является ли ошибкой превышение верхней границы массива? Является ли ошибкой
использование отрицательных значений для доступа к элементам массива?
12. Как обозначается операция сдвига вправо без знака?
13. Перепишите рассмотренный ранее класс MinMax таким образом, чтобы в нем использовалась
разновидность for-each цикла for.
14. В упражнении 5.1 была реализована пузырьковая сортировка. Можно ли в программе
из этого примера заменить обычный цикл for его разновидностью foreach?
Если нельзя, то почему?
15. Можно ли управлять оператором switch с помощью объектов типа String?
Глава 6
Дополнительные
сведения о методах
и классах
204 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
* Управление доступом к членам классов
,§. Передача объектов при вызове методов
'1i) Возврат объектов из методов
,:i, Перегрузка методов
􀂐 Перегрузка конструкторов
􀂑 Применение рекурсии
,;,. Использование ключевого слова static
;§; Использование внутренних классов
* Использование переменного числа аргументов
в этой главе возобновляется рассмотрение классов и методов. Сначала будет показано,
каким образом контролируется доступ к членам класса, а затем будут рассмотрены
особенности передачи и возврата объектов из методов, детали перегрузки
методов, использования рекурсии и ключевого слова static, Кроме того, будут представлены
вложенные классы и методы с переменным числом аргументов.
Управление доступом к членам класса
Поддержка инкапсуляции в классе дает два главных преимущества. Во-первых, класс
связывает данные с кодом. Это преимущество использовалось в предыдущих примерах
программ, начиная с главы 4. И во-вторых, класс предоставляет средства для управления
доступом к его членам. Именно эта, вторая, особенность и будет рассмотрена ниже.
В языке Java, по сути, имеются два типа членов класса: открытые (puЬlic) и закрытые
(private), хотя в действительности дело обстоит немного сложнее. Доступ к
открытому члену свободно осуществляется из кода, определенного за пределами класса.
Именно этот тип члена класса использовался в рассмотренных до сих пор примерах
программ. Закрытый член класса доступен только методам, определенным в самом
классе. С помощью закрытых членов и организуется управление доступом.
Ограничение доступа к членам класса является основополагающей частью объектно-
ориентированного программирования, поскольку оно позволяет исключить неверное
использование объекта. Разрешая доступ к закрытым данным только с помощью
строго определенного ряда методов, можно предупредить присваивание неверных значений
этим данным, выполняя, например, проверку диапазона представления чисел.
Для закрытого члена класса нельзя задать значение непосредственно в коде за пределами
класса. Но в то же время можно полностью управлять тем, как и когда данные используются
в объекте. Следовательно, правильно реализованный класс образует некий
"черный ящик", которым можно пользоваться, но внутренний механизм его действия
закрыт для вмешательства извне.
Глава 6. Дополнительные сведения о методах и классах 205
В рассмотренных ранее примерах программ не уделялось никакого внимания управлению
доступом, поскольку в Java члены класса по умолчанию доступны из остальных
частей программы. (Иными словами, они открыты для доступа по умолчанию.)
Это удобно для создания небольших программ (в том числе и тех, что служат примерами
в данной книге), но недопустимо в большинстве реальных условий эксплуатации
программного обеспечения. Ниже будет показано, какими языковыми средствами Java
можно пользоваться для управления доступом.
Модификаторы доступа в Java
Управление доступом к членам класса в Java осуrnествляется с помощью трех модификаторов
доступа (называемых также спецификаторами): puЫic, private и protected.
Если модификатор не указан, то принимается тип доступа по умолчанию. В этой главе
будут рассмотрены модификаторы puЫic и private. Модификатор protected непосредственно
связан с наследованием, и поэтому он будет обсуждаться в главе 8.
Когда член класса обозначается модификатором puЫic, он становится доступным
из любого друтого кода в программе, включая и методы, определенные в других классах.
Когда же член класса обозначается модификатором private, он может быть доступен
только другим членам этого класса. Следовательно, методы из других классов не имеют
доступа к закрытому члену класса.
Если все классы в программе относятся к одному пакету, то отсутствие модификатора
доступа равнозначно указанию модификатора puЫic по умолчанию. Пакет представляет
собой группу классов, предназначенных как для организации классов, так и
для управления доступом. Рассмотрение пакетов откладывается до главы 8, а для примеров
программ, представленных в этой и предыдущих главах, тип доступа по умолчанию
не отличается от puЫic.
Модификатор доступа указывается перед остальной частью описания типа отдельного
члена класса. Это означает, что именно с него должен начинаться оператор объявления
члена класса. Соответствующие примеры приведены ниже.
puЫic String errMsg;
private accountBalance bal;
private boolean isError(byte status) { // ...
Для того чтобы стал понятнее эффект от применения модификаторов доступа puЫic
и private, рассмотрим следующий пример программы.
// Сравнение видов доступа puЫic и private
class MyClass {
private int alpha; // закрытый доступ
puЫic int beta; // открытый доступ
int gamma; // .тип доступа по умолчанию (по сути, puЫic)
/* Методы доступа к переменной alpha. Члены класса могут
обращаться к закрытым членам того же класса.
*/
void setAlpha(int а) {
alpha = а;
206 Java 8: руководство для начинающих. 6-е издание
int getAlpha () {
return alpha;
class AccessDemo (
puЫic static void main(String args[]) (
MyClass оЬ = new MyClass();
/* Доступ к переменной alpha возможен только с помощью
специально предназначенных для этой цели методов. */
ob.setAlpha(-99);
System.out.println("ob.alpha: " + ob.getAlpha());
// Обратиться к переменной alpha так, как показано ниже, нельзя
// ob.alpha = 10; // Ошибка: alpha - закрытая переменная! .--- Оwибко,
поскоn􀂓ку alpha -
// Следующие обращения вполне допустимы, так как
// переменные beta и gamma являются открытыми
оЬ. Ье ta = 8 8; .. Возможно, поскоn􀂔ку это открытые переменные
ob.gamma = 99;
закрыто• переменна•!
Нетрудно заметить, что в классе MyClass переменная alpha определена как pri vate,
переменная beta - как puЫic, а перед переменной gamma модификатор доступа отсутствует,
т.е. в данном примере она ведет себя как открытый член класса, которому по
умолчанию присваивается модификатор доступа puЫic. Переменная alpha закрыта, и
поэтому к ней невозможно обратиться за пределами ее класса. Следовательно, в классе
AccessDemo нельзя пользоваться переменной alpha непосредственно. Доступ к ней организуется
с помощью открытых методов доступа setAlpha () и getAlpha (), определенных
в одном с ней классе. Если удалить комментарии в начале следующей строки кода,
то скомпилировать программу не удастся:
// ob.alpha = 10; // Ошибка: alpha - закрытая переменная!
Компилятор выдаст сообщение об ошибке, связанной с нарушением правил доступа.
Несмотря на то что переменная alpha недоступна для кода за пределами класса
MyClass, пользоваться ею можно с помощью открытых методов доступа setAlpha () и
getAlpha () .
Таким образом, закрытые переменные могут быть свободно использованы другими
членами класса, но недоступны за пределами этого класса.
Рассмотрим практическое применение средств управления доступом на примере
приведенной ниже программы. Во время ее выполнения предотвращается возникновение
ошибок выхода за границы массива. Это достигается следующим образом. Массив
объявляется как закрытый член класса, а доступ к нему осуществляется с помощью
специально предназначенных для этой цели методов. Эти методы отслеживают попытки
обращения к элементам, не входящим в массив, и вместо аварийной остановки программы
возвращают сообщение об ошибке. Массив определяется в классе FailSoftArray,
код которого приведен ниже.
Глава 6. Дополнительные сведения о методах и классах 207
/* В этом классе реализуется "отказоустойчивый" массив,
предотвращающий ошибки времени выполнения
*/
class FailSoftArray {
private int а[];
private int errval;
// ссылка на массив
// значение, возвращаемое в случае
// возникновения ошибки при выполнении
/ / метода get ()
puЫic int length; // открытая переменная length
/* Конструктору данного класса передается размер массива и
значение, которое должен возвращать метод get() при
возникновении ошибки. */
puЫic FailSoftArray(int size, int errv) {
а = new int[size];
errval errv;
length = size;
// Возвратить значение элемента массива
puЫic int get(int index) {
if(indexOK(index)) return a[index];
return errval;
с заданным индексом
--------- Отсnеживоние попытки вwходо
зо rроницы моссиео
// Установить значение элемента с заданным индексом.
// Если возникнет ошибка, возвратить логическое значение false.
puЫic boolean put(int index, int val) {
if(indexOK(index)) {
a[index] = val;
return true;
return false;
// Вернуть логическое значение true, если индекс
// не выходит за границы массива
private boolean indexOK(int index) {
if(index >= О & index < length) return true;
return false;
// Демонстрация работы с "отказоустойчивым" массивом
class FSDemo {
puЫic static void main(String args[J) {
FailSoftArray fs = new FailSoftArray(5, -1);
int х;
// Демонстрация корректной обработки ошибок
System.out.println("Oбpaбoткa ошибок без вывода отчета.");
208 Java 8: руководство для начинающих. 6-е издание
for(int i=O; i < (fs.length * 2); i++)
f 5 • pU t ( i t i * 1 о) ; 4------------- Дnя об ращения к эnементам массива
доnжны нсnоnьэоаатьс• методы доступа forх (=i nfts .i g=Oe;t (ii );< ...(.....-f s-.l-en-gt-h -* -2)-; -i+-+)- { --------􀁮\-
if(x != -1) System.out.print(x + " ");
System.out.println("");
/Sy/s tОбeрmа.бoоuтtа.тprь inоtшиlnб(к"и \nOбpaбoткa ошибок с выводом отчета."); fori(fi(!ntf si.=pOu;t (ii, < i*(flsO.)l)e ngth * 2); i++) System.out.println(""вИнндeе кcдо"пу с+ тiи м+о го диапазона");
forх (i= nfts i.=gOe;t (ii );< (fs.length * 2); i++) { ielfs(xe != -1) System.out.print(x + " "); System.out.println(""вИнндeе кcдо"пу с+ тiи м+о го диапазона");
Выполнение этой программы дает следующий результат. ОО бр1а0 бо20т ка30 ош40и бок без вывода отчета.
ИОнбдраебксот ка ошибок с выводом отчета. 5 Индекс вне допустимого диапазона 6 вне допустимого диапазона
Индекс 7 вне допустимого диапазона Индекс 8 вне допустимого диапазона Индекс 9 вне допустимого диапазона
о Инд10е кс20 30 40 Индекс 5 вне допустимого диапазона 6 вне допустимого диапазона Индекс 7 вне допустимого диапазона Индекс 8 вне допустимого диапазона Индекс 9 вне допустимого диапазона
Рассмотрим подробнее этот пример. В классе FailSoftArray определены три закрытых
члена. Первым из них является переменная а, в которой содержится ссылка на
массив, предназначенный для хранения данных. Вторым членом является переменная errval, в которой хранится значение, возвращаемое вызывающей части программы в
том случае, если вызов метода get ( ) приводит к ошибке. И третьим членом является
метод indexOk () , в котором определяется, находится ли индекс в допустимых пределах.
Эти три члена могут быть использованы только друтими членами класса FailSoftArray.
Остальные члены данного класса объявлены открытыми и могут быть вызваны из любой
части программы, где используется класс FailSoftArray.
Глава 6. Дополнительные сведения о методах и классах 209
При создании объекта типа FailSoftArray следует указать размер массива и значение,
которое должно возвращаться в случае неудачного вызова get () . Это значение не
может совпадать ни с одним значением, хранящимся в массиве. После создания объекта
непосредственный доступ извне его к массиву, на который указывает ссылка, хранящаяся
в переменной а, а также к переменной errval, невозможен, что исключает их
некорректное использование. В частности, пользователь не сможет непосредственно
обратиться к массиву по ссылке в переменной а, задав индекс элемента, выходящий за
границы допустимого диапазона. Доступ к указанным элементам возможен только с помощью
методов get () и put ().
Метод indexOK () объявлен как закрытый главным образом для того, чтобы проиллюстрировать
управление доступом. Но даже если бы он был открытым, то это не создавало
бы никакого риска, поскольку он не видоизменяет объект. Однако, поскольку этот
метод используется только членами класса FailSoftArray, он объявлен закрытым.
Обратите внимание на то, что переменная экземпляра length открыта. Это согласуется
с правилами реализации массивов в Java. Для того чтобы получить данные о длине
массива типа FailSoftArray, достаточно прочитать значение переменной экземпляра
length.
Для сохранения данных в массиве типа FailSoftArray по указанному индексу вызывается
метод put (), тогда как метод get () извлекает содержимое элемента этого
массива по заданному индексу. Если индекс оказывается вне границ массива, то метод
put () возвращает логическое значение false, а метод get () - значение errval.
Ради простоты в большинстве примеров программ, представленных в этой книге,
на члены класса будет в основном распространяться тип доступа по умолчанию. Но не
следует забывать, что в реальных объектно-ориентированных программах очень важно
ограничивать доступ к членам класса, и в особенности к переменным. Как будет показано
в главе 7, при использовании наследования роль средств управления доступом еще
более возрастает.
Упражнение 6.1 ·················· Усовершенствование класса Queue Модификатор доступа private можно использовать для ycoвepшeн\
.. Queue.-.javaj ствования класса Queue, разработанного в упражнении 5.2 из главы 5.
В текущей версии этого класса используется тип доступа по умолчанию, который, по
существу, делает все члены этого класса открытыми. Это означает, что другие классы
могут непосредственно обращаться к элементам базового массива - и даже вне очереди.
А поскольку назначение класса, реализующего очередь, состоит в том, чтобы обеспечить
принцип доступа "первым пришел - первым обслужен", то возможность произвольного
обращения к элементам массива явно неуместна. В частности, это давало бы возможность
недобросовестным программистам изменять индексы в переменных putloc
и getloc, искажая тем самым организацию очереди. Подобные недостатки нетрудно
устранить с помощью модификатора доступа private. Поэтапное описание процесса
создания программы приведено ниже.
1. Создайте новый файл Queue. j ava.
2. Снабдите массив q, а также переменные putloc и getloc в классе Queue модификаторами
доступа private. В результате код этого класса должен выглядеть так,
как показано ниже.
// Усовершенствованный класс очереди, предназначенной
// для хранения символьных значений
21 О Java 8: руководство для начинающих. 6-е издание
class Queue {
// Эти члены класса теперь являются закрытыми
private char q[]; // массив для хранения элементов очереди
private int putloc, getloc; // индексы для вставки и
Queue (int size) {
q = new char[size+l];
putloc = getloc = О;
// Поместить символ в очередь
void put(char ch) {
if(putloc==q.length-1)
// извлечения элементов очереди
// выделить память для очереди
System.out.println(" - Очередь заполнена.");
return;
putloc++;
q[putloc] ch;
// Извлечь символ из очереди
char get () {
if (getloc == putloc) {
System.out.println(" - Очередь пуста.");
return (char) О;
getloc++;
return q[getloc];
3. Изменение типа доступа к массиву q и переменным putloc и getloc с выбираемого
по умолчанию на закрытый (private) никак не скажется на работе программ,
в которых класс Queue используется корректно. В частности, этот класс
будет по-прежнему нормально взаимодействовать с классом QDemo из упражнения
5.2. В то же время некорректное обращение к классу Queue станет невозможным.
Например, следующий фрагмент кода не будет скомпилирован.
Queue test = new Queue(lO);
test.q[O] = 99; // Ошибка!
test.putloc = -100; // Не пройдет!
4. Теперь, когда массив q и переменные putloc и getloc объявлены как private,
класс Queue строго следует принципу "первым пришел - первым обслужен", по
которому действует очередь.
Глава 6. Дополнительные сведения о методах и классах 211
Передача объектов методам
Вплоть до этого момента в приводимых примерах программ при передаче параметров
методам использовались лишь простые типы. Но параметрами могут быть и объекты.
Например, в приведенной ниже программе определен класс Block, предназначенный
дЛЯ хранения размеров параллелепипеда в трех измерениях.
// Методам можно передавать объекты
class Block {
int а, Ь, с;
int volume;
Block(int i, int j, int k) {
а = i;
ь j;
с k;
volume а * Ь * с;
// Вернуть логическое значение true, если
// параметр оЬ определяет тот же параллелепипед Испоnьзоаан необъектноrотнпа
boolean sameBlock (Block оЬ) { 4---------- в качестве параметра
if((ob.a == а) & (оЬ.Ь == Ь) & (оЬ.с == с)) return true;
else return false;
// Вернуть логическое значение true, если
// параметр оЬ определяет параллелепипед того же объема
boolean sameVolume(Block оЬ) {
if(ob.volume == volume) return true;
else return false;
class PassOb {
puЫic static
Block оЫ
Block оЬ2
Block оЬЗ
void main(String args[J)
new Block(lO, 2, 5);
new Block(lO, 2, 5);
new Block(4, 5, 5);
System.out.println("oЫ имеет те же размеры, что и оЬ2: " +
оЫ. sameBlock ( оЬ2) ) ; 4---------- Передача объекта
System.out.println("oЫ имеет те же размеры, что и оЬЗ: " + 1 oЫ.sameBlock(ob3));􀁧41----------􀁨System.
out.println("oЫ имеет тот же объем, что и оЬЗ: " +
oЫ.sameVolume(obЗ));------------􀁩
Выполнение этой программы дает следующий результат.
оЫ имеет те же размеры, что и оЬ2: true
оЫ имеет те же размеры, что и оЬЗ: false
оЫ имеет тот же объем, что и оЬЗ: true
212 Java 8: руководство для начинающих. 6-е издание
В методах sameBlock () и sameVolume () объект Block, переданный им в качестве параметра,
сравнивается с текущим объектом. Метод sameBlock () возвращает логическое
значение true только в том случае, если все три размера обоих параллелепипедов совпадают.
В методе же sameVolume () сравниваются лишь объемы двух параллелепипедов.
Но в обоих случаях параметр оЬ имеет тип Block. Несмотря на то что Block - это
класс, параметры данного типа используются точно так же, как и параметры встроенных
в Java типов данных.
Способы передачи аргументов методу
Как показывает приведенный выше пример, передача объекта методу не вызывает затруднений.
Однако имеются некоторые нюансы, не нашедшие отражения в данном примере.
В некоторых случаях последствия передачи объекта по ссьmке будут отличаться от
тех результатов, к которым приводит передача значения обычного типа. Для выяснения
причин этих отличий рассмотрим два возможных способа передачи аргументов методу.
Первый из них - это вызов по значению. В этом случае в формальный параметр метода
копируется значение аргумента. Следовательно, изменения, вносимые в параметр
метода, никоим образом не сказываются на состоянии аргумента, используемого при
вызове. Вторым способом передачи аргумента является вызов по ссылке. В этом случае
параметру метода передается не значение аргумента, а ссылка на него. В методе эта
ссьmка используется для доступа к конкретному аргументу, указанному при вызове. Это
означает, что изменения, вносимые в параметр, будут оказывать влияние на аргумент,
используемый при вызове метода. Как будет далее показано, несмотря на то что в Java
передача аргументов осуществляется в соответствии с механизмом вызова по значению,
результирующий эффект оказывается разным для простых и ссьmочных типов.
Если методу передается простой тип, например int или douЫe, то он передается
по значению. При этом создается копия аргумента, а то, что происходит с параметром,
принимающим аргумент, не распространяется за пределы метода. Рассмотрим в качестве
примера следующую программу.
// Простые тиnы данных передаются методам по значению
class Test {
/* Этот метод не может изменить значения аргументов,
передаваемых ему при вызове. */
void noChange(int i, int j) {
i i + j;
j = -j;
class CallByValue {
puЫic static void main(String args[]) {
Test оЬ = new Test();
int а = 15, Ь = 20;
System.out.println("a и Ь перед вызовом: " +
а + " " + Ь);
ob.noChange(a, Ь);
System.out.println("a и Ь после вызова: " +
Глава 6. Дополнительные сведения о методах и классах 213
а + 1
1
11 + Ь);
Ниже приведен результат выполнения данной программы.
а и Ь перед call: 15 20
а и Ь после call: 15 20
Как видите, действия, выполняемые в теле метода noChange () , никоим образом не
влияют на значения переменных а и Ь в вызывающем методе.
Если же методу передается объект, то ситуация коренным образом меняется, поскольку
объекты передаются неявно, по ссылке. Вспомните, что создание переменной, для которой
в качестве типа указан класс, означает создание ссылки на объект этого класса,
и именно эта ссылка передается по значению в формальный параметр при передаче ее
методу. Отсюда следует, что и передаваемый аргумент, и параметр метода, как содержащие
одну и ту же ссьmку, будут ссьmаться на один и тот же объект. Таким образом, любые
изменения объекта в методе будут вызывать соответствующие изменения в объекте, используемом
в качестве аргумента. Для примера рассмотрим следующую программу.
// Объекты передаются методам no ссылке
class Test {
int а, Ь;
Test (int i, int j) {
а i;
ь = j;
/* Передача объекта методу. Теперь переменные оЬ.а и оЬ.Ь
объекта, используемого при вызове, также будут изменяться. */
void change(Test оЬ) {
оЬ.а оЬ.а + оЬ.Ь;
оЬ.Ь = -оЬ.Ь;
class CallByRef {
puЬlic static void rnain(String args[]) {
Test оЬ = new Test(l5, 20);
Systern.out.println( 11 ob.a и оЬ.Ь перед вызовом: 11 +
оЬ.а + 11 " + оЬ.Ь);
оЬ. change ( оЬ) ;
Systern.out.println("ob.a и оЬ.Ь после вызова: 11 +
оЬ.а + " " + оЬ.Ь);
Выполнение этой программы дает следующий результат.
оЬ.а и оЬ.Ь перед вызовом: 15 20
оЬ.а и оЬ.Ь после вызова: 35 -20
Как видите, в данном случае действия в методе change () оказывают влияние на
объект, используемый в качестве аргумента этого метода.
214 Java 8: руководство для начинающих. 6-е издание
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Существует ли способ передачи простого типа по ссылке?
ОТВЕТ. Явным образом этого сделать нельзя. Но в Java определен ряд классов, служащих
оболочкой для простых типов. Это классы DouЬle, Float, Byte, Short,
Integer, Long и Character. Они не только позволяют передавать простые
типы по ссылке, но и содержат ряд методов для манипулирования их значениями.
Например, в классах-оболочках числовых типов содержатся методы,
преобразующие двоичные значения в символьную строку, а также методы, выполняющие
обратное преобразование.
Возврат объектов
Метод может возвращать данные любого типа, включая и типы классов. Например,
объект приведенного ниже класса ErrorMsg можно использовать для вывода сообщений
об ошибке. В этом классе имеется метод getErrorMsg (), который возвращает объект
типа String, описывающий конкретную ошибку. Объект типа String создается на основании
кода ошибки, переданного методу.
// Возврат объекта типа Striпg
class ErrorMsg {
String msgs[] = {
"Ошибка вывода",
"Ошибка ввода",
"Отсутствует место на диске",
"Выход индекса за границы диапазона"
};
String getErrorMsg(int i) (
if(i >=О & i < msgs.length)
return msgs[i);
else
----- Возврат объекта типа String
return "Несуществующий код ошибки";
class ErrMsg {
puЫic static void main(String args[])
ErrorMsg err = new ErrorMsg();
System.out.println(err.getErrorMsg(2));
System.out.println(err.getErrorMsg(l9));
Выполнение этой программы дает следующий результат.
Отсутствует место на диске
Несуществующий код ошибки
Глава 6. Дополнительные сведения о методах и классах 215
Разумеется, возвращать можно и объекты создаваемых классов. Например, приведенный
ниже фрагмент кода представляет собой переработанную версию предыдущей
программы, в которой создаются два класса формирования ошибок Err и Errorlnfo.
В классе Err, помимо кода ошибки, инкапсулируется строка описания ошибки.
А в классе Errorlnfo содержится метод getErrorinfo (), возвращающий объект типа
Err.
// Возврат объекта, определяемого разработчиком программы
class Err {
String msg; // сообщение об ошибке
int severity; // уровень серьезности ошибки
Err(String m, int s) {
msg = m;
severity = s;
class Errorinfo {
String msgs[] =
"Ошибка вывода",
"Ошибка ввода",
"Отсутствует место на диске",
"Выход индекса за границы диапазона"
);
int howbad[] = { 3, 3, 2, 4 };
Err getErrorinfo ( int i) { Возврат объекта типа Err
if(i >=О & i < msgs.length)
return new Err(msgs[i], howbad[i]);
else
return new Еrr("Несуществующий код ошибки", О);
class Errinfo {
puЫic static void main(String args[])
Errorlnfo err = new Errorinfo();
Err е;
е = err.getErrorinfo(2);
System.out.println(e.msg + " уровень: " + e.severity);
е = err.getErrorlnfo(l9);
System.out.println(e.msg + " уровень: " + e.severity);
Результат выполнения данной версии программы выглядит следующим образом.
Отсутствует место на диске уровень: 2
Несуществующий код ошибки уровень: О
216 Java 8: руководство для начинающих. 6-е издание
При каждом вызове метода getErrorinfo () создается новый объект типа Err, и
ссылка на него возвращается вызывающему методу. Затем этот объект используется методом
main () для отображения уровня серьезности ошибки и текстового сообщения.
Объект, возвращенный методом, существует до тех пор, пока на него имеется хотя бы
одна ссьmка. Если ссьmки на объект отсутствуют, он уничтожается сборщиком мусора.
Поэтому при выполнении программы не может возникнуть ситуация, когда объект удаляется
лишь потому, что метод, в котором он бьm создан, завершился.
Перегрузка методов
В этом разделе речь пойдет об одном из самых интересных языковых средств Java -
перегрузке методов. Несколько методов одноrо класса могут иметь одно и то же имя,
отличаясь лишь набором параметров. Перегрузка методов является одним из способов
реализации принципа полиморфизма в Java.
Для того чтобы перегрузить метод, достаточно объявить его новый вариант, отличающийся
от уже существующих, а все остальное сделает компилятор. Нужно лишь соблюсти
одно условие: тип и/или число параметров в каждом из перегружаемых методов
должны быть разными. Одноrо лишь различия в типах возвращаемых значений для этой
цели недостаточно. (Информации о возвращаемом типе не всегда будет хватать Java для
принятия решения о том, какой именно метод должен использоваться.) Конечно, перегружаемые
методы могут иметь разные возвращаемые типы, но при вызове метода
выполняется лишь тот его вариант, в котором параметры соответствуют передаваемым
аргументам.
Ниже приведен простой пример программы, демонстрирующий перегрузку методов.
// Перегрузка методов
class Overload {
void ovlDemo() { ----- Первая версия
System.out.println("Бeз параметров");
// Перегрузка метода ovlDemo для одного параметра типа int
void ovlDemo(int а) { Втораяверсня
System. out. println ( "Один параметр: " + а);
// Перегрузка метода ovlDemo для двух параметров типа int
int ovlDemo(int а, int Ь) { Третьяверсня
System.out.println("Двa параметра: " + а + " " + Ь);
return а + Ь;
// Перегрузка метода ovlDemo для двух параметров типа douЫe
douЫe ovlDemo(douЫe а, douЫe Ь) { Четвертаяверсн•
System.out.println("Двa параметра типа douЫe: " +
а + " "+ Ь);
return а + Ь;
class OverloadDemo {
puЫic static void main (String args []) {
Глава 6. Дополнительные сведения о методах и классах 217
Overload оЬ = new Overload();
int resI;
douЫe resD;
// Поочередно вызвать все версии метода ovlDemo()
ob.ovlDemo();
System.out.println();
ob.ov1Demo(2);
System.out.println();
resI = ob.ov1Demo(4, 6);
System.out.println("Peзyльтaт вызова ob.ov1Demo(4, 6): " +
resI);
System.out.println();
resD = ob.ovlDemo(l.l, 2.32);
System.out.println("Peзyльтaт вызова ob.ovlDemo(l.l, 2.32): " +
resD);
Выполнение этой программы дает следующий результат.
Без параметров
Один параметр: 2
Два параметра: 4 6
Результат вызова ob.ov1Demo(4, 6): 10
Два параметра типа douЫe: 1.1 2.32
Результат вызова ob.ovlDemo(l.l, 2.32): 3.42
Как видите, метод ovlDemo () перегружается четырежды. В первой его версии параметры
не предусмотрены, во второй - определен один целочисленный параметр, в
третьей - два целочисленных параметра, в четвертой - два параметра типа douЬle.
Обратите внимание на то, что первые два варианта метода ovlDemo () имеют тип void, а
два другие возвращают значение. Как пояснялось ранее, тип возвращаемого значения не
учитывается при перегрузке методов. Следовательно, попытка определить два варианта
метода ovlDemo () так, как показано ниже, приводит к ошибке.
// Возможен лишь один вариант метода ovlDemo(int)
void ovlDemo ( int а) { Возвращаемое значение непьэ• нспопьэовать
System.out.println("One parameter: " + а); дпароэпнченнапереrружоемwхметодов
/* Ошибка! Невозможно существование двух версий
перегруженного метода ovlDemo(int), отличающихся
лишь типом возвращаемого значения.
*/
int ovlDemo(int а) {
System.out.println("Oдин параметр: " + а);
return а * а;
218 Java 8: руководство для начинающих. 6-е издание
Как поясняется в комментариях к приведенному выше фрагменту кода, отличия возвращаемых
типов недостаточно для перегрузки методов.
Как следует из главы 2, в Java применяется автоматическое приведение типов. Это
приведение распространяется и на типы параметров перегружаемых методов. В качестве
примера рассмотрим следующий фрагмент кода.
/* Автоматическое преобразование типов может влиять
на выбор перегружаемого метода.
*/
class Overload2 {
void f (int х) {
System.out.println("Bнyтpи f(int): " + х);
void f(douЫe х) {
System.out.println("Bнyтpи f(douЫe): " + х);
class TypeConv {
puЬlic static void main(String args[])
Overload2 оЬ = new Overload2();
int i = 10;
douЫe d = 10.1;
byte Ь = 99;
short s 10;
float f = 11.SF;
оЬ. f (i); // вызов
оЬ. f (d); // ВЫЗОВ
ob.f (Ь); // вызов
метода ob.f(int)
метода ob.f(douЫe)
метода ob.f(int) с преобразованием типов
оЬ. f (s); // ВЫЗОВ метода ob.f(int) с преобразованием типов
оЬ. f (f); // вызов метода ob.f(douЬle) с преобразованием типов
Выполнение этого фрагмента кода дает следующий результат.
Внутри f (int): 10
Внутри f(douЫe): 10.1
Внутри f (int): 99
Внутри f (int): 10
Внутри f(douЫe): 11.5
В данном примере определены только два варианта метода f () : один принимает
параметр типа int, а второй - параметр типа douЫe. Но передать методу f () можно
также значение типа byte, short и float. Значения типа byte и short исполняющая
система Java автоматически преобразует в тип int. В результате будет вызван вариант
метода f (int). А если параметр имеет значение типа float, то оно преобразуется в тип
douЫe, и далее вызывается вариант метода f (douЫe).
Важно понимать, что автоматическое преобразование типов выполняется лишь в отсутствие
прямого соответствия типов параметра и аргумента. В качестве примера ниже
Глава 6. Дополнительные сведения о методах и классах 219
представлена другая версия предыдущей программы, в которой добавлен вариант метода
f ( ) с параметром типа byte.
// Добавление версии метода f(byte)
class Overload2 {
void f(byte х) { Это1ерси•nрини моетnорометртиnоЬуtе
System.out.println("Bнyтpи f(byte): " + х);
void f (int х) {
System.out.println("Bнyтpи f(int): " + х);
void f(douЫe х) {
System.out.println("Bнyтpи f(douЫe): " + х);
class TypeConv {
puЬlic static void main(String args[])
Overload2 оЬ = new Overload2();
int i = 10;
douЫe d = 10.1;
byte Ь = 99;
short s 10;
float f = 11.5F;
оЬ. f (i); // вызов
ob.f(d); // ВЫЗОВ
оЬ. f (Ь); // вызов
оЬ. f (s); // вызов
оЬ. f (f); // ВЫЗОВ
метода
метода
метода
метода
метода
ob.f(int)
ob.f(douЫe)
оЬ. f (byte) без преобразования типов
ob.f(int) с преобразованием типов
ob.f(douЬle) с преобразованием типов
Выполнение этой версии программы дает следующий результат.
Внутри f(int): 10
Внутри f(douЫe): 10.1
Внутри f(byte): 99
Внутри f(int): 10
Внутри f(douЬle): 11.5
Поскольку в данной программе предусмотрена версия метода f () , которая принимает
параметр типа byte, то при вызове этого метода с аргументом типа byte выполняется
вызов f (byte), и автоматического преобразования типа byte в тип int не происходит.
Перегрузка методов поддерживает полиморфизм, поскольку она является одним из
способов реализации парадигмы "один интерфейс - множество методов". Для того
чтобы стало понятнее, как и для чего это делается, необходимо принять во внимание
следующее соображение: в языках программирования, не поддерживающих перегрузку
220 Java 8: руководство для начинающих. 6-е издание
методов, каждый метод должен иметь уникальное имя. Но в ряде случаев требуется выполнять
одну и ту же последовательность операций над разными типами данных. В качестве
примера рассмотрим функцию, определяющую абсолютное значение. В языках,
не поддерживающих перегрузку методов, приходится создавать несколько вариантов
данной функции с именами, отличающимися хотя бы одним символом. Например,
в языке С функция abs () возвращает абсолютное значение числа типа int, функция
labs () - абсолютное значение числа типа long, а функция fabs () - абсолютное значение
числа с плавающей точкой. Объясняется это тем, что в С не поддерживается перегрузка,
и поэтому каждая из функций должна обладать своим собственным именем,
несмотря на то что все они выполняют одинаковые действия. Это приводит к неоправданному
усложнению процесса написания программ. Разработчику приходится не
только представлять себе действия, выполняемые функциями, но и помнить все три их
имени. Такая ситуация не возникает в Java, потому что все методы, вычисляющие абсолютное
значение, имеют одно и то же имя. В стандартной библиотеке Java для вычисления
абсолютного значения предусмотрен метод abs () . Его перегрузка осуществляется в
классе Math для обработки значений всех числовых типов. Решение о том, какой именно
вариант метода abs () должен быть вызван, исполняющая система Java принимает,
исходя из типа аргумента.
Главная ценность перегрузки заключается в том, что она обеспечивает доступ к группе
родственных методов по общему имени. Следовательно, имя abs обозначает общее
выполняемое действие, а компилятор сам выбирает конкретный вариант метода по обстоятельствам.
Благодаря полиморфизму несколько имен сводятся к одному. Несмотря
на всю простоту рассматриваемого здесь примера, продемонстрированный в нем принцип
полиморфизма можно расширить, чтобы выяснить, каким образом перегрузка помогает
справляться с более сложными ситуациями в программировании.
Когда метод перегружается, каждая его версия может выполнять какое угодно действие.
Для установления взаимосвязи перегружаемых методов не существует какого-то
твердого правила, но с точки зрения правильного стиля программирования перегрузка
методов подразумевает подобную взаимосвязь. Следовательно, использовать одно и то
же имя для несвязанных друг с другом методов не следует, хотя это и возможно. Например,
имя sqr можно было бы выбрать для методов, возвращающих квадрат и квадратный
корень числа с плавающей точкой. Но ведь это принципиально разные операции.
Такое применение перегрузки методов противоречит ее первоначальному назначению.
На практике перегружать следует только тесно связанные операции.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Программисты на Java употребляют термин сигнатура. Что это такое?
ОТВЕТ. Применительно к Java сигнатура обозначает имя метода и список его параметров.
При перегрузке методов действует следующее правило: никакие два метода
из одного класса не могут иметь одинаковые сигнатуры. Следует, однако,
иметь в виду, что сигнатура не включает в себя тип возвращаемого значения,
поскольку он не используется в Java при принятии решения о перегрузке.
Глава 6. Дополнительные сведения о методах и классах 221
Перегрузка конструкторов
Как и методы, конструкторы также могут перегружаться. Это дает возможность конструировать
объекты самыми разными способами. В качестве примера рассмотрим следующую
программу.
!! Демонстрация перегрузки конструкторов
class MyClass {
int х;
MyClass {) Конструнроаонне объектов раэнымн способами
System.out.println("Bнyтpи MyClass() .");
х = О;
MyClass (int i) {
System.out.println("Bнyтpи MyClass(int) .");
х = i;
MyClass(douЫe d) {
System.out.println("Bнyтpи MyClass(douЫe) .");
х = (int) d;
MyClass (int i, int j) {
System.out.println("Bнyтpи MyClass(int, int) .");
х = i * j;
class OverloadConsDemo {
puЫic static void main(String args[])
MyClass tl new MyClass();
MyClass t2 new MyClass(88);
MyClass tЗ new MyClass(17.23);
MyClass t4 new MyClass(2, 4);
System.out.println("tl.x: " + tl.x);
System.out.println("t2.x: " + t2.x);
System.out.println("tЗ.x: " + tЗ.х);
System.out.println("t4.x: " + t4.x);
В результате выполнения этой программы получается следующий результат.
Внутри MyClass().
Внутри MyClass(int).
Внутри MyClass(douЬle).
Внутри MyClass(int, int).
tl.x: О
t2 .х: 88
tЗ.х: 17
t4. х: 8
222 Java 8: руководство для начинающих. 6-е издание
В данном примере конструктор MyClass () перегружается четырежды. Во всех перегруженных
версиях этого конструктора объект типа MyClass строится по-разному.
Конкретный вариант конструктора выбирается на основании параметров, которые указываются
при выполнении оператора new. Перегружая конструктор класса, вы предоставляете
пользователю созданного вами класса свободу в выборе способа конструирования
объекта.
Перегрузка конструкторов чаще всего используется для того, чтобы дать возможность
инициализировать один объект на основании другого объекта. Рассмотрим в качестве
примера следующую программу, в которой класс Surnmation используется для вычисления
суммы двух целочисленных значений.
// Инициализация одного объекта посредством другого
class Sumrnation {
int sum;
// Создать объект на основе целочисленного значения
Sumrnation(int nurn) {
sum = О;
for{int i=l; i <= num; i++)
sum += i;
// Создать один объект на основе другого
Sumrnation(Sumrnation оЬ) {
sum = ob.sum;
class SurnDemo {
puЫic static void main{String args[])
Sumrnation sl new Sumrnation{5);
Sumrnation s2 = new Sumrnation{sl);
System.out.println{ 11 sl.sum: 11 + sl.surn);
System.out.println("s2.surn: 11 + s2.surn);
Выполнение этой программы дает следующий результат.
sl.sum: 15
s2.sum: 15
Как следует из приведенного выше примера, использование одного объекта при инициализации
другого нередко оказывается вполне оправданным. В данном случае при
конструировании объекта s2 нет необходимости вычислять сумму. Даже если подобная
инициализация не повышает быстродействие программы, зачастую удобно иметь конструктор,
создающий копию объекта.
Глава 6. Дополнительные сведения о методах и классах 223
Упражнение 6.2 Переrрузка конструктора класса Queue
j_._._6_·_0_·.􀀖-----􀀗---·_;_·_2_· ·__ _-__j_·_􀀙_-_._v_ .. 􀀚_-_·_·_j_ В этом проекте предстоит усовершенствовать класс Queue, добавив в
него два дополнительных конструктора. В первом из них новая очередь
будет конструироваться на основе уже существующей, а во втором - начальные
значения элементов очереди будут присваиваться при ее конструировании. Как станет
ясно в дальнейшем, добавление этих конструкторов сделает класс Queue более удобным
для использования. Поэтапное описание процесса создания соответствующей программы
приведено ниже.
1. Создайте новый файл QDemo2. java и скопируйте в него код класса Queue, созданный
в упражнении 6.1.
2. Прежде всего добавьте в этот класс приведенный ниже конструктор, который будет
создавать одну очередь на основе другой.
// Конструктор, создающий один объект типа Queue
// на основе другого
Queue(Queue оЬ) {
putloc = ob.putloc;
getloc = ob.getloc;
q = new char[ob.q.length];
// Копировать элементы очереди
for(int i=getloc+l; i <= putloc; i++)
q [ i] = оЬ. q [ i] ;
Внимательно проанализируем работу этого конструктора. Сначала переменные
putloc и getloc инициализируются значениями, содержащимися в объекте оЬ,
который передается в качестве параметра. Затем организуется новый массив для
хранения элементов очереди, которые далее копируются из объекта оЬ в этот массив.
Вновь созданная копия очереди будет идентична оригиналу, хотя они и являются
совершенно отдельными объектами.
3. Добавьте в данный класс конструктор, инициализирующий очередь данными из
символьного массива, как показано ниже.
// Конструирование и инициализация объекта типа Queue
Queue (char а [)) {
putloc = О;
getloc = О;
q = new char[a.length+l);
for(int i = О; i < a.length; i++) put(a[i));
В этом конструкторе создается достаточно большая очередь для хранения символов
из массива а. В силу особенностей алгоритма, реализующего очередь, длина
очереди должна быть на один элемент больше, чем длина исходного массива.
4. Ниже приведен завершенный код видоизмененного класса Queue, а также код
класса QDemo2, демонстрирующего организацию очереди для хранения символов
и обращение с ней.
// Класс, реализующий очередь для хранения символов
class Queue {
224 Java 8: руководство для начинающих, 6-е издание
private char q[]; // массив для хранения элементов очереди
private int putloc, getloc; // индексы для вставки и
// извлечения элементов
// очереди
// Сконструировать пустую очередь заданного размера
Queue ( int size) {
q = new char[size+l]; // выделить память для очереди
putloc = getloc = О;
// Сконструировать очередь на основе имеющегося объекта Queue
Queue(Queue оЬ) {
putloc = ob.putloc;
getloc = ob.getloc;
q = new char[ob.q.length];
// Копировать элементы в очередь
for(int i=getloc+l; i <= putloc; i++)
q[i] = ob.q[i);
// Сконструировать очередь на основе массива исходных значений
Queue(char а[]) {
putloc = О;
getloc = О;
q = new char[a.length+l];
for(int i = О; i < a.length; i++) put(a[i]);
// Поместить символ в очередь
void put(char ch) {
if(putloc==q.length-1)
System.out.println(" - Очередь заполнена");
return;
putloc++;
q [putloc] ch;
// Извлечь символ из очереди
char get () {
if(getloc == putloc) {
System.out.println(" - Очередь пуста");
return (char) О;
getloc++;
return q[getloc];
Глава 6. Дополнительные сведения о методах и классах 225
// Продемонстрировать использование класса Queue
class QDerno2 {
puЫic static void rnain(String args[J) {
// Создать пустую очередь для хранения 10 элементов
Queue ql = new Queue(lO);
char narne[J = {'Т', 'о', 'rn'};
// Создать очередь на основе массива
Queue q2 = new Queue(narne);
char ch;
int i;
// Поместить ряд символов в очередь ql
for(i=O; i < 10; i++)
ql.put ( (char) ( 'А' + i));
// Создать одну очередь на основе другой
Queue qЗ = new Queue(ql);
// Показать очереди
Systern.out.print("Coдepжимoe ql: ");
for (i=O; i < 10; i++) {
ch = ql.get();
Systern.out.print(ch);
Systern.out.println("\n");
Systern.out.print("Coдepжимoe q2: ");
for (i=O; i < З; i++) {
ch = q2.get();
Systern.out.print(ch);
Systern.out.println("\n");
Systern.out.print("Coдepжимoe qЗ: ");
for (i=O; i < 10; i++) {
ch = qЗ.get();
Systern.out.print(ch);
Результат выполнения данной программы выглядит следующим образом.
Содержимое ql: AВCDEFGHIJ
Содержимое q2: Тот
Содержимое qЗ: AВCDEFGHIJ
226 Java 8: руководство для начинающих. 6-е издание
Рекурсия
В Java допускается, чтобы метод вызывал самого себя. Этот процесс называется рекурсией,
а метод, вызывающий самого себя, - рекурсивным. Вообще говоря, рекурсия
предстамяет собой процесс, в ходе которого некая сущность определяет себя же. В этом
отношении она чем-то напоминает циклическое определение. Рекурсивный метод отличается
в основном тем, что он содержит оператор, в котором этот метод вызывает самого
себя. Рекурсия ямяется эффективным механизмом упрамения программой.
Классическим примером рекурсии служит вычисление факториала числа. Факториал
числа N - это произведение всех целых чисел от 1 до N. Например, факториал числа З
равен lx2x3, или 6. В приведенном ниже примере программы демонстрируется рекурсивный
способ вычисления факториала числа. Для сравнения в эту программу включен
также нерекурсивный вариант вычисления факториала.
// Простой пример рекурсии
class Factorial {
// Рекурсивный метод
int factR(int n) {
int result;
if(n== l) return 1;
result = factR(n-1) * n;
return result; t.... _ __ - Рекурсианый вызов метода factR ()
// Вариант программы, вычисляющий факториал итеративным способом
int factI (int n) {
int t, result;
result = 1;
for(t= l; t <= n; t++) result *= t;
return result;
class Recursion
puЫic static void main(String args[])
Factorial f = new Factorial();
System.out.println("Bычиcлeниe рекурсивным методом");
System.out.println("Фaктopиaл З равен " + f.factR(З));
System.out.println("Фaктopиaл 4 равен " + f.factR(4));
System.out.println("Фaктopиaл 5 равен " + f.factR(S));
System.out.println();
System.out.println("Bычиcлeниe итеративным методом");
System.out.println("Фaктopиaл З равен " + f.factI(З));
System.out.println("Фaктopиaл 4 равен " + f.factI(4));
System.out.println("Фaктopиaл 5 равен " + f.factI(S));
Глава 6. Дополнительные сведения о методах и классах 227
Ниже приведен результат выполнения данной программы.
Вычисление рекурсивным методом
Факториал З равен 6
Факториал 4 равен 24
Факториал 5 равен 120
Вычисление итеративным методом
Факториал З равен 6
Факториал 4 равен 24
Факториал 5 равен 120
Действия нерекурсивноrо метода factI () не требуют особых пояснений. В нем используется
цикл, в котором числа, начиная с 1, последовательно умножаются друг на
друга, постепенно образуя произведение, дающее факториал.
Рекурсивный метод factR () действует в соответствии с несколько более сложной
схемой. Когда метод factR () вызывается с аргументом, равным 1, он возвращает 1, в
противном случае - произведение, определяемое из выражения factR (n-1) *n. Для вычисления
этого выражения вызывается метод factR () с аргументом n-1. Этот процесс
повторяется до тех пор, пока значение переменной n не окажется равным 1, после чего
из предыдущих вызовов данного метода начнут возвращаться полученные значения. Например,
при вычислении факториала 2 первый вызов метода factR () повлечет за собой
второй вызов того же самого метода, но с аргументом 1. В результате метод возвратит
значение 1, которое затем умножается на 2 (т.е. исходное значение переменной n). В результате
всех этих вычислений будет получен факториал, равный 2. По желанию в тело
метода factR () можно ввести операторы println () , чтобы сообщать, на каком именно
уровне осуществляется очередной вызов, а также отображать промежуточные результаты
вычислений.
Когда метод вызывает самого себя, в системном стеке распределяется память для новых
локальных переменных и параметров, и код метода выполняется с этими новыми
переменными и параметрами с самого начала. При рекурсивном вызове метода не создается
его новая копия, но лишь используются его новые аргументы. А при возврате из
каждого рекурсивного вызова старые локальные переменные и параметры извлекаются
из стека, и выполнение возобновляется с точки вызова в методе. Рекурсивные методы
можно сравнить по принципу действия с постепенно сжимающейся и затем распрямляющейся
пружиной.
Рекурсивные варианты многих процедур могут выполняться немного медленнее,
чем их итерационные эквиваленты, из-за дополнительных затрат системных ресурсов
на неоднократные вызовы метода. Если же таких вызовов окажется слишком много, то
в конечном итоге может быть переполнен системный стек. А поскольку параметры и
локальные переменные рекурсивного метода хранятся в системном стеке и при каждом
новом вызове этого метода создается их новая копия, то в какой-то момент стек может
оказаться исчерпанным. Если возникнет подобная ситуация, исполняющая система Java
сгенерирует исключение. Но в большинстве случаев об этом не стоит особенно беспокоиться.
Как правило, переполнение системного стека происходит тогда, когда рекурсивный
метод выходит из под контроля.
Главное преимущество рекурсии заключается в том, что она позволяет реализовать
некоторые алгоритмы яснее и проще, чем итерационным способом. Например, алгоритм
быстрой сортировки довольно трудно реализовать итерационным способом.
А некоторые задачи, например, искусственного интеллекта, очевидно, требуют именно
228 Java 8: руководство для начинающих. 6-е издание
рекурсивного решения. При написании рекурсивных методов следует непременно указать
в соответствующем месте условный оператор, например if, чтобы организовать
возврат из метода без рекурсии. В противном случае возврат из вызванного однажды рекурсивного
метода может вообще не произойти. Подобного рода ошибка весьма характерна
для реализации рекурсии в практике программирования. Поэтому рекомендуется
пользоваться операторами, содержащими вызовы метода println (), чтобы следить за
происходяшим в рекурсивном методе и прервать его выполнение, если в нем обнаружится
ошибка.
Применение ключевого слова static
Иногда требуется определить такой член класса, который будет использоваться независимо
от каких бы то ни было объектов этого класса. Как правило, доступ к члену
класса организуется посредством объекта этого класса, но в то же время можно создать
член класса для самостоятельного применения без ссылки на конкретный объект. Для
того чтобы создать такой член класса, достаточно указать в самом начале его объявления
ключевое слово static. Если член класса объявляется как static, он становится доступным
до создания каких-либо объектов своего класса и без ссьmки на какой-либо объект.
С помощью ключевого слова static можно объявлять как переменные, так и методы.
Такие члены и методы называются статическими. Наиболее характерным примером
члена типа static служит метод main (), который объявляется таковым потому, что он
должен вызываться виртуальной машиной Java в самом начале выполняемой программы.
Для того чтобы воспользоваться членом типа static за пределами класса, достаточно
дополнить имя данного члена именем класса, используя точечную нотацию. Но создавать
объект для этого не нужно. В действительности член типа static оказывается
доступным не по ссылке на объект, а по имени своего класса. Так, если требуется присвоить
значение 10 переменной count типа static, являющейся членом класса Timer,
то для этой цели можно воспользоваться следующей строкой кода:
Timer.count = 10;
Эта форма записи подобна той, что используется для доступа к обычным переменным
экземпляра посредством объекта, но в ней указывается имя класса, а не объекта.
Аналогичным образом вызываются методы типа static.
Переменные, объявляемые как static, по существу являются глобальными. В силу
этого при создании объектов данного класса копии статических переменных в них не
создаются. Вместо этого все экземпляры класса совместно пользуются одной и той же
статической переменной. Ниже приведен пример программы, демонстрирующий различия
между статическими и обычными переменными экземпляра.
// Применение статической переменной
class StaticDemo {
int х; // обычная переменная экземпляра
static int у; // статическая переменная Все объекты нсnоnьэуютоднунтуже
копню статической переменной
// Возвратить сумму значений переменной экземпляра х и
// статической переменной у
int sum() {
return х + у;
class SDemo {
Глава 6. Дополнительные сведения о методах и классах 229
puЫic static void main(String args[])
StaticDemo оЫ new StaticDemo();
StaticDemo оЬ2 = new StaticDemo();
// У каждого объекта имеется своя копия
// переменной экземпляра
оЫ.х = 10;
оЬ2.х = 20;
System.out.println("Paзyмeeтcя, оЫ.х и оЬ2.х " +
"независимы");
System.out.println("oЫ.x: " + оЫ.х +
"\nob2.x: " + оЬ2.х);
System.out.println();
// Все объекты совместно используют одну общую
// копию статической переменной
System.out.println("Cтaтичecкaя переменная у - общая");
StaticDemo.y = 19;
System.out.println("Пpиcвoить StaticDemo.y значение 19");
System.out.println("oЫ.sum(): " + oЫ.sum());
System.out.println("ob2.sum(): " + ob2.sum());
System.out.println();
StaticDemo.y = 100;
System.out.println("Измeнить значение StaticDemo.y на 100");
System.out.println("oЫ.sum(): " + oЫ.sum());
System.out.println("ob2.sum(): " + ob2.sum());
System.out.println(); }
Выполнение этой программы дает следующий результат.
Разумеется, оЫ.х and оЬ2.х независимы
оЫ.х: 10
оЬ2.х: 20
Статическая переменная у - общая
Присвоить StaticDemo.y значение 19
oЫ.sum(): 29
ob2.sum(): 39
Изменить значение StaticDemo.y на 100
oЫ.sum(): 110
ob2.sum(): 120
Нетрудно заметить, что статическая переменная у используется как объектом оЫ,
так и объектом оЬ2. Изменения в ней оказывают влияние на весь класс, а не только на
ero экземпляр.
230 Java 8: руководство для начинающих. 6-е издание
Метод типа static отличается от обычного метода тем, что его можно вызывать по
имени его класса, не создавая экземпляр объекта этого класса. Пример такого вызова
уже приводился ранее. Это был метод sqrt () типа static, относящийся к классу Math
из стандартной библиотеки классов Java. Ниже приведен пример программы, в которой
объявляется статическая переменная и создается метод типа static.
// Применение статического метода
class StaticMeth {
static int val = 1024; // статическая переменная
// Статический метод
static int va1Div2()
return val/2;
class SDemo2 {
puЫic static void main (String args []) {
System.out.println("Знaчeниe val: " + StaticMeth.val);
System.out.println("StaticMeth.valDiv2(): " +
StaticMeth.valDiv2());
StaticMeth.val = 4;
System.out.println("Знaчeниe val: " + StaticMeth.val);
System.out.println("StaticMeth.valDiv2(): " +
StaticMeth.valDiv2());
Выполнение этой программы дает следующий результат.
Значение val: 1024
StaticMeth.valDiv2(): 512
Значение val: 4
StaticMeth.valDiv2(): 2
На применение методов типа static накладывается ряд следующих ограничений:
$ в методе типа static допускается непосредственный вызов только других методов
типа static;
􀁣 для метода типа static непосредственно доступными оказываются только друтие
данные типа static, определенные в его классе;
,, в методе типа static должна отсутствовать ссылка this.
В приведенном ниже классе код статического метода valDi vDenorn () создан некорректно.
class StaticError {
int denom = 3; // обычная переменная экземпляра
static int val = 1024; // статическая переменная
Глава 6. Дополнительные сведения о методах и классах 231
/* Ошибка! К нестатическим переменным нельзя обращаться
из статического метода. */
static int valDivDenom() {
return val/denom; // не пройдет компиляцию!
В данном примере denom является обычной переменной экземпляра, к которой нельзя
обращаться из статического метода.
Статические блоки
Иногда для подготовки к созданию объектов в классе должны быть выполнены некоторые
инициализирующие действия. В частности, может возникнуть потребность установить
соединение с удаленным сетевым узлом или задать значения некоторых статических
переменных перед тем, как воспользоваться статическими методами класса. Для
решения подобных задач в Java предусмотрены статические блоки. Статический блок
выполняется при первой загрузке класса, еще до того, как класс будет использован для
каких-нибудь других целей. Ниже приведен пример применения статического блока.
// Применение статического блока
class StaticBlock (
static douЫe root0f2;
static douЬle root0f3;
s ta tic Этот бпок выnоnняется nрн эоrруэке кпоссо.
System.out.println("Bнyтpи статического блока");
rootOf2 Math.sqrt(2.0);
root0f3 = Math.sqrt(3.0);
StaticBlock(String msg) (
System.out.println{msg);
class SDemo3 {
puЬlic static void main(String args[]) (
StaticBlock оЬ = new StaticBlock("Bнyтpи конструктора");
System.out.println("Kopeнь квадратный из 2 равен " +
StaticBlock.rootOf2);
System.out.println("Kopeнь квадратный из 3 равен " +
StaticBlock.rootOf3);
Результат выполнения данной программы выглядит следующим образом.
Внутри статического блока
Внутри конструктора
Корень квадратный из 2 равен 1.4142135623730951
Корень квадратный из 3 равен 1.7320508075688772
232 Java 8: руководство для начинающих. 6-е издание
Как видите, статический блок выполняется еще до того, как будет создан какой-либо
объект.
Упражнение 6.3 Быстрая сортировка
: ................................. : В главе 5 был рассмотрен простой способ так называемой пузырько- 1..?,5.􀀎-􀀏􀀐􀀑-:.􀀒.г.􀀓􀀔j вой сортировки. Там же было вкратце упомянуто о том, что существуют
и более совершенные способы сортировки. В этом проекте предстоит реализовать
один из самых эффективных способов: быструю сортировку. Аrlгоритм быстрой сортировки
бьш разработан Чарльзом Хоаром и назван его именем. На сегодняшний день это
самый лучший универсальный алгоритм сортировки. Он не был продемонстрирован в
главе 5 лишь потому, что реализовать быструю сортировку лучше всего с помощью рекурсии.
В данном проекте будет создана программа для сортировки символьного массива,
но демонстрируемый подход может быть применен к сортировке любых объектов.
Быстрая сортировка опирается на принцип разделения. Сначала из массива выбирается
один опорный элемент (так называемый компаранд), и массив делится на две части.
Элементы, "меньшие" опорного, помещаются в одну часть массива, а "большие
или равные опорному", - в другую часть. Затем процесс рекурсивно повторяется для
каждой оставшейся части до тех пор, пока массив не окажется отсортированным. Допустим,
имеется массив, содержащий последовательность символов fedacb, а в качестве
опорного выбран символ d. На первом проходе массив будет частично упорядочен следующим
образом:
Исходные данные fedacb
Проход 1 bcadef
Далее этот процесс повторяется для каждой части: Ьса и def. Как видите, процесс
рекурсивен по своей сути, и действительно, наиболее эффективной реализацией быстрой
сортировки является рекурсивная сортировка.
Опорный элемент можно выбрать двумя способами: случайным образом или путем
вычисления среднего значения части элементов массива. Эффективность сортировки
будет оптимальной в том случае, когда опорный элемент выбирается как раз посредине
диапазона значений элементов, содержащихся в массиве, но зачастую выбрать такое
значение непросто. Если же опорный элемент выбирается случайным образом, то вполне
возможно, что он окажется на краю диапазона. Но и в этом случае алгоритм быстрой сортировки
будет действовать корректно. В том варианте быстрой сортировки, который реализуется
в данном проекте, в качестве опорного выбирается элемент, находящийся посередине
массива. Поэтапное описание процесса создания программы приведено ниже.
1. Создайте новый файл QSDemo. j ava.
2. Прежде всего создайте класс Quicksort, код которого приведен ниже.
// Упражнение 6.3. Простая версия класса Quicksort,
// реализующего быструю сортировку
class Quicksort {
// Организовать вызов фактического метода быстрой сортировки
static void qsort(char items[])
qs(items, О, items.length-1);
Глава 6. Дополнительные сведения о методах и классах 233
// Рекурсивная версия метода быстрой сортировки символов
private static void qs(char iterns[], int left, int right)
{
int i, j;
char х, у;
i left; j = right;
х = iterns[(left+right)/2];
do {
while((iterns[i] < х) && (i < right)) i++;
while((x <iterns[j]) && (j >left)) j--;
if (i <= j)
у = iterns [i];
iterns[i] = iterns[j];
iterns [j] = у;
i++; j--;
while ( i <= j) ;
if(left < j) qs(iterns, left, j);
if(i < right) qs(iterns, i, right);
С целью упрощения интерфейса в классе Quicksort предоставляется метод
qsort (), из которого вызывается метод qs (), фактически выполняющий сортировку.
Такой подход позволяет выполнять сортировку, передавая методу лишь имя
массива и не осуществляя первоначальное разделение. А поскольку метод qs ()
используется только в классе, он определяется как private.
3. Для того чтобы запустить сортировку, достаточно вызвать метод Quicksort.
qsort (). Этот метод определен как static, и поэтому для его вызова достаточно
указать имя класса, а создавать объект не обязательно. По завершении работы
этого метода массив будет отсортирован. Данная версия программы работает
только с символьными массивами, но вы можете адаптировать ее для сортировки
массивов любого типа.
4. Ниже приведен полный исходный код программы, демонстрирующей применение
класса Quicksort.
!/ Упражнение 6.3. Простая версия класса Quicksort,
// реализующего быструю сортировку
class Quicksort {
!/ Организовать вызов фактического метода быстрой сортировки
static void qsort(char iterns[])
qs(iterns, О, iterns.length-1);
// Рекурсивная версия метода быстрой сортировки символов
private static void qs(char iterns[], int left, int right)
{
int i, j;
char х, у;
234 Java 8: руководство для начинающих. 6-е издание
i left; j = right;
х = items[(left+right)/2);
do {
while((items[i] < х) && (i < right)) i++;
while((x < items[j]) && (j > left)) j--;
if(i <= j)
у = items[i];
items[i] = items[j);
items[j] = у;
i++; j--;
while(i <= j);
if(left < j) qs(items, left, j);
if(i < right) qs(items, i, right);
class QSDemo {
puЬlic static void main(String args[]) {
char а [ J = { 'd', 'х', 'а', 'r', 'р', 'j', 'i' ) ;
int i;
System.out.print("Иcxoдный массив: ");
for(i=O; i < a.length; i++)
System.out.print(a[i));
System.out.println();
// Отсортировать массив
Quicksort.qsort(a);
System.out.print("Oтcopтиpoвaнный массив: ");
for(i=O; i < a.length; i++)
System.out.print(a[i]);
Вложенные и внутренние классы
В Java определены вложенные классы. Вложенным называется такой класс, который
объявляется в другом классе. Вложенные классы не относятся к базовым языковым
средствам Java. Они даже не поддерживались до появления версии Java l. l, хотя с тех
пор часто применяются в реальных программах, и поэтому о них нужно знать.
Вложенный класс не может существовать независимо от класса, в который он вложен.
Следовательно, область действия вложенного класса ограничена его внешним
классом. Если вложенный класс объявлен в пределах области действия внешнего класса,
то он становится членом последнего. Имеется также возможность объявить вложенный
класс, который станет локальным в пределах блока.
Глава 6. Дополнительные сведения о методах и классах 235
Существуют два типа вложенных классов. Одни вложенные классы объявляются с
помощью модификатора доступа static, а другие - без него. В этой книге будет рассматриваться
только нестатический вариант вложенных классов. Классы такого типа
называются внутренними. Внутренний класс имеет доступ ко всем переменным и методам
внешнего класса, в который он вложен, и может обращаться к ним непосредственно,
как и все остальные нестатические члены внешнего класса.
Иногда внутренний класс используется для предоставления ряда услуг внешнему классу,
в котором он содержится. Ниже приведен пример применения внутреннего класса
для вычисления различных значений, которые используются включающим его классом.
// Применение внутреннего класса
class Outer {
int nums[);
Outer(int n[J)
nums = n;
void Analyze ()
Inner inOb = new Inner();
System.out.println("Минимyм: " + inOb.min());
System.out.println("Maкcимyм: " + inOb.max(});
System.out.println("Cpeднee: " + inOb.avg());
// Внутренний класс
class Inner {
int min () {
----- Внутренний кпасс
int m = nums[OJ;
for(int i=l; i < nums.length; i++)
if(nums[i] < m) m = nums[i];
return m;
int max ()
int m = nums[O];
for(int i=l; i < nums.length; i++)
if(nums[i] > m) m = nums[i];
return m;
int avg ()
int а = О;
for(int i=O; i < nums.length; i++)
а += nums[i];
return а/ nums.length;
236 Java 8: руководство для начинающих. 6-е издание
class NestedClassDemo {
puЫic static void main(String args[]) {
int х [] = { 3, 2, 1, 5, 6, 9, 7, 8 } ;
Outer outOb = new Outer(x);
outOb.Analyze();
Результат выполнения данной программы выглядит следующим образом.
Минимум: 1
Максимум: 9
Среднее: 5
В данном примере внутренний класс Inner обрабатывает массив nums, являющийся
членом класса Outer. Вложенный класс имеет доступ к членам объемлющего класса,
и поэтому он может непосредственно обращаться к массиву nums. А вот обратное не
справедливо. Так, например, метод analyze () не может непосредственно вызвать метод
min () , не создав объект типа Inner.
Как уже упоминалось, класс можно вложить в области действия блока. В итоге получается
локальный класс, недоступный за пределами блока. В следующем примере программы
мы преобразуем класс ShowBi ts, созданный в упражнении 5.3, таким образом,
чтобы он стал локальным.
// Применение класса ShowBits в качестве локального
class LocalClassDemo
puЬlic static void main(String args[])
!! Внутренняя версия класса ShowBits
class ShowBits { Локоnьныйкпосс, аnоженныйвметод
int numЬits;
ShowBits(int n)
numЬits = n;
void show(long val)
long mask = 1;
!! Сдвиг влево для установки единицы в нужной позиции
mask <<= numЬits-1;
int spacer = О;
for (; mask ! = О; mask >»= 1) {
if( (val & mask) != О) System.out.print("l");
else System.out.print("O");
spacer++;
if ( (spacer % 8) == О) {
System.out.print(" ");
spacer = О;
о
1
2
3
4
5
6
7
8
9
Глава 6. Дополнительные сведения о методах и классах 237
Systern.out.println();
for (byte Ь = О; Ь < 10; Ь++) {
ShowBits byteval = new ShowBits(B);
Systern.out.print(b + " в двоичном представлении: ");
byteval.show(b);
Выполнение этой программы дает следующий результат.
в двоичном представлении: 00000000
В ДВОИЧНОМ представлении: 00000001
в двоичном представлении: 00000010
В ДВОИЧНОМ представлении: 00000011
в двоичном представлении: 00000100
в двоичном представлении: 00000101
в двоичном представлении: 00000110
в двоичном представлении: 00000111
в двоичном представлении: 00001000
В ДВОИЧНОМ представлении: 00001001
В данном примере класс ShowBi ts недоступен за пределами метода main () , а следовательно,
попытка получить доступ к нему из любого метода, кроме main () , приведет к
ошибке.
И последнее замечание: внутренний класс может быть безымянным. Экземпляр
безымянного, или анонимного, внутреннего класса создается при объявлении класса с помощью
оператора new. Безымянные внутренние классы будут подробнее рассмотрены в
rлаве 16.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Чем статический вложенный класс отличается от нестатического?
ОТВЕТ. Статический вложенный класс объявляется с помощью модификатора
static. Являясь статическим, он может непосредственно обращаться к любому
статическому члену своего внешнего класса. Другие члены внешнего класса доступны
ему посредством ссылки на объект.
Переменное число аргументов
Иногда оказываются полезными методы, способные принимать переменное число
аргументов. Например, методу, устанавливающему соединение с Интернетом, могут
понадобиться имя и пароль пользователя, имя файла, протокол и другие параметры.
Если при вызове метода некоторые из этих данных опущены, то должны использоваться
238 Java 8: руководство для начинающих, 6-е издание
значения по умолчанию. В подобных ситуациях бьuю бы удобнее передавать только те
аргументы, для которых заданные по умолчанию значения неприменимы, а для этого
требуется метод, который мог бы принимать аргументы, количество которых заранее не
известно.
До версии J2SE5 для поддержки списков аргументов переменной длины применялись
два способа, ни один из которых не был особенно удобен. Во-первых, если максимально
возможное количество аргументов было невелико и заранее известно, то можно
было создавать перегруженные версии метода - по одной для каждого способа его вызова.
Очевидно, что такой подход применим лишь в отдельных случаях. И во-вторых,
если таких версий требовалось создавать слишком много или их максимальное количество
было неопределенным, то применялся второй подход: параметры помещались в
массив, а затем этот массив передавался методу. У каждого из этих способов имеются
свои недостатки, и со временем стало ясно, что для преодоления описанной проблемы
следует искать другие решения.
Такое решение было предложено в JDK 5. Новое средство, которое позволило избавиться
от явного формирования массива аргументов перед вызовом метода, получило
название varargs (сокращение от variahle-length arguments - список аргументов переменной
длины). Соответствующие методы называют методами с переменным числом аргументов
(другое название - методы переменной арности). В методах этого типа список
параметров имеет не фиксированную, а переменную длину, что обеспечивает дополнительную
гибкость, позволяя методам принимать произвольное число аргументов.
Использование методов с переменным числом аргументов
Списки аргументов переменной длины обозначаются символом многоточия ( ... ).
Ниже приведен пример метода vaTest () , принимающего переменное число аргументов
(в том числе и нулевое).
// Метод vaTest() с переменным числом аргументов
static void vaTest (int ... v) { ----------Объ•1nение метода со сnнском
System.out.println("Чиcлo аргументов: " + v.length);
System.out.println("Coдepжимoe: ");
for(int i=O; i < v.length; i++)
System.out.println(" arg " + i + "· " + v[i]);
System.out.println();
Обратите внимание на синтаксис объявления параметра v:
int ... v
орrументо1 переменной дпинw
Это объявление сообщает компилятору, что метод vaTest () может вызываться с указанием
произвольного количества аргументов, в том числе и вовсе без них. Более того,
оно означает неявное объявления аргумента v как массива типа int [ J. Таким образом,
в теле метода vaTest () доступ к параметру v осуществляется с помощью обычного синтаксиса
обращения к массивам.
Ниже приведен полный исходный код примера программы, которая демонстрирует
использование метода vaTest () .
Глава 6. Дополнительные сведения о методах и классах 239
// Демонстрация использования метода с переменным числом
// аргументов.
class VarArgs {
// Метод vaTest() допускает переменное число аргументов
static void vaTest(int ... v) {
Systern.out.println("Koличecтвo аргументов: " + v.length);
Systern.out.println("Coдepжимoe: ");
for(int i=O; i < v.length; i++)
Systern.out.println(" arg " + i + "· " + v[i]);
Systern.out.println();
puЫic static void rnain(String args[))
{
/ / Метод vaTest () может вызываться с
// переменным числом аргументов
vaTest(lO); // 1 аргумент vaTest (1, 2, 3); // 3 аргумента J----Вызовы методасуказаннем
vaTest (); / / без аргументов
разnнчного чнсnа аргументов
Выполнение этой программы дает следующий результат.
Количество аргументов: 1
Содержимое:
arg О: 10
Количество аргументов: 3
Содержимое:
arg О: 1
arg 1: 2
arg 2: 3
Количество аргументов: О
Содержимое:
В приведенной выше программе обращает на себя внимание следующее. Во-первых,
как пояснялось выше, обращение к параметру v в методе vaTest () осуществляется как
к массиву. Дело в том, что он действительно является массивом (и, таким образом, может
иметь переменную длину) Многоточие в объявлении этого метода указывает компилятору
на использование переменного числа аргументов, а также на необходимость поместить
их в массив v. Во-вторых, в методе main () присутствуют вызовы метода vaTest ()
с использованием различного числа аргументов, в том числе и без указания аргумента.
Указываемые аргументы автоматически помещаются в массив v. Если же аргументы не
указаны, длина этого массива будет равна нулю.
Помимо списка параметров переменной длины, в объявлении метода могут указываться
и обычные параметры, но при одном условии: массив параметров переменной
длины должен быть указан последним. Например, приведенное ниже объявление метода
является вполне допустимым.
int doit(int а, int Ь, douЫe с, int ... vals) {
240 Java 8: руководство для начинающих. 6-е издание
В этом случае первым трем аргументам, указанным при вызове метода doit () , будут
соответствовать первые три параметра в объявлении метода, тогда как остальные аргументы
будут приниматься из массива vals.
Ниже приведен переработанный вариант метода vaTest () , в котором метод получает
как обычные аргументы, так и массив аргументов переменной длины.
// Использование массива аргументов переменной длины
!/ наряду с обычными аргументами
class VarArgs2 {
// Здесь msg - обычный параметр,
!/ а v - массив параметров переменной длины
static void vaTest ( String msg, int . . . v) { ......t-- --"06wчнwй" параметр н параметр
System.out.println(msg + v.length); 1 1ндемас:с:н1опеременнойдnннw
System.out.println("Coдepжимoe: ");
for(int i=O; i < v.length; i++)
System.out.println(" arg " + i + "· " + v[i]);
System.out.println();
puЫic static void main(String args[J)
{
vаТеst("Один аргумент в массиве: ", 10);
vaTest("Tpи аргумента в массиве: ", 1, 2, З);
vаТеst("Отсутствуют аргументы в виде массива: ");
Выполнение этого фрагмента кода дает следующий результат.
Один аргумент в массиве: 1
Содержимое:
arg О: 10
Три аргумента в массиве: 3
Содержимое:
arg О: 1
arg 1: 2
arg 2: З
Отсутствуют аргументы в массиве: О
Содержимое:
Помните о том, что список параметров переменной длины должен указываться последним.
Например, следующее объявление метода недопустимо.
int doit(int а, int Ь, douЫe с, int ... vals,
boolean stopFlag) { // Ошибка!
В данном примере сделана попытка указать обычный параметр после списка параметров
переменной длины.
Глава 6. Дополнительные сведения о методах и классах 241
Существует еще одно ограничение, которое следует соблюдать: список параметров
переменной длины можно указать в методе только один раз. Например, приведенное
ниже объявление метода недопустимо.
int do!t(int а, int Ь, douЫe с, int ... vals,
douЫe ... morevals) { // Ошибка!
Ошибкой в данном случае является попытка указать два разных списка параметров
переменной длины.
Перегрузка методов с переменным
числом аргументов
Методы, принимающие переменное количество аргументов, можно перегружать.
Например, в следующей программе представлены три перегруженные версии метода
vaTest ().
// Перегрузка метода с переменным числом аргументов
class VarArgsЗ {
static void vaтest(int ... v) { -4----Переоя версия метода vaтest ()
System.out.println("vaTest(int ... ): " +
"Количество аргументов: " + v.length);
System.out.println("Coдepжимoe: ");
for(int i=O; i < v.length; i++)
System.out.println(" arg " + i + "· " + v[i]);
System.out.println();
static void vaTest(boolean ... v) { -4----Второя версия метода vaTest ()
System.out.println("vaTest(boolean ... ): " +
"Количество аргументов: " + v. length) ;
System.out.println("Coдepжимoe: ");
for(int i=O; i < v.length; i++)
System.out.println(" arg " + i + "· " + v[i]);
System.out.println();
static void vaтest(String msg, int ... v) { -4----Третья версия метода vaтest()
System.out.println("vaTest(String, int ... ): " +
msg + v.length);
System.out.println("Coдepжимoe: ");
for(int i=O; i < v.length; i++)
System.out.println(" arg " + i + "· " + v[i]);
System.out.println();
242 Java 8: руководство для начинающих. 6-е издание
puЫic static void main(String args[])
{
vaTest (1, 2, 3);
vаТеst("Тестирование: ", 10, 20);
vaTest(true, false, false);
Выполнение этой программы дает следующий результат.
vaтest(int ... ): Количество аргументов: 3
Содержимое:
arg О: 1
arg 1: 2
arg 2: 3
vaTest(String, int ... ): Тестирование: 2
Содержимое:
arg О: 10
arg 1: 20
vaTest(boolean ... ): Количество аргументов: 3
Содержимое:
arg О: true
arg 1: false
arg 2: false
В этой программе продемонстрированы два способа перегрузки методов с переменным
числом аргументов. Во-первых, перегруженные версии методов могут различаться
типом параметра, содержащего переменное количество аргументов. По этому принципу
перегружены версии метода vaтest ( int ... ) и vaTest (boolean ... ) . Вспомните, что
многоточие говорит о том, что соответствующий аргумент должен рассматриваться как
массив указанного типа. Поэтому, в полной аналогии с тем, как обычные методы можно
перегружать за счет использования различных типов параметра, соответствующего массиву,
методы с переменным числом аргументов можно перегружать, используя различные
типы параметра varargs. На основании этого различия и будет определяться версия,
подлежащая вызову.
Второй способ перегрузки методов с переменным числом аргументов состоит в добавлении
одного или нескольких обычных аргументов. Он реализован в версии метода
vaTest (String, int ... ) . В этом случае исполняющая система Java использует для выбора
нужной версии метода как число параметров, так и их типы.
Переменное число аргументов и неопределенность
Перегрузка методов, принимающих список аргументов переменной длины, может
приводить к возникновению непредвиденных ошибок. Причиной их появления является
неопределенность, которая может возникать при вызове перегруженного метода с переменным
числом аргументов. В качестве примера рассмотрим следующую программу.
// Перегрузка метода с переменным числом аргументов
// и неопределенность в выборе перегруженной версии.
//
// В этой программе имеется ошибка, и
// поэтому она не будет компилироваться.
class VarArgs4 {
Глава 6, Дополнительные сведения о методах и классах 243
// Использование списка аргументов переменной длины типа int
static void vaTest (int ... v) {
// ...
// Использование списка аргументов переменной длины типа boolean
static void vaTest(boolean ... v) {
// . . .
puЫic static void main(String args[])
{
vaтest(l, 2, З); // ОК
vaTest(true, false, false); // ОК
vaTest(); // Ошибка: неопределенность вызова!
В этой программе перегрузка метода vaTest () выполнена совершенно правильно,
но программа не будет скомпилирована из-за наличия следующего вызова:
vaTest(); // Ошибка: неопределенность вызова!
Вспомните, что переменное количество аргументов допускает и полное их отсутствие,
так что в этом отношении все нормально. Однако приведенный выше вызов не
может быть однозначно интерпретирован, поскольку ему соответствуют обе перегруженные
версии метода: vaTest (int ... ) и vaTest (boolean ... ) .
Рассмотрим еще один пример возникновения неопределенности при обращении к
методу. Из двух приведенных ниже версий метода vaTest () компилятор не сможет однозначно
выбрать требуемую, хотя, казалось бы, одна из них явно отличается от другой
наличием дополнительного обычного аргумента.
static void vaTest (int ... v) { // ...
static void vaTest (int n, int ... v) { // ...
И тем не менее компилятор не сможет определить, какую именно из этих двух версий
необходимо использовать для следующего вызова:
vaTest ( l)
Действительно, здесь совершенно неясно, каким образом следует интерпретировать
эту строку кода: как вызов метода vaTest (int ... ) с одним аргументом в виде списка
параметров переменной длины или как вызов метода vaTest (int, int ... ) с отсутствующим
списком аргументов переменной длины? Таким образом, в подобных ситуациях
также возникает неопределенность.
В силу описанных причин в ряде случаев имеет смысл отказаться от перегрузки, а
для различения методов присвоить им разные имена. Кроме того, в некоторых случаях
возникновение ошибок неопределенности может указывать на то, что при проектировании
программы были допущены просчеты, которые можно исправить, более тщательно
продумав структуру программы.
244 Java 8: руководство для начинающих, 6-е издание
/,/
Вопросы н уnражнення для самопроверкн
1. Предположим, имеется следующий фрагмент кода.
class Х {
private int count;
Исходя из этого, допустим ли следующий код?
class У {
puЫic static void main (String args []) {
Х оЬ = new Х();
ob.count = 10;.
2. Модификатор доступа должен объявлению члена класса.
3. Помимо очереди, в программах часто используется структура данных, которая
называется стеком. Обращение к стеку осуществляется по принципу "первым
пришел - последним обслужен". Стек можно сравнить со стопкой тарелок, стоящих
на столе. Последней берется тарелка, поставленная на стол первой. Создайте
класс Stack, реализующий стек для хранения символов. Используйте методы
push ( ) и рор () для манипулирования содержимым стека. Пользователь класса
Stack должен иметь возможность задавать размер стека при ero создании. Все
члены класса Stack, кроме методов push () и рор (), должны быть объявлены
как pri vate. (Подсказка: в качестве исходной заготовки можете воспользоваться
классом Queue, изменив в нем лишь способ доступа к данным.)
4. Предположим, имеется следующий класс.
class Test
int а;
Test(int i) { а = i; }
Напишите метод swap () , реализующий обмен содержимым между двумя объектами
типа Test, на которые ссылаются две переменные данного типа.
5. Правильно ли написан следующий фрагмент кода?
class Х {
int meth (int а, int Ь) { ... }
String meth ( int а, int Ь) { •••
6. Напишите рекурсивный метод, отображающий символы, составляющие строку в
обратном порядке.
7. Допустим, все объекты класса должны совместно использовать одну и ту же переменную.
Как объявить такую переменную?
8. Для чего может понадобиться статический блок?
9. Что такое внутренний класс?
10. Допустим, требуется член класса, к которому могут обращаться только другие
члены этого же класса. Какой модификатор доступа следует использовать в ero
объявлении?
11. Имя метода и список ero параметров вместе составляют------- метода.
Глава 6. Дополнительные сведения о методах и классах 245
12. Если методу передается значение типа int, то в этом случае используется переда-
ча параметра по _____ _
13. Создайте метод sum () , принимающий список аргументов переменной длины и
предназначенный для суммирования передаваемых ему значений типа int. Метод
должен возвращать результат суммирования. Продемонстрируйте работу этого
метода.
14. Можно ли перегружать методы с переменным количеством аргументов?
15. Приведите пример вызова перегруженного метода с переменным количеством аргументов,
демонстрирующий возникновение неопределенности.

Глава 7
Наследование
248 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
%' Основы наследования
􀂬 Вызов конструктора суперкласса
􀂭 Обращения к членам суперкласса с помощью ключевого слова super
t􀂮 Создание многоуровневой иерархии классов
􀂯 Порядок вызова конструкторов
􀂰 Ссылки на объекты подкласса из переменной суперкласса
!$ Переопределение методов
􀂱 Применение переопределяемых методов для организации динамиче-
ского доступа
'Щ} Абстрактные классы
􀂲 Использование ключевого слова final
􀂳 Класс Obj ect
о дним из трех фундаментальных принципов объектно-ориентированного программирования
служит наследование - механизм, обеспечивающий создание
иерархических классификаций. Используя наследование, можно создать общий класс,
определяющий характеристики, которые будут общими для множества родственных
элементов. Затем этот класс может наследоваться другими, более специализированными
классами, каждый из которых будет добавлять собственные уникальные характеристики.
В терминологии Java наследуемый класс называют суперклассом, а наследующий -
подклассом. Таким образом, подкласс - это специализированная версия суперкласса.
Он наследует все переменные и методы, определенные в суперклассе, дополняя их собственными,
уникальными элементами.
Основы наследования
В Java, чтобы наследовать класс, достаточно включить его имя в объявление другого
класса с помощью ключевого слова extends. Таким образом, подкласс расширяет суперкласс,
дополняя его собственными членами.
Рассмотрим простой пример, позволяющий продемонстрировать некоторые свойства
наследования. В приведенной ниже программе создается суперкласс TwoDShape, хранящий
сведения о ширине и высоте двумерного объекта, а также его подкласс Triangle.
Обратите внимание на использование ключевого слова extends при создании подкласса.
// Простая иерархия классов
// Класс, описывающий двумерные объекты
class TwoDShape {
douЫe width;
douЫe height;
Глава 7. Наследование 249
void showDim() {
System.out.println("Шиpинa и высота - " +
width + " и " + height);
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
String style; t􀀃􀀄􀀄􀀄􀀄􀀄􀀄􀀄􀀄- - Кпасс Triangle насnедует кnасс TwoDShape
douЫe area() {
return width * height / 2; ----- Из кnасса Triangle можно обращатьс11 к чnенам
кnасса ТWoDShape так, как есnн бы это бwnн ero
собственные чnенw
void showStyle() {
System.out.println("Tpeyгoльник " + style);
class Shapes {
puЫic static void main(String args[JI
Triangle tl new Triangle();
Triangle t2 = new Triangle();
tl.width = 4.0;
tl.height = 4.0; 4----Объектам тнnа Triangle достуnнw все чnенw кnасса Triangle,
tl.style "закрашенный";
t2.width 8.0;
t2.height = 12.0;
t2.style = "контурный";
даже те, которые унасnедованw от кnасса TwoDShape
System.out.println("Инфopмaция о tl: ");
tl.showStyle();
tl. showDim ();
System.out.println("Плoщaдь - " + tl.area());
System.out.println();
System.out.println("Инфopмaция о t2: ");
t2.showStyle();
t2. showDim () ;
System.out.println("Плoщaдь - " + t2.area());
Ниже приведен результат выполнения данной программы.
Информация о tl:
Треугольник закрашенный
Ширина и высота - 4.0 и 4.0
Площадь - 8.0
250 Java 8: руководство для начинающих. 6-е издание
Информация о t2:
Треугольник контурный
Ширина и высота - 8.0 и 12.О
Площадь - 48.0
Здесь в классе TwoDShape определены свойства обобщенной двумерной фигуры,
частными случаями которой могут быть квадрат, треугольник, прямоугольник и т.п.
Класс Triangle представляет конкретную разновидность класса TwoDShape, в данном
случае треугольник. Класс Triangle включает в себя все элементы класса TwoDShape,
а в дополнение к ним - поле style и методы area () и showStyle (). Описание стиля
оформления треугольника хранится в переменной экземпляра style. В этой переменной
может храниться любая строка, описывающая треугольник, например "закрашенный",
"контурный", "прозрачный", "закрашенный" или "скругленный". Метод area ()
вычисляет и возвращает площадь треугольника, а метод showStyle () отображает стиль
оформления треутольника.
В класс Triangle входят все члены суперкласса TwoDShape, и поэтому в теле метода
area () доступны переменные экземпляра width и height. Кроме того, объекты tl и t2
в методе main () могут непосредственно обращаться к переменным width и height, как
если бы они принадлежали классу Triangle. На рис. 7.1 схематически показано, каким
образом суперкласс TwoDShape включается в состав класса Triangle.
TooDShap,{
width
height
showDim( )
Triangle
style
area( )
showStyle( )
Рис. 7.1. Схематическое представление класса Triangle
Несмотря на то что TwoDShape является суперклассом для класса Triangle, он
по-прежнему остается независимым классом. Тот факт, что один класс является суперклассом
друтого, вовсе не исключает возможности его непосредственного использования.
Например, следующий фрагмент кода вполне допустим.
TwoDShape shape = new TwoDShape();
shape.width = 10;
shape.height = 20;
shape. showDim () ;
Разумеется, объекту типа TwoDShape ничего не известно о подклассах своего класса
TwoDShape, и он не может к ним обращаться.
Ниже приведена общая форма объявления класса, наследующего суперкласс.
class имя
_
подкласса extends имя_суперкласса {
// тело класса
Глава 7. Наследование 251
Для каждого создаваемого подкласса можно указать только один суперкласс. Множественное
наследование в Java не поддерживается, т.е. у подкласса не может быть несколько
суперклассов. (Этим Java отличается от языка С++, где допускается наследование
одновременно нескольких классов. Не забывайте об этом, если вам когда-нибудь
придется преобразовывать код С++ в код Java.) С другой стороны, в Java допускается
многоуровневая иерархия, в которой один подкласс является суперклассом другого подкласса.
И конечно же, класс не может быть суперклассом по отношению к самому себе.
Главное преимущество наследования заключается в следующем: создав суперкласс, в
котором определены общие для множества объектов свойства, вы можете использовать
его для создания любого числа более специализированных подклассов. Каждый подкласс
добавляет собственный набор специфических для него атрибутов в соответствии
с конкретной необходимостью. В качестве примера ниже приведен еще один подкласс,
который наследует суперкласс TwoDShape и инкапсулирует прямоугольники.
// Подкласс для представления прямоугольников,
// производный от класса TwoDShape
class Rectangle extends TwoDShape {
boolean isSquare() {
if(width == height) return true;
return false;
douЫe area() {
return width * height;
В класс Rectangle входят все члены класса TwoDShape. Кроме того, он содержит метод
isSquare (), определяющий, является ли прямоугольник квадратом, а также метод
area (), вычисляющий площадь прямоугольника.
Наследование и доступ к членам класса
Как отмечалось в главе 6, с целью исключения несанкционированного доступа к членам
класса их часто объявляют как закрытые, используя для этого модификатор доступа
private. Наследование класса не отменяет ограничений, налагаемых на доступ к закрытым
членам класса. Поэтому, несмотря на то что в подкласс автоматически включаются
все члены его суперкласса, доступ к закрытым членам суперкласса ему запрещен. Так,
если переменные экземпляра width и height в классе TwoDShape объявить как закрытые
(см. ниже), это предотвратит возможность доступа к ним из класса Triangle.
!/ Закрытые члены класса не наследуются.
// Этот код не пройдет компиляцию.
// Класс, описывающий двумерные объекты
class TwoDShape {
private douЫe width; // теперь эти переменные
private douЫe height; // объявлены как закрытые
252 Java 8: руководство для начинающих. 6-е издание
void showDim() (
System.out.println("Шиpинa и высота - " +
width + " и " + height);
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
String style;
1.----------Доступ к чnенам суперкnасса, объявnенным
f
как закрытые, невозможен
douЫe area ()
return width * height / 2; // Ошибка! Доступ запрещен.
void showStyle() (
System.out.println("Tpeyгoльник " + style);
Класс Triangle не сможет быть скомпилирован, поскольку ссылки на переменные
width и height в методе area () нарушают правила доступа. Эти переменные объявлены
закрытыми {private), и поэтому они доступны только членам собственного класса.
Подклассы доступа к ним не имеют.
Не забывайте, что член класса, объявленный как закрытый, недоступен за пределами
своего класса. Это ограничение распространяется на все подклассы данного класса.
На первый взгляд, ограничение на доступ к закрытым членам суперкласса из подкласса
кажется трудно преодолимым, поскольку это исключает возможность их использования.
Однако это вовсе не так. Как пояснялось в главе 6, для обращения к закрытым
членам класса в программах на Java обычно используют специальные методы доступа.
Ниже в качестве примера приведены видоизмененные классы TwoDShape и Triangle, в
которых методы доступа используются для обращения к переменным экземrтяра width
и height.
// Использование методов доступа для установки и
// получения значений закрытых членов.
// Класс, описывающий двумерные объекты
class TwoDShape (
private douЫe width; // теперь эти переменные
private douЫe height; // объявлены как закрытые
// Методы доступа к закрытым переменным
douЫe getWidth() ( return width; }
douЫe getHeight() ( return height; }
void setWidth(douЫe w) ( width = w; }
void setHeight(douЫe h) ( height = h;
void showDim() {
экземпляра width и height
----- Методы доступа к переменным
экземмяра width н height
System.out.println("Шиpинa и высота - " +
width + " и " + height);
Глава 7. Наследование 253
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
String style;
douЫe area ()
return getWidth() * getHeight() / 2;
void showStyle() {
System.out.println("Tpeyгoльник " + style);
class Shapes2 {
puЫic static
Triangle tl
Triangle t2
void main(String args[])
new Triangle();
= new Triangle();
tl.setWidth(4.0);
tl.setHeight(4.0);
tl.style = "закрашенный";
t2.setWidth(8.0);
t2.setHeight(12.0);
t2.style = "контурный";
System.out.println("Инфopмaция о tl: ");
tl. showStyle () ;
tl.showDim();
System.out.println("Плoщaдь - " + tl.area());
System.out.println();
System.out.println("Инфopмaция о t2: ");
t2.showStyle();
t2.showDim();
System.out.println("Плoщaдь - " + t2.area());
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. В каких случаях переменную экземпляра следует объявлять закрытой?
ОТВЕТ. Не существует твердых правил, позволяющих принять безошибочное решение
по данному вопросу. Следует лишь придерживаться двух общих принципов.
Во-первых, если переменная экземпляра используется только методами,
определенными в классе, то она должна быть закрытой. И во-вторых, если значение
переменной экземпляра не должно выходить за определенные границы,
ее следует объявить как закрытую, а обращение к ней организовать с помощью
специальных методов доступа. Подобным образом можно предотвратить присваивание
недопустимых значений переменной.
254 Java 8: руководство для начинающих, 6-е издание
Конструкторы и наследование
В иерархии классов допускается, чтобы как суперклассы, так и подклассы имели
собственные конструкторы. В связи с этим возникает вопрос: какой именно конструктор
отвечает за создание объекта подкласса - конструктор суперкласса, конструктор
подкласса или же оба одновременно? На этот вопрос можно ответить так: конструктор
суперкласса используется для построения родительской части объекта, а конструктор
подкласса - для остальной его части. И в этом есть своя логика, поскольку суперклассу
неизвестны и недоступны любые собственные члены подкласса, а значит, каждая из
указанных частей объекта должна конструироваться по отдельности. В приведенных
выше примерах этот вопрос не возникал, поскольку они базировались на автоматически
создаваемых конструкторах, используемых по умолчанию. Но на практике в большинстве
случаев конструкторы приходится определять явным образом.
Если конструктор определен только в подклассе, то все происходит очень просто:
конструируется объект подкласса, а родительская часть объекта автоматически создается
конструктором суперкласса, используемым по умолчанию. В качестве примера
рассмотрим приведенный ниже переработанный вариант класса Triangle, в котором
определяется собственный конструктор, в связи с чем член style этого класса делается
закрытым.
// Добавление конструктора в класс Triangle.
// Класс, описывающий двумерные объекты
class TwoDShape {
private douЫe width; // теперь эти переменные
private douЫe height; // объявлены как закрытые
// Методы доступа к переменным экземпляра width и height
douЫe getWidth() { return width; 1
douЫe getHeight() { return height; 1
void setWidth(douЫe w) { width = w; 1
void setHeight(douЫe h) { height = h;
void showDim() {
System.out.println(11 Шиpинa и высота - " +
width + 11 и 11 + height);
// Подкласс для представления треугольников,
// производный: от класса TwoDShape
class Triangle extends TwoDShape {
private String style;
// Конструктор
Triangle(String s, douЫe w, douЫe h) {
setWidth(w);
s е tHe i g h t ( h) ; Иннцноnнзоцня чостн объекта, соответствующей кnоссу TwoDShape
style = s;
Глава 7. Наследование 255
douЫe area() {
return getWidth() * getHeight() / 2;
void showStyle() {
Systern.out.println("Tpeyгoльник " + style);
class ShapesЗ {
puЫic static
Triangle tl
Triangle t2
void rnain(String args[J) {
new Тriаnglе("закрашенный", 4.0, 4.0);
= new Тriаnglе("контурный", 8.0, 12.0);
Systern.out.println("Инфopмaция о tl: ");
tl.showStyle();
tl.showDirn();
Systern.out.println("Плoщaдь - " + tl.area());
Systern.out.println();
Systern.out.println("Инфopмaция о t2: ");
t2.showStyle();
t2.showDirn();
Systern.out.println("Плoщaдь - " + t2.area());
Здесь конструктор класса Triangle инициализирует как собственное поле style, так
и унаследованные члены класса TwoDClass.
Если конструкторы объявлены как в подклассе, так и в суперклассе, то дело несколько
усложняется, поскольку должны быть выполнены оба конструктора. В этом случае
на помощь приходит ключевое слово super, которое может применяться в двух общих
формах. Первая форма используется для вызова конструктора суперкласса, а вторая -
для доступа к членам суперкласса, скрытых членами подкласса. Рассмотрим первое из
указанных применений ключевого слова super.
Использование ключевого слова super
для вызова конструктора суперкласса
Для вызова конструктора суперкласса из подкласса используется следующая общая
форма ключевого слова super:
super (список_ параметров) ;
где список_ параметров определяет параметры, требуемые конструктором суперкласса.
Вызов конструктора super () всегда должен быть первым оператором в теле конструктора
подкласса. Проиллюстрируем использование вызова super () на примере приведенной
ниже программы, включающей видоизмененную версию класса TwoDShape, в
которой определен конструктор, инициализирующий переменные экземпляра width и
height.
256 Java 8: руководство для начинающих. 6-е издание
// Добавление конструкторов в класс TwoDShape
class TwoDShape {
private douЫe width;
private douЫe height;
// Параметризированный конструктор
TwoDShape(douЫe w, douЫe h) {
width = w;
height = h;
----- Конструктор кnоссо TwoDShape
// Методы доступа к переменным экземпляра width и height
douЫe getWidth() { return width; }
douЫe getHeight() { return height; 1
void setWidth(douЫe w) { width = w; }
void setHeight(douЫe h) { height = h;
void showDirn() {
Systern.out.println("Шиpинa и высота - " +
width + " и " + height);
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
private String style;
Triangle(String s, douЫe w, douЫe hl {
su er(w, h); // вызвать конструктор суперкласса
style = s;
Испоnьзоаание оператора super () дnя
аwэова конструктора кnасса TwoDShape
douЫe area() {
return getWidth() * getHeight() / 2;
void showStyle() {
Systern.out.println("Tpeyгoльник " + style);
class Shapes4 {
puЫic static
Triangle tl
Triangle t2
void rnain(String args[]) {
new Тriаnglе("закрашенный", 4.0, 4.0);
= new Тriаnglе("контурный", 8.0, 12.0);
Systern.out.println("Инфopмaция о tl: ");
tl.showStyle();
tl. showDirn () ;
Systern.out.println("Плoщaдь - " + tl.area());
System.out.println();
System.out.println("Инфopмaция о t2: ");
t2.showStyle();
t2.showDim();
Глава 7. Наследование 257
System.out.println("Плoщaдь - " + t2.area());
В конструкторе Triangle присутствует вызов конструктора super () с параметрами
w и h. В результате управление получает конструктор TwoDShape ( ) , инициализирующий
переменные width и height этими значениями. Теперь класс Triangle не должен самостоятельно
инициализировать элементы суперкласса. Ему остается инициализировать
только собственную переменную экземпляра style. Конструктору TwoDShape () предоставляется
возможность построить соответствующий подобъект так, как требуется для
данного класса. Более того, в суперклассе TwoDShape можно реализовать функции, о
которых подклассам ничего не будет известно. Благодаря этой мере повышается отказоустойчивость
кода.
Вызов super () позволяет вызвать любую форму конструктора, определенную в суперклассе
Для выполнения выбирается тот вариант конструктора, который соответствует
указанным аргументам. Ниже в качестве примера приведены расширенные версии
классов TwoDShape и Triangle, которые содержат конструкторы по умолчанию и конструкторы,
принимающие один и более аргументов.
// Добавление дополнительных конструкторов в класс TwoDShape
class TwoDShape {
private douЫe width;
private douЫe height;
// Конструктор по умолчанию
TwoDShape() {
width = height = О.О;
// Параметризированный конструктор
TwoDShape(douЫe w, douЫe h) {
width = w;
height = h;
// Конструирование объекта с одинаковыми значениями
// переменных экземпляра width и height
TwoDShape(douЫe х) {
width = height = х;
// Методы доступа к переменным экземпляра width и height
douЫe getWidth() { return width; }
douЫe getHeight() { return height; }
void setWidth(douЫe w) { width = w; }
void setHeight(douЫe h) { height = h;
258 Java 8: руководство для начинающих, 6-е издание
void showDim() {
System.out.println("Шиpинa и высота - " +
width + " и " + height);
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
private String style;
// Конструктор по умолчанию
Triangle () {
super(); // вызвать конструктор суперкласса по умолчанию
style = "none";
// Конструктор
Triangle(String s, douЫe w, douЫe h) {
super(w, h); // вызвать конструктор суперкласса с двумя аргументами
s t у 1 е = s ; Исnоn•зовонне
аргументом
оператора super ()
дn• вwзово рознwх
форм конструктора
// Конструктор с одним TwoDShape ()
Triangle(douЫe х) {
super(x); // вызвать конструктор суперкласса с одним аргументом 􀀃-t-􀀄􀀄􀀅
style = "закрашенный";
douЫe area() {
return getWidth() * getHeight() / 2;
void showStyle() {
System.out.println("Tpeyгoльник " + style);
class Shapes5 {
puЫic static
Triangle tl
Triangle t2
Triangle tЗ
tl = t2;
void main(String args(J) {
new Triangle();
new Triangle ("контурный", 8. О, 12. 0);
new Triangle(4.0);
System.out.println("Инфopмaция о tl: ");
tl.showStyle();
tl.showDim(J;
System.out.println("Плoщaдь - " + tl.area()J;
System.out.println();
System.out.println("Инфopмaция о t2: ");
t2.showStyle();
t2. showDim () ;
Глава 7. Наследование 259
System.out.println("Плoщaдь - " + t2.area());
System.out.println();
System.out.println("Инфopмaция о tЗ: ");
tЗ.showStyle();
tЗ. showDim () ;
System.out.println("Плoщaдь - " + tЗ.area());
System.out.println();
Выполнение этой версии программы дает следующий результат.
Информация о tl:
Треугольник контурный
Ширина и высота - В.О и 12.0
Площадь - 48.0
Информация о t2:
Треугольник контурный
Ширина и высота - В.О и 12.0
Площадь - 48.0
Информация о tЗ:
Треугольник закрашенный
Ширина и высота - 4.0 и 4.0
Площадь - В.О
Еще раз напомним основные свойства вызова конструктора super () . Когда этот вызов
присутствует в конструкторе подкласса, происходит обращение к конструктору его
непосредственного суперкласса. Таким образом, вызывается конструктор того класса,
который непосредственно породил вызывающий класс. Это справедливо и при многоуровневой
иерархии. Кроме того, вызов конструктора super () должен быть первой инструкцией
в теле конструктора подкласса.
Применение ключевого слова super
для доступа к членам суперкласса
Существует еще одна общая форма ключевого слова super, которая применяется подобно
ключевому слову this, но ссылается на суперкласс данного класса. Эта общая
форма обращения к члену суперкласса имеет следующий вид:
sиреr. член
_
класса
где член
_
класса обозначает метод или переменную экземпляра.
260 Java 8: руководство для начинающих. 6-е издание
Данная форма ключевого слова super используется в тех случаях, когда член подкласса
скрывает член суперкласса. Рассмотрим следующий пример простой иерархии
классов.
// Использование ключевого слова super для предотвращения
// сокрытия имен
class А {
int i;
/! Создать подкласс, расширяющий класс А
class В extends А {
int i; // эта переменная i скрывает переменную i из класса А
B{int а, int Ь) {
super.i = а; // переменная i из класса А
i = Ь; // переменная i из класса В
void show{) {
4---- Здес􀀔 super. i ссыnается на
переменную i из кnасса А
System.out.println{"i в суперклассе: " + super.i);
System.out.println{"i в подклассе: " + i);
class UseSuper {
puЫic static void main{String args[J) {
В subOb = new B{l, 2);
subOb.show{);
Данная программа выводит следующий результат.
i в суперклассе: 1
i в подклассе: 2
Несмотря на то что переменная экземпляра i в классе в скрывает одноименную переменную
в классе А, ключевое слово super позволяет обращаться к переменной i из
суперкласса. Аналогичным образом ключевое слово super можно использовать для вызова
методов суперкласса, скрываемых методами подкласса.
Упражнение 7.1
........................ ...................
: .?.􀀑􀀒-􀀓-k.?._􀀔rn-􀀕 .: .?. -􀀖 􀀗-􀀘 ... :
Расширение класса Vehicle
Для того чтобы продемонстрировать возможности наследования,
расширим класс Vehicle, созданный в главе 4. Напомним, что
класс Vehicle инкапсулирует данные о транспортных средствах и, в частности, сведения
о количестве пассажиров, объеме топливного бака и расходе топлива. Воспользуемся
классом Vehicle в качестве заготовки для создания более специализированных классов.
Например, транспортным средством, помимо прочих, является грузовик. Одной из
важных характеристик грузовика является его грузоподъемность. Поэтому для создания
класса Truck можно расширить класс Vehicle, добавив переменную экземпляра,
Глава 7. Наследование 261
хранящую сведения о допустимом весе перевозимого груза. В этом проекте переменные
экземпляра объявляются в классе Vehicle как закрытые (pri vate), а для обращения к
ним используются специальные методы доступа. Поэтапное описание процесса создания
программы приведено ниже.
1. Создайте новый файл TruckDemo. java и скопируйте в него исходный код последней
версии класса Vehicle, разработанной в главе 4.
2. Создайте класс Truck, исходный код которого приведен ниже.
// Расширение класса Vehicle для грузовиков
class Truck extends Vehicle {
private int cargocap; // грузоподъемность в фунтах
// Конструктор класса Truck
Truck(int р, int f, int m, int с) {
/* Инициализация членов класса Vehicle
с использованием конструктора этого класса. */
super (р, f, m);
cargocap = с;
// Методы доступа к переменной cargocap
int getCargo() { return cargocap;
void putcargo(int с) { cargocap = с; }
Здесь класс Truck наследует класс Vehicle. В класс Truck добавлены новые члены
cargocap, getCargo () и putCargo (). Кроме того, он содержит все элементы,
определенные в классе Vehicle.
3. Объявите закрытые переменные экземпляра в классе Vehicle.
private int passengers;
private int fuelcap;
private int mpg;
// количество пассажиров
// объем топливного бака в галлонах
// потребление топлива в милях на галлон
4. Ниже приведен полный исходный код программы, в которой демонстрируется
использование класса Truck.
// Упражнение 7.1
//
// Создание подкласса класса Vehicle для грузовиков
class Vehicle {
private int passengers; // количество пассажиров
private int fuelcap; // объем топливного бака в галлонах
private int rnpg; // потребление топлива в милях на галлон
// Конструктор класса Vehicle
Vehicle(int р, int f, int m) {
passengers = р;
fuelcap = f;
rnpg = rn;
// Возвратить дальность поездки транспортного средства
int range () {
262 Java 8: руководство для начинающих. 6-е издание
return mpg * fuelcap;
// Вычислить объем топлива, требующегося
// для прохождения заданного пути
douЫe fuelneeded(int miles) {
return (douЬle) miles / mpg;
// Методы доступа к переменным экземпляра
int getPassengers() { return passengers; }
void setPassengers(int р) { passengers = р;
int getFuelcap () { return fuelcap; }
void setFuelcap(int f) { fuelcap = f; }
int getMpg() { return mpg; }
void setMpg(int m) { mpg = m; }
// Расширение класса Vehicle для грузовиков
class Truck extends Vehicle {
private int cargocap; // грузоподъемность в фунтах
// Конструктор класса Truck
Truck(int р, int f, int m, int с} {
/* Инициализация членов класса Vehicle
с использованием конструктора этого класса. */
super (р, f, m);
cargocap = с;
// Методы доступа к переменной cargocap
int getCargo() { return cargocap;
void putCargo(int с} { cargocap = с; }
class TruckDemo {
puЫic static void main(String args[]) {
// Создать ряд новых объектов типа Truck
Truck semi = new Truck(2, 200, 7, 44000);
Truck pickup = new Truck(З, 28, 15, 2000);
douЫe gallons;
int dist = 252;
gallons = semi.fuelneeded(dist);
System.out.println("Гpyзoвик может перевезти " + semi.getCargo() +
" фунтов.");
System.out.println("Для преодоления " + dist + "миль грузовику
требуется " +
gallons + " галлонов топлива.\n");
gallons pickup.fuelneeded(dist);
Глава 7. Наследование 263
Systern.out.println( 11 Пикaп может перевезти 11 + pickup.getCargo() +
II фунтов.");
Systern.out.println("Для преодоления 11 + dist + " миль пикапу
требуется 11 +
gallons + " галлонов топлива.");
5. Ниже приведен результат выполнения данной программы.
Грузовик может перевезти 44000 фунтов.
Для преодоления 252 миль грузовику требуется 36.0 галлонов топлива.
Пикап может перевезти 2000 фунтов.
Для преодоления 252 миль пикапу требуется 16.8 галлонов топлива.
6. На основе класса Vehicle можно создать немало других подклассов. Например, в
приведенной ниже заготовке класса, описывающего внедорожники, предусмотрена
переменная, содержащая величину дорожного просвета для автомобиля.
// Создание класса, описывающего внедорожники
class OffRoad extends Vehicle {
private int groundClearance; // дорожный просвет в дюймах
// ...
Итак, имея в своем распоряжении суперкласс, определяющий общие свойства
некоторых объектов, можно создать на его основе специализированные подклассы.
Каждый подкласс дополняет свойства суперкласса собственными уникальными
свойствами. В этом и состоит сущность наследования.
Создание многоуровневой иерархии классов
До сих пор мы использовали простые иерархии классов, которые состояли только из
суперкласса и подкласса. Однако Java позволяет строить иерархии, состоящие из любого
количества уровней наследования. Как уже упоминалось выше, многоуровневая иерархия
идеально подходит для использования одного подкласса в качестве суперкласса для
другого подкласса. Так, если имеются три класса, А, в и с, то класс с может наследовать
все характеристики класса В, а тот, в свою очередь, может наследовать все характеристики
класса А. В подобных случаях каждый подкласс наследует характерные особенности
всех своих суперклассов. В частности, класс с наследует все члены классов в и А.
Для того чтобы стало понятнее назначение многоуровневой иерархии, рассмотрим
следующий пример программы. В этой программе подкласс Triangle выступает в роли
суперкласса для класса ColorTriangle. Класс ColorTriangle наследует все свойства
классов Triangle и TwoDShape, а также содержит поле color, определяющее цвет треугольника.
// Многоуровневая иерархия
class TwoDShape {
private douЫe width;
private douЫe height;
264 Java 8: руководство для начинающих. 6-е издание
// Конструктор по умолчанию
TwoDShape () (
width = height = О.О;
// Параметризированный конструктор
TwoDSha.pe (douЫe w, douЫe h) (
width = w;
height = h;
// Создать объект с одинаковыми значениями
// переменных экземпляра width и height
TwoDShape(douЫe х) (
width = height = х;
// Методы доступа к переменным экземпляра width и height
douЫe getWidth () ( return width; }
douЫe getHeight() ( return height; }
void setWidth(douЫe w) ( width = w; }
void setHeight(douЫe h) ( height = h;
void showDim() (
System.out.println("Шиpинa и высота - " +
width + " и " + height);
// Расширение класса TwoDShape
class Triangle extends TwoDShape
private String style;
// Конструктор по умолчанию
Triangle () (
super();
style = "none";
Triangle(String s, douЫe w, douЬle h) (
super(w, h); // вызвать конструктор суперкласса
style = s;
// Конструктор с одним аргументом для построения треугольника
Triangle (douЫe х) (
super(x); // вызвать конструктор суперкласса
style = "закрашенный";
douЫe area() {
return getWidth() * getHeight() / 2;
void showStyle() {
System.out.println("Tpeyгoльник " + style);
// Расширение класса Triangle
class ColorTriangle extends Triangle
Глава 7. Наследование 265
private String color; tь.--------- Кпасс ColorTriangle насnедуеr класс
ColorTriangle (String с, String s,
Triangle, nронэводныйот кпасса
TwoDShape, н поэтому включает асе чnены
douЫe w, douЫe h) кnaccoaTriangleнТWoDShape
super(s, w, h):
color = с;
String getColor () { return color: }
void showColor() {
System.out.println("Цвeт - " + color);
class Shapesб {
puЫic static void main(String args[]) {
ColorTriangle tl =
new ColorTriangle("Cиний", "контурный", 8.0, 12.0);
ColorTriangle t2 =
new ColorTriangle ("Красный", "закрашенный", 2. О, 2. О) ;
System.out.println("Инфopмaция: о tl: ");
tl.showStyle();
tl. showDim () ;
tl.showColor();
System.out.println("Плoщaдь - " + tl.area());
System.out.println();
System.out.println("Инфopмaция: о t2: ") ;
t2.showStyle();
t2. showDim () ;
t2.showColor();
------------ 061.ект тнnа ColorTriangl e может выэыаать как
собственные методы, так н методы суnеркпоссов
System.out.println("Плoщaдь - " + t2.area());
266 Java 8: руководство для начинающих. 6-е издание
Результат выполнения данной программы выглядит следующим образом.
Информация о tl:
Треугольник контурный
Ширина и высота - В.О и 12.0
Цвет - Синий
Площадь - 48.О
Информация о t2:
Треугольник закрашенный
Ширина и высота - 2.0 и 2.0
Цвет - Красный
Площадь - 2.0
Благодаря наследованию в классе ColorTriangle можно использовать ранее определенные
классы Triangle и TwoDShape, дополняя их лишь полями, необходимыми для
конкретного применения класса ColorTriangle. Таким образом, наследование способствует
повторному использованию кода.
Данный пример демонстрирует еще одну важную деталь: вызов super () всегда означает
обращение к конструктору ближайшего суперкласса. Иными словами, вызов
super () в классе ColorTriangle означает вызов конструктора класса Triangle,
а в классе Triangle - вызов конструктора класса TwoDShape. Если в иерархии классов
для конструктора суперкласса предусмотрены параметры, то все суперклассы должны
передавать их вверх по иерархической структуре. Это правило действует независимого
от того, нужны ли параметры самому подклассу или не нужны.
Очередность вызова конструкторов
В связи с изложенным выше в отношении наследования и иерархии классов может
возникнуть следующий вопрос: когда именно создается объект подкласса и какой именно
конструктор выполняется первым - тот, который определен в подклассе, или же тот,
который определен в суперклассе? Например, если имеется суперкласс А и подкласс в,
то что вызывается раньше: конструктор класса А или конструктор класса в? Ответ на
этот вопрос состоит в том, что в иерархии классов конструкторы вызываются в порядке
наследования, начиная с суперкласса и кончая подклассом. Более того, метод super ()
должен быть первым оператором в конструкторе подкласса, и поэтому порядок, в котором
вызываются конструкторы, остается неизменным, независимо от того, используется
ли вызов super () или нет. Если вызов super () отсутствует, то выполняется конструктор
каждого суперкласса по умолчанию (т.е. конструктор без параметров). Порядок вызова
конструкторов демонстрируется на примере следующей программы.
// Демонстрация очередности вызова конструкторов.
// Создать суперкласс
class А {
А() {
System.out.println("Koнcтpyктop А");
// Создать подкласс путем расширения класса А
class В extends А {
В() {
System.out.println("Koнcтpyктop В");
// Создать подкласс путем расширения класса В
class С extends В {
С() {
System.out.println("Koнcтpyктop С");
class OrderOfConstruction {
puЬlic static void main(String args[J) {
С с = new С();
Глава 7. Наследование 267
Ниже приведен результат выполнения данной программы.
Конструктор А
Конструктор В
Конструктор С
Как видите, конструкторы вызываются в порядке наследования классов.
По зрелом размышлении можно прийти к выводу, что вызов конструкторов в порядке
наследования классов имеет определенный смысл. Ведь суперклассу ничего не известно
ни об одном из производных от него подклассов, и поэтому любая инициализация,
которая требуется его членам, не только должна осуществляться независимо от
инициализации членов подкласса, но и, возможно, является необходимой подготовительной
операцией для этого процесса. Следовательно, она должна выполняться первой.
Ссылки на суперкласс и объекты подклассов
Как вам уже известно, Java является строго типизированным языком программирования.
Помимо стандартных преобразований и автоматического повышения простых
типов данных, в этом языке строго соблюдается принцип совместимости типов. Это означает,
что переменная, ссылающаяся на объект класса одного типа, как правило, не
может ссылаться на объект класса другого типа. В качестве примера рассмотрим следующую
простую программу.
// Этот код не пройдет компиляцию
class Х {
int а;
X(int i) { а i;
class У {
int а;
Y(int i) { а i;
268 Java 8: руководство для начинающих. 6-е издание
class IncompatiЬleRef {
puЫic static void main(String args[]) {
Х х = new X(lO);
Х х2;
У у = new Y(S);
х2 х; // Допустимо, так как обе переменные одного типа
х2 у; // Ошибка, так как переменные разных типов
Несмотря на то что классы х и У содержат одинаковые члены, переменной типа Х
нельзя присвоить ссылку на объект типа У, поскольку типы объектов отличаются. Вообще
говоря, ссылочная переменная может указывать только на объекты своего типа.
Однако существует одно важное исключение из этоrо: ссылочной переменной суперкласса
может быть присвоена ссылка на объект любого подкласса, производного от
данного суперкласса. Таким образом, ссылку на объект суперкласса можно использовать
для обращения к объектам соответствующих подклассов. Ниже приведен соответствующий
пример.
// Обращение к объекту подкласса по ссылочной
// переменной суперкласса
class Х {
int а;
X(int i) { а i;
class У extends Х {
int Ь;
Y(int i, int j) {
super(j);
ь = i;
class SupSubRef {
puЫic static void main(String args[]) {
Х х = new X(lO);
Х х2;
У у = new Y(S, 6);
х2 = х; // Допустимо, так как обе переменные одного типа
System.out.println("x2.a: " + х2.а); КпассУ11ап11етс11подкяассомХ,поэтому
􀀥-------------------переменные х2 ну моrут ссыпат�.с:11 на
один н тот же объект пронэаодноrо кпасса
х2 = у; // По-прежнему допустимо по указанной вьппе причине
System.out.println("x2.a: " + х2.а);
// В классе Х известны только члены класса Х
х2.а = 19; // допустимо
// х2.Ь = 27; // ошибка, так как переменная Ь не является членом класса Х
}
Глава 7. Наследование 269
В данном примере класс У является подклассом х. Следовательно, переменной х2
можно присвоить ссылку на объект типа У.
Следует особо подчеркнуть, что доступ к конкретным членам класса определяется
типом ссылочной переменной, а не типом объекта, на который она ссылается. Это
означает, что если ссылка на объект подкласса присваивается ссылочной переменной
суперкласса, то последняя может быть использована для доступа только к тем частям
данного объекта, которые определяются суперклассом. Именно поэтому переменной х2
недоступен член ь класса У, когда она ссылается на объект этого класса. И в этом есть
своя логика, поскольку суперклассу ничего не известно о тех членах, которые добавлены
в его подкласс. Именно поэтому последняя строка кода в приведенном выше примере
была закомментирована.
Несмотря на то что приведенные выше рассуждения могут показаться несколько отвлеченными,
им соответствует ряд важных практических применений. Одно из них рассматривается
ниже, а другое будет рассмотрено далее в этой главе, когда речь поЙдет о
переопределении методов.
Один из самых важных моментов для присваивания ссылок на объекты подкласса
переменным с типом суперкласса наступает тогда, когда конструкторы вызываются в
иерархии классов. Как вам уже должно быть известно, в классе нередко определяется
конструктор, принимающий объект своего класса в качестве параметра. Благодаря этому
в классе может быть сконструирована копия объекта. Этой особенностью можно воспользоваться
в подклассах, производных от такого класса. В качестве примера рассмотрим
описанные ниже версии классов TwoDShape и Triangle. В оба класса добавлены
конструкторы, принимающие объект своего класса в качестве параметра.
class TwoDShape {
private douЫe width;
private douЫe height;
// Конструктор по умолчанию
TwoDShape() {
width = height = О.О;
// Параметризированный конструктор
TwoDShape(douЫe w, douЫe h) {
width = w;
height = h;
// Создать объект с одинаковыми значениями
// переменных экземпляра width и height
TwoDShape(douЫe х) {
width = height = х;
// Создать один объект на основе другого
TwoDShape ( TwoDShape оЬ) Соэдоть один объект на основе дpyroro
width = ob.width;
height = ob.height;
270 Java 8: руководство для начинающих. 6-е издание
// Методы доступа к переменным экземпляра width и height
douЫe getWidth() { return width; }
douЫe getHeight () { return height; }
void setWidth(douЫe w) { width = w; }
void setHeight(douЫe h) { height = h;
void showDirn() {
Systern.out.println("Шиpинa и высота - " +
width + " и " + height);
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
private String style;
// Конструктор по умолчанию
Triangle () {
super();
style = "none";
// Конструктор класса Triangle
Triangle(String s, douЫe w, douЫe h) {
super(w, h); // вызвать конструктор суперкласса
style = s;
// Конструктор с одним аргументом для построения треугольника
Triangle(douЫe х) {
super(x); // вызвать конструктор суперкласса
style = "закрашенный";
// Создать один объект на основе другого
Triangle(Triangle оЬ) {
super(ob); // передача объекта конструктору класса TwoDShape
style = ob.style; f... 􀀃 􀀃􀀃􀀃􀀃􀀃􀀃􀀃􀀄 - Передать ссЬU1ку на объект Triangle
конструктору кпасса TwoDShape
douЫe area() {
return getWidth() * getHeight() / 2;
void showStyle () {
Systern.out.println("Tpeyгoльник " + style);
class Shapes7 {
puЫic static void main(String args[]) {
Triangle tl
new Triangle ("контурный", В. О, 12. О};
// создать копию объекта tl
Triangle t2 = new Triangle(tl};
System.out.println("Инфopмaция о tl: ");
tl.showStyle();
tl. showDim () ;
Глава 7. Наследование 271
System.out.println("Плoщaдь - " + tl.area(}};
System.out.println();
System.out.println("Инфopмaция о t2: ");
t2.showStyle(};
t2. showDim () ;
System.out.println("Плoщaдь - " + t2.area());
В приведенном выше примере программы объект t2 конструируется на основе
объекта tl, и поэтому они идентичны. Результат выполнения данной программы выглядит
следующим образом.
Информация о tl:
Треугольник контурный
Ширина и высота - В.О и 12.0
Площадь - 48.0
Информация о t2:
Треугольник контурный
Ширина и высота - В.О и 12.0
Площадь - 48.О
Обратите внимание на конструктор класса Triangle, код которого приведен ниже.
// Создать один объект на основе другого
Triangle(Triangle оЬ} {
// передача объекта конструктору класса TwoDShape
super (оЬ);
style = ob.style;
В качестве параметра данному конструктору передается объект Triangle, который
затем с помощью вызова super () передается конструктору TwoDShape, как показано
ниже.
// Создать один объект на основе другого
TwoDShape(TwoDShape оЬ}
width = ob.width;
height = ob.height;
272 Java 8: руководство для начинающих, 6-е издание
Следует заметить, что конструктор TwoDshape () должен получить объект типа
TwoDShape, но конструктор Triangle () передает ему объект типа Triangle. Тем не менее
никаких недоразумений не возникает. Ведь, как пояснялось ранее, ссылочная переменная
суперкласса может ссылаться на объект подкласса. Следовательно, конструктору
TwoDShape () можно передать ссылку на экземпляр подкласса, производного от класса
TwoDShape. Конструктор TwoDShape () инициализирует лишь те части передаваемого
ему объекта подкласса, которые являются членами класса TwoDShape, и поэтому не имеет
значения, содержит ли этот объект дополнительные члены, добавленные в производных
подклассах.
Переопределение методов
В иерархии классов часто присутствуют методы с одинаковой сигнатурой и одинаковым
возвращаемым значением как в суперклассе, так и в подклассе. В этом случае говорят,
что метод суперкласса переопределяется в подклассе. Если переопределяемый метод
вызывается из подкласса, то он всегда будет ссылаться на версию метода, определенную
в подклассе. Версия метода, определенная в суперклассе, скрывается. Рассмотрим в качестве
примера следующую программу.
// Переопределение метода
class А (
int i, j;
A(int а, int Ь) (
i а;
j = Ь;
// Отобразить переменные i и j
void show() (
System.out.println("i и j: " + i + " " + j);
class В extends А (
int k;
В (int а, int Ь, int с) (
super(a, Ь);
k = с;
// Отображение переменной k
void show () (
System.out.println("k: " + k);
class Override (
Донный метод nepeonpeдen11eт метод show ( ) нз кnоссо А
puЫic static void main(String args[]) (
В subOb = new B(l, 2, 3);
subOb.show(); // вызвать метод show() из класса В
Глава 7, Наследование 273
Выполнение этой программы дает следующий результат:
k: 3
Когда метод show ( ) вызывается для объекта типа в, выбирается версия этого метода,
определенная в классе в. Таким образом, версия метода show () в классе в переопределяет
версию одноименного метода, объявленную в классе А.
Если требуется обратиться к исходной версии переопределяемого метода, т.е. той,
которая определена в суперклассе, следует воспользоваться ключевым словом super.
Например, в приведенном ниже варианте класса в из метода show () вызывается версия
того же метода, определенная в суперклассе. При этом отображаются все переменные
экземпляра.
class в extends А {
int k;
В (int а, int Ь, int с) {
super (а, Ь);
k = с;
1,----------Исnоnьэовать кnючевое сnово super
void show () { A/IA 11wэово 11ерснн меrода show (),
оnредеnенной II cynepкnacce А
super.show();
System.out.println("k: " + k);
Если подставить новую версию метода show () в предыдущий вариант программы,
результат ее выполнения изменится и будет иметь следующий вид.
iиj: 12
k: 3
В данном случае super. show () - это вызов метода show (}, определенного в суперклассе.
Переопределение метода происходит только в том случае, если сигнатуры переопределяемого
и переопределяющего методов совпадают. В противном случае происходит
обычная перегрузка методов. Рассмотрим следующую видоизмененную версию предыдущего
примера.
/* Методы с разными сигнатурами не переопределяются,
а перегружаются. */
class А {
int i, j;
A(int а, int Ь) {
i а;
j = Ь;
// Отобразить переменные i и j
void show() {
System.out.println("i и j: " + i + " " + j);
27 4 Java 8: руководство для начинающих. 6-е издание
!/ Создание подкласса путем расширения класса А
class В extends А {
int k;
В (int а, int Ь, int с) {
super (а, Ь);
k = с;
// Перегрузить метод show()
void show(String msg) {
System.out.println(msg + k);
4------Сиrнотуры донноrо метода и метода show () из кnоссо А
class Overload {
отnичоются, поэтому вместо переопредеnения происходит
переrруэко метода
puЫic static void main(String args[J) {
В subOb = new B(l, 2, З);
subOb.show("k: "); !/ вызывается метод show() из класса В
subOb.show(); // вызывается метод show() из класса А
Выполнение этой программы дает следующий результат.
k: 3
i иj: 12
На этот раз в версии метода show () из класса в предусмотрен строковый параметр.
Из-за этого сигнатура данного метода отличается от сигнатуры метода show () из класса
А, для которого параметры не предусмотрены. Поэтому никакого переопределения
метода не происходит.
Поддержка полиморфизма
в переопределяемых методах
Несмотря на то что приведенные выше примеры позволили продемонстрировать
технику использования переопределенных методов, этого недостаточно для того, чтобы
вы смогли в полной мере оценить, какие широкие возможности обеспечиваются этим
механизмом. Действительно, если бы переопределение методов представляло собой не
более чем некий свод соглашений относительно использования пространств имен, то
все, о чем говорилось выше, можно было бы считать хотя и заслуживающей интереса,
но малополезной с точки зрения практики особенностью языка программирования. Однако
это далеко не так. Механизм переопределения методов лежит в основе одного из
наиболее эффективных языковых средств Java - динамической диспетчеризации методов,
обеспечивающей возможность поиска подходящей версии переопределенного метода во
время выполнения программы (а не во время ее компиляции).
Вспомним очень важный принцип: ссылочная переменная суперкласса может
ссылаться на объект подкласса. В Java этот принцип используется для вызова переопределяемых
методов во время выполнения. Если вызов переопределенного метода
Глава 7. Наследование 275
осуществляется с использованием ссылки на суперкласс, то исполняющая система Java
выбирает нужную версию метода на основании типа объекта, на который эта ссылка
указывает в момент вызова. Ссылкам на различные типы объектов будут соответствовать
вызовы различных версий переопределенного метода. Иными словами, во время
выполнения версия переопределенного метода выбирается в зависимости от типа обьекта
ссылки (а не типа ссылочной переменной). Следовательно, если суперкласс содержит
метод, переопределенный в подклассе, будет вызываться метод, соответствующий тому
объекту, на который указывает ссылочная переменная суперкласса.
Ниже приведен простой пример, демонстрирующий использование динамической
диспетчеризации вызовов методов.
// Демонстрация динамической диспетчеризации методов
class Sup {
void who() {
System.out.println("who() в Sup");
class SuЫ extends Sup {
void who() {
System.out.println("who() в SuЫ");
class Sub2 extends Sup {
void who() {
System.out.println("who() в Sub2");
class DynDispDemo {
puЫic static void main(String args[J) {
Sup superOb new Sup();
SuЫ subOЫ new SuЫ();
Sub2 subOb2 new Sub2();
Sup supRef;
supRef = superOb;
supRef.who(}; -4---- 8 каждом нз
этих 811130808
выбор версии
метода supRef = subOЫ; who ( )
supRef.who(); -4---- осущестеnяется
по типу объекта,
на который
указывает ссыnка
supRef = sub0b2;
supRef.who(); ----- во время еыпоnнення
Результат выполнения данной программы выглядит следующим образом.
who () в Sup
who() в SuЫ
who () в Sub2
276 Java 8: руководство для начинающих. 6-е издание
В данном примере программы определяются суперкласс Sup и два ero подкласса
SuЫ и Sub2. В классе Sup объявляется метод who (), переопределяемый в подклассах.
В методе main () создаются объекты типа Sup, SuЫ и Sub2. Там же объявляется переменная
supRef, ссылающаяся на объект типа Sup. Затем переменной supRef в методе
main () поочередно присваиваются ссылки на объекты разного типа, и далее эти ссылки
используются для вызова метода who () . Как следует из результата выполнения данной
программы, вызываемая версия метода who () определяется типом объекта, на который
указывает переменная supRef в момент вызова, а не типом самой переменной.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Переопределяемые методы напоминают виртуальные функции в С++.
Есть ли у них сходство?
ОТВЕТ. Да, есть. Читатели, знакомые с языком С++, заметят, что переопределяемые
методы в Java применяются с той же целью и тем же способом, что и виртуальные
функции в С++.
Для чего нужны переопределенные методы
Как упоминалось выше, переопределяемые методы обеспечивают поддержку полиморфизма
времени выполнения. Большое значение полиморфизма в объектно-ориентированных
программах обусловлено тем, что это позволяет объявить в суперклассе методы,
общие для всех ero подклассов, а в самих подклассах - определить конкретные
реализации всех этих методов или некоторых из них. Переопределение методов - один
из способов, которыми в Java реализуется принцип полиморфизма "один интерфейс -
множество методов".
Залогом успешного применения полиморфизма является, в частности, понимание
тоrо, что суперклассы и подклассы образуют иерархию по степени увеличения специализации.
При продуманной организации суперкласса он предоставляет своему подклассу
все элементы, которыми тот может пользоваться непосредственно. В нем также
определяются те методы, которые должны быть по-своему реализованы в производных
классах. Таким образом, подклассы получают достаточную свободу в определении собственных
методов, реализуя в то же время согласованный интерфейс. Сочетая наследование
с переопределением методов, в суперклассе можно определить общую форму
методов для использования во всех ero подклассах.
Демонстрация механизма переопределения
методов на примере класса ТwoDShape
Для тоrо чтобы стало понятнее, насколько эффективным является механизм переопределения
методовпродемонстрируем ero применение на примере класса TwoDShape.
В приведенных ранее примерах в каждом классе, наследующем класс TwoDShape, определялся
метод area (). Теперь мы знаем, что в этом случае имеет смысл включить метод
area () в состав класса TwoDShape, позволить каждому ero подклассу переопределить
Глава 7. Наследование 2П
этот метод и, в частности, реализовать вычисление площади в зависимости от конкретного
типа геометрической фигуры. Именно такой подход и реализован в приведенном
ниже примере программы. Для удобства в класс TwoDShape добавлено поле name. (Это
упрощает написание демонстрационной программы.)
// Использование динамической диспетчеризации методов
class TwoDShape {
private douЫe width;
private douЫe height;
private String name;
// Конструктор по умолчанию
TwoDShape() {
width = height = О.О;
name = "none";
// Параметризированный конструктор
TwoDShape(douЫe w, douЫe h, String n) {
width = w;
height = h;
name = n;
// Создать объект с одинаковыми значениями
// переменных экземпляра width и height
TwoDShape(douЫe х, String n) {
width = height = х;
name = n;
// Создать один объект на основе другого
TwoDShape(TwoDShape оЬ) {
width = ob.width;
height = ob.height;
name = ob.name;
// Методы доступа к переменным экземпляра width и height
douЫe getWidth() { return width; }
douЫe getHeight () { return height; }
void setWidth(douЫe w) { width = w; }
void setHeight(douЫe h) { height = h;
String getName() { return name; }
void showDim() {
System.out.println("Шиpинa и высота - " +
width + " и " + height);
douЫe area() { 4----------- Метод area () опредепен в кпоссе TwoDShape
System.out.println("Meтoд area() должен быть переопределен");
278 Java 8: руководство для начинающих. 6-е издание
return О.О;
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
private String style;
// Конструктор по умолчанию
Triangle() {
super();
style = "none";
// Конструктор класса Triangle
Triangle(String s, douЫe w, douЫe h) {
super (w, h, "треугольник") ;
style = s;
// Конструктор с одним аргументом для построения треугольника
Triangle(douЫe х) {
super(x, "треугольник"); // вызвать конструктор суперкласса
style = "закрашенный";
// Создать один объект на основе другого
Triangle(Triangle оЬ) {
super(ob); // передать объект конструктору класса TwoDShape
style = ob.style;
// Переопределение метода area() для класса Triangle
douЫe area () { Переопределит􀀓 метод area () дпя кпассо Triangle
return getWidth() * getHeight() / 2;
void showStyle() {
System.out.println("Tpeyгoльник " + style);
// Подкласс для представления прямоугольников,
// производный от класса TwoDShape
class Rectangle extends TwoDShape {
// Конструктор по умолчанию
Rectangle () {
super();
Глава 7. Наследование 279
// Конструктор класса Rectangle
Rectangle(douЫe w, douЫe h) {
super(w, h, "прямоугольник"); // вызвать конструктор суперкласса
// Создать квадрат
Rectangle(douЫe х)
super(x, "прямоугольник"); // вызвать конструктор суперкласса
// Создать один объект на основе другого
Rectangle(Rectangle оЬ) {
super(ob); // передать объект конструктору класса TwoDShape
boolean isSquare()
if(getWidth() getHeight()) return true;
return false;
// Переопределение метода area() для класса Rectangle
douЫe area () { Переоnредепнть метод area () дnА масса Rectangle
return getWidth() * getHeight();
class DynShapes {
puЬlic static void main(String args[]) {
TwoDShape shapes(] = new TwoDShape[5];
shapes(O]
shapes(l]
shapes(2]
shapes(З]
shapes[4]
new
new
new
new
new
Тriаnglе("контурный", 8.0, 12.0);
Rectangle(lO);
Rectangle(lO, 4);
Triangle (7. О) ;
TwoDShape(lO, 20, "фигура");
Нужная аерсн11 метода area ( )
вызывается дnА каждой
rеаметрнческой фнrуры
по отдеnьностн
for(int i=O; i < shapes.length; i++ ) {
􀁪
System.out.println("Oбъeкт - "+ shapes[i] .getName());
System.out.println("Плoщaдь - "+ shapes[i].area());
System.out.println();
Ниже приведен результат выполнения данной программы.
Объект - треугольник
Площадь - 48.0
Объект - прямоугольник
Площадь - 100.0
Объект - прямоугольник
Площадь - 40.О
280 Java 8: руководство для начинающих, 6-е издание
Объект - треугольник
Площадь - 24.5
Объект - фигура
Метод area() должен быть переопределен
Площадь - О.О
Рассмотрим код данной программы более подробно. Теперь, как и предполагалось
при написании программы, метод area () входит в состав класса TwoDShape и переопределяется
в классах Triangle и Rectangle. В классе TwoDShape метод area () играет роль
заполнителя и лишь уведомляет пользователя о том, что этот метод должен быть переопределен
в подклассе. При каждом переопределении метода area () в нем реализуются
средства, необходимые для того типа объекта, который инкапсулируется в подклассе.
Так, если требуется реализовать класс для эллипсов, метод area () придется переопределить
таким образом, чтобы он вычислял площадь этой фигуры.
Рассматриваемая здесь программа имеет еще одну важную особенность. Обратите
внимание на то, что в методе main () геометрические фигуры объявляются как массив
объектов типа TwoDShape. Но на самом деле элементами массива являются ссылки на
объекты Triangle, Rectangle и TwoDShape. Это вполне допустимо. Ведь, как пояснялось
ранее, ссьuючная переменная суперкласса может ссылаться на объект его подкласса.
В этой программе организован перебор элементов массива в цикле и вывод сведений
о каждом объекте. Несмотря на всю простоту данного примера, он наглядно демонстрирует
потенциальные возможности как наследования классов, так и переопределения
методов. Тип объекта, на который указывает ссылочная переменная суперкласса,
определяется во время выполнения, что гарантирует правильный выбор версии переопределенного
метода. Если объект является производным от класса TwoDShape, то для
вычисления его площади достаточно вызвать метод area (). Интерфейс для выполнения
данной операции оказывается общим и не зависит от того, с какой именно геометрической
фигурой приходится иметь дело.
Использование абстрактных классов
Иногда требуется создать суперкласс, в котором определяется лишь самая общая
форма для всех его подклассов, а наполнение ее деталями предоставляется каждому из
этих подклассов. В таком классе определяется лишь суть методов, которые должны быть
конкретно реализованы в подклассах, а не в самом суперклассе. Подобная ситуация возникает,
например, в связи с невозможностью полноценной реализации метода в суперклассе.
Именно такая ситуация была продемонстрирована в варианте класса TwoDShape
из предыдушего примера, где метод area () был определен всего лишь как заполнитель.
Такой метод не вычисляет и не выводит площадь двумерной геометрической формы любого
типа.
Создавая собственные библиотеки классов, вы сможете сами убедиться в том, что
ситуации, в которых невозможно дать полное определение метода в контексте его суперкласса,
встречаются довольно часто. Подобное затруднение разрешается двумя способами.
Один из них, как было показано в предыдущем примере, состоит в том, чтобы
просто вывести предупреждающее сообщение. И хотя в некоторых случаях, например
при отладке, такой способ может быть действительно полезным, в практике программирования
он обычно не применяется. Ведь в суперклассе могут быть объявлены методы,
которые должны быть переопределены в подклассе, чтобы этот класс приобрел
Глава 7. Наследование 281
конкретный смысл. Рассмотрим для примера класс Triangle. Он был бы неполным,
если бы в нем не был переопределен метод area (). В подобных случаях требуется какой-
то способ, гарантирующий, что в подклассе действительно будут переопределены
все необходимые методы. И такой способ в Java имеется. Он состоит в использовании
абстрактного метода.
Абстрактный метод объявляется с использованием модификатора abstract. Абстрактный
метод не имеет тела и поэтому не реализуется в суперклассе. Это означает,
что он должен быть переопределен в подклассе, поскольку его вариант из суперкласса
просто непригоден для использования. Для определения абстрактного метода используется
следующий общий синтаксис:
abstract тип имя(список_параметров);
Как видите, в этом синтаксисе отсутствует тело. Спецификатор abstract может применяться
только к обычным методам, но не к статическим методам и конструкторам.
Класс, содержащий один или несколько абстрактных методов, должен быть также
объявлен как абстрактный с использованием того же спецификатора abstract в объявлении
класса. Поскольку абстрактный класс не определяет реализацию полностью,
у него не может быть объектов. Следовательно, попытка создать объект абстрактного
класса с помощью оператора new приведет к возникновению ошибки во время компиляции.
Подкласс, наследующий абстрактный класс, должен реализовать все абстрактные
методы суперкласса. В противном случае он также должен быть определен как абстрактный.
Таким образом, атрибут abstract наследуется до тех пор, пока не будет достигнута
полная реализация класса.
Используя абстрактный класс, мы можем усовершенствовать рассмотренный ранее
класс TwoDShape. Для неопределенной двумерной геометрической фигуры понятие площади
не имеет смысла, поэтому в приведенной ниже версии программы метод area () и
сам класс TwoDShape объявляются как абстрактные. Это, конечно, означает, что любой
класс, наследующий класс TwoDShape, должен переопределить метод area () .
// Создание абстрактного класса
abstract class TwoDShape
private douЫe width;
private douЫe height;
private String name;
// Конструктор по умолчанию
TwoDShape() {
width = height = О.О;
name = "none";
.----Теперь кnасс TwoDShape яаяяется абстрактным
// Параметризированный конструктор
TwoDShape(douЫe w, douЫe h, String n) {
width = w;
height = h;
name = n;
// Создать объект с одинаковыми значениями
// переменных экземпляра width и height
282 Java 8: руководство для начинающих. 6-е издание
TwoDShape(douЫe х, String n) {
width = height = х;
name = n;
// Создать один объект на основе другого
TwoDShape(TwoDShape оЬ) {
width = ob.width;
height = ob.height;
narne = ob.narne;
// Методы доступа к переменным width и height
douЫe getWidth() { return width; }
douЫe getHeight () { return height; }
void setWidth(douЫe w) { width = w; }
void setHeight(douЫe h) { height = h;
String getNarne () { return narne; }
void showDirn() {
Systern.out.println("Шиpинa и высота - " +
width + " и " + height);
// Теперь метод area() абстрактный
abstract douЫe area () ; Сделать метод area () абстрактным
// Подкласс для представления треугольников,
// производный от класса TwoDShape
class Triangle extends TwoDShape {
private String style;
// Конструктор по умолчанию
Triangle () {
super();
style = "none";
// Конструктор класса Triangle
Triangle(String s, douЫe w, douЫe h) {
super(w, h, "треугольник");
style = s;
// Конструктор с одним аргументом для построения треугольника
Triangle (douЫe х) {
super(x, "треугольник"); // вызвать конструктор суперкласса
style = "закрашенный";
// Создать один объект на основе другого
Triangle(Triangle оЬ) {
Глава 7. Наследование 283
super(ob); // передать объект конструктору класса TwoDShape
style = ob.style;
douЫe area(J (
return getWidth() * getHeight() / 2;
void showStyle() {
System.out.println("Tpeyгoльник " + style);
// Подкласс для представления прямоугольников,
// производный от класса TwoDShape
class Rectangle extends TwoDShape {
// Конструктор по умолчанию
Rectangle () {
super();
// Конструктор класса Rectangle
Rectangle(douЫe w, douЫe h) {
super(w, h, "прямоугольник"); // вызвать конструктор суперкласса
// Создать квадрат
Rectangle(douЫe х)
super(x, "прямоугольник"); // вызвать конструктор суперкласса
// Создать один объект на основе другого
Rectangle(Rectangle оЬ) {
super(ob); // передать объект конструктору класса TwoDShape
boolean isSquare(J
if(getWidth() getHeight()) return true;
return false;
douЫe area() {
return getWidth() * getHeight();
class AЬsShape {
puЬlic static void main(String args[]J {
TwoDShape shapes[] = new TwoDShape[4];
shapes[O] new Тriаnglе("контурный", 8.0, 12.0);
shapes[l] = new Rectangle(lO);
284 Java 8: руководство для начинающих. 6-е издание
shapes[2]
shapes[ЗJ
new Rectangle(lO, 4);
new Triangle(7.0);
for(int i=O; i < shapes.length; i++) {
System.out.println("Oбъeкт - " +
shapes[i].getName() );
System.out.println("Плoщaдь - " + shapes[i] .area());
System.out.println();
Как видно из текста программы, все классы, наследующие класс TwoDShape, должны
переопределять метод area (). Вы можете убедиться в этом самостоятельно, попытавшись
создать подкласс, в котором метод area () не переопределен. В итоrе вы получите
сообщение об ошибке во время компиляции. Разумеется, возможность создания объектной
ссылки типа TwoDShape, что и было сделано в приведенном выше примере программы,
у вас остается, но объявить объект типа TwoDShape вы уже не сможете. Именно
поэтому массив shapes в методе main () сокращен до четырех элементов, а объект типа
TwoDShape для абстрактной двумерной rеометрической фиrуры больше не создается.
И еще одно, последнее замечание. Обратите внимание на то, что в классе TwoDShape
по-прежнему определяются методы showDim () и getName () без модификатора
abstract. Ничеrо предосудительною в этом нет, поскольку допускается (и это часто используется
на практике), чтобы абстрактные классы включали в себя конкретные методы,
к которым подклассы моrут обращаться в своем исходном коде. Переопределению в
подклассах подлежат лишь те методы, которые объявлены как abstract.
Использование ключевого слова :f inal
Механизмы наследования классов и переопределения методов - весьма мощные
средства Java, однако иноrда они моrут становиться для вас помехой. Предположим,
например, что создается класс, в котором инкапсулированы средства управления некоторым
устройством. Данный класс может предоставлять пользователю возможность
инициализировать устройство с использованием конфиденциальной коммерческой информации.
В этом случае пользователи данноrо класса не должны иметь возможность
переопределять метод, ответственный за инициализацию устройства. Для этой цели в
Java предусмотрено ключевое слово final, позволяющее без труда запретить переопределение
метода или наследование класса.
Предотвращение переопределения методов
Для тоrо чтобы предотвратить переопределение метода, в начале ero объявления
нужно указать модификатор final. Переопределять объявленные указанным способом
методы нельзя. Ниже приведен фраrмент кода, демонстрирующий использование ключевоrо
слова final для подобных целей.
class А {
final void meth() {
System.out.println("Этo метод final.");
class В extends А {
Глава 7. Наследование 285
void meth() { // Ошибка! Этот метод не может быть переопределен
System.out.println("Heдoпycтимo!");
Поскольку метод meth () объявлен как final, его нельзя переопределить в классе в.
Если вы попытаетесь сделать это, возникнет ошибка при компиляции программы.
Предотвращение наследования
Предотвратить наследование класса можно, указав в определении класса ключевое
слово final. В этом случае считается, что данное ключевое слово применяется ко всем
методам класса. Очевидно, что не имеет никакого смысла применять ключевое слово
final к абстрактным классам. Ведь абстрактный класс не завершен по определению, и
объявленные в нем методы должны быть реализованы в подклассах.
Ниже приведен пример класса, создание подклассов которого запрещено.
final class А {
// . . .
// Следующее определение класса недопустимо
class В extends А { // Ошибка! Класса А не может иметь подклассов.
// . . .
Как следует из комментариев к данному примеру, наследование классом В класса А
запрещено, так как последний определен как final.
Применение ключевого слова final
к переменным экземпляра
Помимо рассмотренных ранее примеров использования, ключевое слово final можно
применять и к переменным экземпляра. Подобным способом создаются именованные
константы. Если имени переменной предшествует модификатор final, то значение
этой переменной не может быть изменено на протяжении всего времени выполнения
программы. Очевидно, что подобным переменным нужно присваивать начальные значения.
В главе 6 был рассмотрен простой класс ErrorMsg для обработки ошибок. В нем
устанавливается соответствие между кодами ошибок и строками сообщений об ошибках.
Ниже приведен усовершенствованный вариант этого класса, в котором для создания
именованных констант применяется модификатор final. Теперь, вместо того чтобы
передавать методу getErrorMsg () числовое значение, например 2, достаточно указать
при его вызове именованную целочисленную константу DISКERR.
// Возврат объекта типа String
class ErrorMsg {
// Коды ошибок.
// Константы объявляются с помощью ключевого слова final
final int OUTERR = О;
final int INERR = 1;
final int DISKERR = 2;
final int INDEXERR = З;
286 Java 8: руководство для начинающих. 6-е издание
String msgs(] = {
"Ошибка вывода",
"Ошибка ввода",
"Отсутствует место на диске",
"Выход индекса за границы диапазона"
} ;
// Возвратить сообщение об ошибке
String getErrorMsg(int i) {
if(i >=О & i < msgs.length)
return msgs[i];
else
return "Несуществующий код ошибки";
class FinalD {
puЫic static void main(String args[])
ErrorMsg err = new ErrorMsg();
// При вызове метода используются константы,
// объявленные с помощью ключевого слова final
System.out.println(err.getErrorMsg(err.OUTERR));
System.out.println(err.getErrorMsg(err.DISKERR));
Обратите внимание на то, как используются константы в методе main (). Они ямяются
членами класса ErrorMsg, и поэтому для доступа к ним требуется ссылка на объект
этого класса. Разумеется, константы могут быть унаследованы подклассами и непосредственно
доступными в них.
Многие программисты используют имена констант типа final, состоящие полностью
из прописных букв, как это сделано в предыдущем примере. Но это правило не
ямяется строгим и лишь отражает общепринятый стиль программирования.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Могут ли переменные типа final быть статическими? И можно ли использовать
ключевое слово final при объявлении локальных переменных и
параметров методов?
ОТВЕТ. Да, можно. Объявив константу таким образом, вы можете обращаться к
ней по имени класса, не создавая конкретных объектов. Так, если при объямении
констант в классе ErrorMsg указать ключевое слово static, вызов метода
println () в методе main () может приобрести следующий вид:
System.out.println(err.getErrorMsg(ErrorMsg.OUTERR));
System.out.println(err.getErrorMsg(ErrorMsg.DISKERR));
Благодаря объявлению параметра как final предотвращается его изменение в
методе. А если объявить локальную переменную как final, то ей нельзя будет
присвоить значение больше одного раза.
Класс Object
Глава 7. Наследование 287
В Java определен специальный класс Obj ect. По умолчанию он считается суперклассом
всех остальных классов. Иными словами, все классы являются подклассами, производными
от класса Object. Это означает, что ссылочная переменная типа Object может
ссылаться на объект любого класса. Более того, такая переменная также может ссылаться
на массив, поскольку массивы реализованы в виде классов.
В классе Object определены перечисленные ниже методы, доступные в любом объекте.
МетоА Назначение
Object clone () Создает новый объект, аналогичный клонируемому объекту
boolean equals (Object объект) Определяет равнозначность объектов
void finalize () Вызывается перед тем, кок неиспользуемый объект будет уда-
лен системой "сборки мусора"
Class<?> getClass () Определяет класс объекта во время выполнения
int hashCode () Возвращает хеш-код, связанный с вызывающим объектом
void notify () Возобновляет роботу потока, ожидающего уведомления от вызывающего
объекта
void notifyAll () Возобновляет роботу всех потоков, ожидающих уведомления
от вызывающего объекта
String toString () Возвращает символьную строку, описывающую объект
void wai t () Ожидает исполнения другого потока
void wai t ( long миллисекунды)
void wait (long миллисекунды,
int наносекунды)
Методы getClass (), notify (), notifyAll () и wait (} объявлены как final, а
остальные можно переопределять в подклассах. Некоторые из этих методов будут описаны
далее. Два из них - equals () и toString () - заслуживают особого внимания.
Метод equals (} сравнивает два объекта. Если объекты равнозначны, то он возвращает
логическое значение true, иначе - логическое значение false. Метод toString ()
возвращает символьную строку, содержащую описание того объекта, которому принадлежит
этот метод. Он автоматически вызывается в том случае, если объект передается
методу println () в качестве параметра. Во многих классах этот метод переопределяется.
В этом случае описание специально подбирается для конкретных типов объектов,
которые в них создаются.
Обратите внимание на необычный синтаксис, описывающий значение, возвращаемое
методом getClass (}. Это обобщенный тип. С помощью обобщений в Java можно
указывать в качестве параметра тип данных, используемый в классе или методе. Более
подробно обобщения рассматриваются в главе 13.
288 Java 8: руководство для начинающих. 6-е издание
;􀀂 Вопросы н упражнения для самоnрQверкн
1. Имеет ли суперкласс доступ к членам подкласса? Имеет ли подкласс доступ к
членам суперкласса?
2. Создайте подкласс Circle, производный от класса TwoDShape. В нем должен
быть определен метод area (), вычисляющий площадь круга, а также конструктор
с ключевым словом super для инициализации членов, унаследованных от класса
TwoDShape.
3. Как предотвратить обращение к членам суперкласса из подкласса?
4. Опишите назначение и два варианта использования ключевого слова super.
5. Допустим, имеется следующая иерархия классов.
class Alpha { ...
class Beta extends Alpha
Class Gamrna extends Beta
В каком порядке вызываются конструкторы этих классов при создании объекта
класса Gamma?
6. Переменная ссылки на суперкласс может указывать на объект подкласса. Объясните,
почему это важно и как это связано с переопределением методов?
7. Что такое абстрактный класс?
8. Как предотвратить переопределение метода? И как предотвратить наследование
класса?
9. Объясните, каким образом механизмы наследования, переопределения методов и
абстрактные классы используются для поддержки полиморфизма.
10. Какой класс является суперклассом всех остальных классов?
11. Класс, который содержит хотя бы один абстрактный метод, должен быть объявлен
абстрактным. Верно или не верно?
12. Какое ключевое слово следует использовать для создания именованной константы?
Глава 8
Пакеты и интерфейсы
290 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
jj;· Использование пакетов
􀂓 Влияние пакетов на доступ к членам класса
􀂔 Использование модификатора доступа protected
􀂕 Импорт пакетов
􀂖 Стандартные пакеты Java
􀂗 Основные положения об интерфейсах
􀂘 Реализация интерфейсов
􀂙 Использование интерфейсных ссылок
'1i, Переменные интерфейса
<t Наследование интерфейсов
,н Создание методов по умолчанию и статических методов интерфейсов
э та глава посвящена рассмотрению двух очень важных инновационных средств Java:
пакетов и интерфейсов. Пакет - это группа логически связанных классов. Пакеты
помогают лучше организовать код и обеспечивают дополнительный уровень инкапсуляции.
Интерфейс определяет набор методов, которые должны присутствовать в классе.
В самом интерфейсе эти методы не реализуются, поэтому он представляет собой чисто
логическую конструкцию. Пакеты и интерфейсы предоставляют дополнительную возможность
для более рациональной организации программ и контроля их структуры.
Пакеты
Иногда взаимозависимые части программ удобно объединять в группы. В Java для
этой цели предусмотрены пакеты. Во-первых, пакет предоставляет механизм объединения
взаимосвязанных частей программы. При обращении к классам, входЯщим в пакет,
указывается имя пакета. Таким образом, пакет предоставляет средства для именования
коллекции классов. И во-вторых, пакет является частью механизма управления доступом
в Java. Классы могут быть объявлены как закрытые для всех пакетов, кроме того, в
который они входят. Следовательно, пакет предоставляет также средства для инкапсуляции
классов. Рассмотрим все эти средства более подробно.
Как правило, при именовании класса для него выделяется имя в пространстве имен.
Пространство имен определяет область объявлений. В Java нельзя присваивать двум
классам одинаковые имена из одного и того же пространства имен. Иными словами, в
пределах пространства имен каждый класс должен обладать уникальным именем. В примерах
программ, представленных в предыдущих главах, по умолчанию использовалось
глобальное пространство имен. Это удобно для небольших программ, но по мере увеличения
объема кода могут возникнуть конфликты имен. В крупных программах бывает
нелегко выбрать уникальное имя для класса. Более того, при использовании библиотек
и кода, написанного другими программистами, приходится принимать специальные
Глава 8. Пакеты и интерфейсы 291
меры для предотвращения конфликтов имен. Для разрешения подобных затруднений
служат пакеты, позволяющие разделить пространство имен на отдельные области. Если
класс определен в пакете, то имя пакета присоединяется к имени класса, в результате
чего исключается конфликт между двумя классами, имеющими одинаковые имена, но
принадлежащими к разным пакетам.
Пакет обычно содержит логически связанные классы, и поэтому в Java определены
специальные права доступа к содержимому пакета. Так, в пакете можно определить
один код, доступный другому коду из того же самого пакета, но недоступный из других
пакетов. Это позволяет создавать автономные группы связанных вместе классов и делать
операции в них закрытыми.
Определение пакета
Каждый класс в Java относится к тому или иному пакету. Если оператор package отсутствует
в коде, то используется глобальный пакет, выбираемый по умолчанию. Пакет
по умолчанию не обладает именем, что упрощает его применение. Именно поэтому в
рассмотренных до сих пор примерах программ не нужно было беспокоиться о пакетах.
Но если пакет по умолчанию подходит для очень простых программ, служащих в качестве
примера, то для реальных приложений он малопригоден. Как правило, для разрабатываемого
кода приходится определять один или несколько пакетов.
Для создания пакета достаточно поместить оператор package в начало файла с исходным
кодом программы на Java. В результате классы, определенные в этом файле, будут
принадлежать указанному пакету. А поскольку пакет определяет пространство имен,
имена классов, содержащихся в файле, войдут в это пространство имен как составные
его части.
Общая форма оператора package выглядит следующим образом:
package имя_пакета;
Например, приведенная ниже строка кода определяет пакет mypack:
package mypack;
Для управления пакетами в Java используется файловая система, в которой для хранения
содержимого каждого пакета выделяется отдельный каталог. Например, файлы с
расширением . class, содержащие классы и объявленные в пакете mypack, будут храниться
в каталоге mypack.
Подобно другим именам в Java, имена пакетов зависят от регистра символов. Это означает,
что каталог, предназначенный для хранения пакета, должен обладать именем, в
точности совпадающим с именем пакета. Если у вас возникнут затруднения при опробовании
примеров программ, представленных в этой главе, проверьте соответствие имен
пакетов именам каталогов. Пакеты всегда именуются прописными буквами.
В разных файлах могут содержаться одинаковые операторы package. Этот оператор
лишь определяет, к какому именно пакету должны принадлежать классы, код которых
содержится в данном файле, и не запрещает другим классам входить в состав того же
самого пакета. Как правило, пакеты реальных программ распространяются на большое
количество файлов.
В Java допускается создавать иерархию пакетов. Для этого достаточно разделить имена
пакетов точками. Ниже приведена общая форма оператора package для определения
многоуровневого пакета.
package пакет_l. пакет_2. пакет_З ... пакет_N;
292 Java 8: руководство для начинающих. 6-е издание
Очевидно, что для поддержки иерархии пакетов следует создать аналогичную иерархию
каталогов.
package alpha.beta.gamrna;
Классы, содержащиеся в данном пакете, должны храниться в структуре каталогов
... /alpha/beta/gamma, rде многоточие обозначает путь к каталогу alpha.
Поиск пакета и переменная среды CLASSPATH
Как пояснялось выше, иерархия каталогов пакетов должна отражать иерархию пакетов.
В связи с этим возникает важный вопрос: как исполняющая система Java узнает, где
искать созданные пакеты? Ответ на этот вопрос следует разделить на три части. Во-первых,
по умолчанию исполняющая система Java обращается к текущему рабочему каталогу.
Так, если поместить пакет в подкаталоге текущего каталога, он будет там наЙден.
Во-вторых, один или несколько путей к каталогам можно задать в качестве значения
переменной среды CLASSPATH. И в-третьих, при вызове интерпретатора java и компилятора
javac из командной строки можно указать параметр -classpath, а также путь к
каталогам с классами.
Рассмотрим в качестве примера следующее определение пакета:
package mypack
Для того чтобы программа могла найти пакет mypack, должно быть выполнено одно
из трех условий: программа должна быть запущена из каталога, содержащего пакет
mypack; в переменной среды CLASSPATH должен храниться полный путь к каталогу с пакетом
mypack; при запуске программы интерпретатору java должен быть передан параметр
-classpath и указан путь к каталогу с пакетом mypack.
Вам будет проще всего работать с примерами программ, представленных далее, если
вы создадите в текущем каталоге, используемом для разработки программ, структуру
каталогов, предназначенных для хранения пакетов, а затем разместите файлы с расширением
. class в соответствующих каталогах. Далее следует выполнять программы из
каталога, выбранного для разработки.
Во избежание каких-либо осложнений все файлы с расширениями . j ava и . class
рекомендуется хранить в том каталоге, который выделен для содержащего их пакета.
Кроме того, каждый исходный файл следует компилировать из того каталога, который
находится по иерархии выше каталога с пакетом.
Простой пример применения пакета
С учетом всего вышесказанного напишем небольшую программу, использующую пакет,
а затем запустим ее на выполнение. Эта программа предназначена для создания простой
базы данных книг. Классы этой программы будут содержаться в пакете bookpack.
// Простая программа, демонстрирующая применение пакетов
package bookpack; Этот файп входнт в пакет bookpack
class Book { ....--------- Сnедоватеnьно, кnасс Book nринадnежит пакету bookpack
private String title;
private String author;
private int pubDate;
Book(String t, String а, int d) {
title = t;
Глава 8. Пакеты и интерфейсы 293
author = а;
pubDate = d;
void show() {
System.out.println(title);
System.out.println(author);
System.out.println(pubDate);
System.out.println();
class BookDemo { Класс BookDemo таКJКе принадnежнт пакету bookpack
puЫic static void main(String args[]) {
Book books[] = new Book[5];
books[OJ new Book("Java: А Beginner's Guide",
"Schildt", 2014);
books[l) new Book("Java: The Complete Reference",
"Schildt", 2014);
books[2] new Book ( "The Art of Java",
"Schildt and Holmes", 2003);
books[З] new Book ( "Red Storm Rising",
"Clancy", 1986);
books[4] new Book ( "On the Road",
"Kerouac", 1955);
for(int i=O; i < books.length; i++) books[i] .show();
Присвойте файлу с приведенным выше исходным кодом имя BookDemo. java и поместите
его в каталог bookpack.
Скомпилируйте этот файл, Это можно сделать, введя в командной строке следующую
команду:
javac bookpack/BookDemo.java
После этого попробуйте выполнить скомпилированную программу, введя в командной
строке следующую команду:
java bookpack.BookDemo
Не забывайте, что для нормального выполнения указанных выше команд текущим
должен быть каталог, являющийся родительским по отношению к каталогу bookpack.
(Для компиляции и запуска программы из какого-нибудь другого каталога вам придется
указать путь к каталогу bookpack, используя один из двух других описанных выше способов
обращения к каталогам с пакетами.)
Теперь классы BookDemo и Book принадлежат к пакету bookpack. Это означает, что
при вызове интерпретатора нельзя ограничиваться передачей ему только имени класса
BookDemo. Приведенная ниже команда не будет выполнена:
java BookDemo
Перед именем класса BookDemo следует непременно указать имя его пакета, как показано
выше.
294 Java 8: руководство для начинающих. 6-е издание
Пакеты и доступ к членам классов
В предыдущих главах бьmи представлены основные механизмы управления доступом,
в том числе модификаторы private и puЬlic. И теперь самое время продолжить
обсуждение вопросов управления доступом к членам классов. Ведь и пакеты принимают
участие в управлении доступом.
Область действия члена класса определяется указываемым модификатором доступа:
private, puЫic или protected, хотя модификатор может и отсутствовать. На формирование
области действия оказывает также влияние принадлежность класса к тому
или иному пакету. Таким образом, область действия члена класса определяется его доступностью
как в классе, так и в пакете. Столь сложный, многоуровневый подход к
управлению доступом позволяет установить достаточно обширный набор прав доступа.
В табл. 8.1 описаны разные уровни доступа к членам классов. Рассмотрим каждый из
них в отдельности.
Таблица 8.1. Уровни доступа к членам классов
Закрытый Член, доступный Защищенный Открытый
член по умолчанию член член
Доступен в том же классе Да Да Да Да
Доступен из подкласса Нет Да Да Да
в том же пакете
Доступен из пюбого класса Нет Да Да Да
в том же пакете
Доступен из подкласса Нет Нет Да Да
в пюбом пакете
Доступен из всякого класса Нет Нет Нет Да
в любом пакете
Если модификатор доступа явно не указан для члена класса, он доступен только в своем
пакете, но не за его пределами. Следовательно, член класса, для которого не задан модификатор
доступа, является открытым в текущем пакете и закрытым за его пределами.
Члены класса, объявленные как открытые (puЬlic), доступны из классов, принадлежащих
любым пакетам. На доступ к ним никаких ограничений не накладывается.
А члены класса, объявленные как закрытые (pri vate), доступны только для членов
того же самого класса. Другие классы, даже принадлежащие к тому же самому пакету, не
могут воздействовать на них. И наконец, члены класса, объявленные как защищенные
(protected), доступны для классов, находящихся в том же самом пакете, а также для
подклассов данного класса, независимо от того, каким пакетам эти подклассы принадлежат.
Правила доступа, приведенные в табл. 8.1, распространяются только на члены классов.
Сами же классы могут быть объявлены как открытые или же доступные по умолчанию.
Если в определении класса присутствует ключевое слово puЫic, то он доступен
для других классов. Отсутствие модификатора доступа означает, что класс доступен
только классам, находящимся в том же самом пакете. На классы, объявленные как открытые,
накладывается следующее единственное ограничение: имя файла, в котором
находится исходный код класса, должно совпадать с именем класса.
Пример доступа к пакету
Глава 8. Пакеты и интерфейсы 295
В рассмотренном выше примере классы Book и BookDemo находились в одном и том
же пакете, поэтому при организации доступа из класса BookDemo к классу Book не возникало
никаких затруднений. По умолчанию все члены класса имеют право обращаться
к членам других классов из того же самого пакета. Если бы класс Book находился
в одном пакете, а класс BookDemo - в другом, ситуация оказалась бы немного сложнее.
В этом случае доступ к классу Book по умолчанию был бы запрещен. Для того чтобы
сделать класс Book доступным для других пакетов, в код программы нужно внести
три изменения. Во-первых, сам класс Book должен быть объявлен открытым (puЫic).
Это позволит обращаться к нему за пределами пакета bookpack. Во-вторых, конструктор
класса должен быть также объявлен открытым. И наконец, модификатор доступа
puЬlic следует указать также перед методом show (). Благодаря этому конструктор и
метод show () станут доступными за пределами пакета bookpack. Следовательно, для
использования класса Book в классах, принадлежаших другим пакетам, его следует объявить
так, как показано ниже.
// Класс Book, видоизмененный для открытого доступа
package bookpack;
puЬlic class Book
private String title;
private String author;
private int pubDate;
4---- Класс Book и ero чnеиы доnжны быть объявлены открытыми,
чтобы их можно быnо нсnоnьзовать в друrих nакетах
// Теперь конструктор стал открытым
puЬlic Book(String t, String а, int d) {
title = t;
author = а;
pubDate = d;
// Теперь метод стал открытым
puЫic void show() {
System.out.println(title);
System.out.println(author);
System.out.println(pubDate);
System.out.println();
Для того чтобы воспользоваться классом Book в другом пакете, нужно применить
оператор import, который рассматривается в следующем разделе, либо указать полное
имя класса, т.е. предварять имя класса именем пакета. Ниже приведен пример класса
UseBook, содержащегося в пакете bookpackext. Для обращения к классу Book в нем используется
полное имя этого класса.
// Данный класс принадлежит пакету bookpackext
package bookpackext;
// Использовать класс Book из пакета bookpack
class UseBook {
puЫic static void main(String args[]) {
296 Java 8: руководство для начинающих. 6-е издание
bookpack.Book books[J = new bookpack.Book[5]; -------Передименемкпасса
books[O] new bookpack.Book("Java: А Beginner's Guide", ВооkукозwвоетСJ1нмя
"Schildt", 2011); пакетоЬооkрасk
books[l] new bookpack.Book("Java: The Complete Reference",
"Schildt", 20011);
books[2] new bookpack. Book ( "The Art of Java",
books [3]
"Schildt and Holmes", 2003);
new bookpack. Book ( "Red Storm Rising",
"Clancy", 1986);
books[4] new bookpack.Book("On the Road",
"Kerouac", 1955);
for(int i=O; i < books.length; i++) books[i].show();
Обратите внимание на то, что при каждом обращении к классу Book перед ним указывается
имя пакета bookpack. Если бы здесь не использовалось полное имя, то при
компиляции класса UseBook класс Book не бьm бы найден.
Защищенные члены классов
Начинающие программисты иногда неправильно пользуются модификатором доступа
protected. Как пояснялось ранее, переменные и методы, объявленные защищенными
(protected), доступны д11я классов, находящихся в том же самом пакете, а также д11я
подклассов данного класса, независимо от того, каким пакетам эти подклассы принадлежат.
Иными словами, член класса, объявленный как protected, доступен д11я подклассов,
но защищен от доступа за пределами пакета.
Для того чтобы стало понятнее назначение модификатора доступа protected, рассмотрим
следующий пример. Сначала изменим класс Book, объявив его переменные экземпляра
защищенными, как показано ниже.
// Объявление защищенными переменных экземпляра в классе Book
package BookPack;
puЫic class Book
// При объявлении этих переменных использован
// модификатор доступа protected
protected String title;
J- protected String author; Теперь эти переменнwе
d . Ь
protecte int pu Date; объявпенw кок protected
puЬlic Book(String t, String а, int d) {
title = t;
author = а;
pubDate = d;
puЬlic void show() {
System.out.println(title);
System.out.println(author);
System.out.println(pubDate);
Глава 8. Пакеты и интерфейсы 297
System.out.println(};
Далее создадим подкласс ExtBook класса Book, а также класс ProtectDemo, в котором
будет использоваться класс ExtBook. В классе ExtBook содержится поле, предназначенное
для хранения названия издательства, а также несколько методов доступа. Оба
класса принадлежат к пакету bookpackext. Их исходный код приведен ниже.
// Пример использования модификатора protected
package bookpackext;
class ExtBook extends bookpack.Book
private String puЬlisher;
puЬlic ExtBook(String t, String а, int d, String р} (
super(t, а, d};
puЫisher = р;
puЫic void show(} {
super.show(};
System.out.println(puЫisher};
System.out.println(};
puЫic String getPuЬlisher(} { return puЫisher;
puЫic void setPuЬlisher(String р} { puЫisher = р;
/* Следующие операторы допустимы, поскольку подклассы имеют
право доступа к членам класса, объявленным защищенными. */
puЫic String getTitle(} { return title; }
puЫic void setTitle (String t} { title = t; }
puЫic String getAuthor(} { return author; }
puЫic void setAuthor(String а} { author = а;
puЫic int getPubDate(} { return pubDate; }
4----Дocryn к чnеном кnоссо Book
разрешен дn• nодкnоссов
puЬlic void setPubDate(int d} { pubDate = d; }
class ProtectDemo {
puЬlic static void main(String args[]}
ExtBook books[] = new ExtBook[5];
books[OJ
books [1]
books[2]
books[ЗJ
books[4]
new ExtBook("Java: А Beginner's Guide",
"Schildt", 2007, "Osborne/McGraw-Hill"};
new ExtBook ( "Java: The Complete Reference",
"Schildt", 2007, "Osborne/McGraw-Hill"};
new ExtBook ( "The Art of Java",
"Schildt and Holmes", 2003,
"Osborne/McGraw-Hill"};
new ExtBook ( "Red Storm Rising",
"Clancy", 1986, "Putnam"};
new ExtBook("On the Road",
"Kerouac", 1955, "Viking"};
298 Java 8: руководство для начинающих. 6-е издание
//
)
for(int i=O; i < books.length; i++) books(i] .show();
// Поиск книг по автору
System.out.println("Showing all books Ьу Schildt.");
for(int i=O; i < books.length; i++)
if(books[i] .getAuthor() == "Schildt")
System.out.println(books[i] .getTitle());
books[OJ .title = "test title"; // Ошибка: доступ запрещен!
f'------Достуn к защищенным nоnям кпасса Book возможен тоnько из ero nодкпоссоа
Обратите внимание на код класса ExtBook. В связи с тем, что класс ExtBook является
подклассом, производным от класса Book, он имеет доступ к защищенным членам
класса Book. Это правило действует, несмотря на то что класс ExtBook находится в другом
пакете. Следовательно, он может обращаться непосредственно к переменным экземпляра
title, author и pubDate, что и было использовано при написании методов
доступа. В то же время доступ к этим переменным экземпляра из класса ProtectDemo
запрещен, поскольку класс ProtectDemo не является подклассом, производным от класса
Book. Так, если удалить комментарии в приведенной ниже строке кода, то программа
не будет скомпилирована.
// books[OJ.title = "test title"; // Ошибка: доступ запрещен!
Импорт пакетов
При использовании класса из другого пакета необходимо задавать его полное имя,
т.е. указывать перед именем класса имя пакета. Такой подход был принят в предыдущем
примере. Но его соблюдение очень быстро становится утомительным для программирования,
и особенно это касается глубоко вложенных пакетов. Язык Java был разработан
программистами для программистов, и поэтому не удивительно, что в нем было предусмотрено
более удобное средство доступа к содержимому пакета: оператор import. Используя
этот оператор, можно упростить обращение к одному или нескольким членам
пакета, чтобы пользоваться ими непосредственно, не указывая явно имя пакета.
Ниже приведена общая форма оператора import.
import имя_пакета.имя_класса;
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Известно, что в языке С++ также имеется модификатор protected.
Подобен ли он одноименному модификатору доступа в языке Java?
ОТВЕТ. Подобен, но не совсем. В языке С++ ключевое слово protected разрешает
доступ к переменной или методу из подклассов, а для остальных классов
данный член класса остается закрытым. В Java таким способом создается член
класса, который может быть доступен из любого класса в пределах пакета, но в
других пакетах доступ сохраняется только для подклассов данного класса. Это
отличие следует иметь в виду при переносе кода из С++ в Java и обратно.
Глава 8. Пакеты и интерфейсы 299
Если требуется импортировать все содержимое пакета, вместо имени класса следует
указать звездочку(*). Ниже приведены примеры обеих форм записи оператора import.
import mypack.MyClass
import mypack.*;
В первом случае из пакета mypack импортируется класс MyClass, а во втором - все
классы из данного пакета. В исходном файле программы на Java операторы import
должны следовать сразу же после оператора package (если таковой имеется) и перед
определением классов.
С помощью оператора import можно организовать доступ к пакету bookpack и воспользоваться
классом Book, не прибегая к его полному имени. Оператор import, разрешающий
данное затруднение, помещается в начало того файла, где требуется доступ к
классу Book, в следующем виде:
import bookpack.*;
Например, так будет выглядеть исходный код класса UseBook, в котором используется
механизм импорта пакетов.
// Использование ключевого слова import
package bookpackext;
import bookpack. *; Импорт кпоссо bookpack
// Использовать класс Book из пакета bookpack
class UseBook {
puЬlic static void main(String args[J)
Book books[] = new Book[5]; ----Теперь к кпоссу Book можно обращаться
непосредственно, без указоння ero nолноrо нменн
books[OJ
books[l]
books[2]
books[З]
books[4]
new Book("Java: А Beginner's Guide",
"Schildt", 2007);
new Book("Java: The Complete Reference",
"Schildt", 2007);
new Book("The Art of Java",
"Schildt and Holmes", 2003);
new Book("Red Storm Rising",
"Clancy", 1986);
new Book ( "On the Road",
"Kerouac", 1955);
for(int i=O; i < books.length; i++} books[i].show();
Как видите, теперь нет нужды предварять имя класса Book именем пакета.
Библиотечные классы Java,
содержащиеся в пакетах
Как пояснялось ранее, в Java определено большое количество стандартных классов,
доступных всем программам. Библиотека классов Java обычно называется Java API
(Application Programming Interface - прикладной программный интерфейс). Классы,
300 Java 8: руководство для начинающих. 6-е издание
входящие в состав библиотеки Java API, хранятся в пакетах. На верхней ступени иерархии
находится пакет java. В его состав входят подчиненные пакеты, включая и перечисленные
ниже.
Пакет Описание
java. lang Содержит большое количество классов общего назначения
java · io Содержит классы, предназначенные для поддержки ввода-вывода
j ava · net Содержит классы, предназначенные для поддержки сетевого взаимодействия
j ava. applet Содержит классы, предназначенные для создания апплетов
j ava. awt Содержит классы, обеспечивающие поддержку набора инструментальных средств
Abstract Window Toolkit
В примерах программ, представленных в этой книге, с самого начала использовался
пакет java. lang. Помимо прочего, он содержит класс System (к нему не раз приходилось
обращаться при вызове метода println () ). Пакет j ava. lang примечателен тем,
что он автоматически включается в каждую программу на Java, в то время как содержимое
других пакетов приходится импортировать явным образом. Некоторые из этих
пакетов будут рассмотрены в последующих главах.
Интерфейсы
Иногда в объектно-ориентированном программировании полезно определить, что
именно должен делать класс, но не как он должен это делать. Примером тому может
служить упоминавшийся ранее абстрактный метод. В абстрактном методе определяются
возвращаемый тип и сигнатура метода, но не предоставляется его реализация. А в подклассе
должна быть обеспечена своя собственная реализация каждого абстрактного метода,
определенного в его суперклассе. Таким образом, абстрактный метод определяет
интерфейс, но не реализацию метода. Конечно, абстрактные классы и методы приносят
известную пользу, но положенный в их основу принцип может быть развит далее. В Java
предусмотрено разделение интерфейса класса и его реализации с помощью ключевого
слова interface.
С точки зрения синтаксиса интерфейсы подобны абстрактным классам. Но в интерфейсе
ни у одного из методов не должно быть тела. Это означает, что в интерфейсе вообще
не предоставляется никакой реализации. В нем указывается только, что именно
следует делать, но не как это делать. Как только интерфейс будет определен, он может
быть реализован в любом количестве классов. Кроме того, в одном классе может быть
реализовано любое количество интерфейсов.
Для реализации интерфейса в классе должны быть предоставлены тела (т.е. конкретные
реализации) методов, описанных в этом интерфейсе. Каждому классу предоставляется
полная свобода в определении деталей своей собственной реализации интерфейса.
Следовательно, один и тот же интерфейс может быть реализован в двух классах по-разному.
Тем не менее в каждом из них должен поддерживаться один и тот же ряд методов
данного интерфейса. А в том коде, где известен такой интерфейс, могут использоваться
объекты любого из этих двух классов, поскольку интерфейс для всех этих объектов остается
одинаковым. Благодаря поддержке интерфейсов в Java может быть в полной мере
реализован главный принцип полиморфизма: "один интерфейс - множество методов".
Глава 8. Пакеты и интерфейсы 301
Интерфейсы объявляются с помощью I<Лючевого слова interface. Ниже приведена
упрощенная форма объявления интерфейса.
доступ interface имя {
возвращаемый_ тип имя метода_ 1 (список_ параметров) ;
возвращаемый_ тип имя_ метода_ 2 (список_ параметров) ;
тип переменная_] значение;
тип переменная_2 = значение;
/ / . . .
возвращаемый_тип имя_метода_N(список_параметров);
тип переменная_N = значение;
Здесь доступ обозначает тип доступа, который определяется модификатором доступа
puЫic или вообще не указывается. Если модификатор доступа отсутствует, применяется
правило, предусмотренное по умолчанию, т.е. интерфейс считается доступным
только членам своего пакета. Ключевое слово puЫic указывает на то, что интерфейс
может использоваться в любом другом пакете. (Код интерфейса, объявленного как
puЫic, должен храниться в файле, имя которого совпадает с именем интерфейса.)
А имя интерфейса может быть любым допустимым идентификатором.
При объявлении методов указываются их сигнатуры и возвращаемые типы. Эти методы
являются, по существу, абстрактными. Как упоминалось выше, реализация метода
не может содержаться в составе интерфейса. Каждый I<Ласс, в определении которого
указан интерфейс, должен реализовать все методы, объявленные в интерфейсе. Методы,
объявленные в интерфейсе, неявно считаются открытыми (puЫic).
Переменные, объявленные в интерфейсе, не являются переменными экземпляра.
Они неявно обозначаются I<Лючевыми словами puЫic, final и static и обязательно
подлежат инициализации. По сути, они являются константами. Ниже приведен пример
определения интерфейса. Предполагается, что этот интерфейс должен быть реализован
в I<Лассе, где формируется последовательный ряд числовых значений.
puЫic interface Series {
int getNext(); // возвратить следующее по порядку число
void reset(); // сброс
void setStart(int х); // установить начальное значение
Этот интерфейс объявляется открытым (puЬlic), а следовательно, он может быть реализован
в I<Лассе, принадлежащем любому пакету.
Реализация интерфейсов
Определенный однажды интерфейс может быть реализован одним или несколькими
I<Лассами. Для реализации интерфейса в определение I<Ласса следует ввести I<Лючевое
слово implements, а затем определить методы, объявленные в интерфейсе. Ниже приведена
общая форма реализации интерфейса в I<Лассе.
class имя класса extends суперкласс implements интерфейс {
// тело класса
302 Java 8: руководство для начинающих. 6-е издание
Если в классе должно быть реализовано несколько интерфейсов, то имена интерфейсов
указываются через запятую. Разумеется, ключевое слово extends и имя суперкласса
указывать не обязательно.
Реализуемые методы интерфейса должны быть объявлены открытыми (puЫic).
А сигнатура реализованного метода должна полностью соответствовать сигнатуре,
объявленной в составе интерфейса. Ниже приведен пример класса ByTwos, реализующего
рассмотренный ранее интерфейс Series. В этом классе формируется последовательный
ряд числовых значений, каждое из которых на два больше предыдуmеrо.
// Реализация интерфейса Series
class ByTwos implements Series {
int start;
int val;
ByTwos ()
start = О;
val = О;
Реоnизует интерфейс Series
puЫic int getNext()
val += 2;
return val;
puЫic void reset()
start = О;
val = О;
puЫic void setStart (int х) {
start = х;
val = х;
Обратите внимание на то, что методы getNext () , reset () и setStart () объявлены
открытыми. Это нужно сделать непременно, поскольку любой метод интерфейса неявно
считается открытым для доступа. Ниже приведен пример программы, демонстрирующий
применение класса ByTwos.
class SeriesDemo {
puЫic static void main(String args[]) {
ByTwos оЬ = new ByTwos();
for(int i=O; i < 5; i++)
System.out.println(11 Cлeдyющee значение: 11 +
ob.getNext());
System.out.println( 11 \nCбpoc11 );
ob.reset();
for(int i=O; i < 5; i++)
System.out.println(11 Cлeдyющee значение: 11 +
ob.getNext());
Глава 8. Пакеты и интерфейсы 303
System.out.println{"\nHaчaльнoe значение: 100");
ob.setStart(lOO);
for(int i=O; i < 5; i++)
System.out.println("Cлeдyющee значение: " +
ob.getNext());
Выполнение этой программы дает следующий результат.
Следующее значение: 2
Следующее значение: 4
Следующее значение: 6
Следующее значение: 8
Следующее значение: 10
Сброс
Следующее значение: 2
Следующее значение: 4
Следующее значение: 6
Следующее значение: 8
Следующее значение: 10
Начальное значение: 100
Следующее значение: 102
Следующее значение: 104
Следующее значение: 106
Следующее значение: 108
Следующее значение: 110
Класс, реализующий интерфейс, может содержать дополнительные переменные и
методы, что вполне допустимо. Более того, именно так в большинстве случаев и поступают
те, кто программирует на Java. Например, в приведенную ниже версию класса
ByТwos добавлен метод getPrevious () , возвращающий предыдущее числовое значение.
// Реализация интерфейса Series и добавление метода getPrevious()
class ByTwos implements Series {
int start;
int val;
int prev;
ByTwos () {
start = О;
val = О;
prev = -2;
puЫic int getNext()
prev val;
val += 2;
return val;
puЫic void reset()
start = О;
304 Java 8: руководство для начинающих. 6-е издание
val = О;
prev = -2;
puЫic void setStart(int х) {
start = х;
val = х;
prev = х - 2;
int getPrevious()
return prev;
4----Добоменне метода, не объ1вnенноrо в интерфейсе Series
Обратите внимание на то, что для добавления метода getPrevious () пришлось изменить
реализацию методов, объявленных в интерфейсе Series. Но сам интерфейс не
претерпел никаких изменений. Эти изменения не видны за пределами класса и не влияют
на его использование. В этом и состоит одно из преимуществ интерфейсов.
Как пояснялось ранее, интерфейс может быть реализован каким угодно количеством
классов. В качестве примера ниже приведен код класса ByThrees. Этот класс
формирует последовательный ряд числовых значений, каждое из которых на три больше
предыдущего.
// Еще одна реализация интерфейса Series
class ByThrees implements Series { 4----Друrой способ реаnиэаци1 интерфейса Series
int start;
int val;
ByThrees ()
start = О;
val = О;
puЫic int getNext()
val += 3;
return val;
puЫic void reset()
start = О;
val = О;
puЫic void setStart(int х) {
start = х;
val = х;
Следует также иметь в виду, что если в определении класса имеется ключевое слово
implements, но он не реализует все методы указанного интерфейса, то этот класс должен
быть объявлен абстрактным (abstract). Объект такого класса создать нельзя, но
Глава 8. Пакеты и интерфейсы 305
ero можно использовать в качестве суперкласса, а завершить реализацию методов интерфейса
в ero подклассах.
Применение интерфейсных ссылок
Возможно, вы будете несколько удивлены, узнав, что в Java допускается объявлять
переменные ссылочного интерфейсного типа, т.е. переменные, хранящие ссылки на
интерфейс. Такая переменная может ссылаться на любой объект, реализующий ее тип
интерфейса. При вызове метода для объекта по интерфейсной ссылке выполняется вариант
этого метода, реализованный в классе данного объекта. Этот процесс аналогичен
применению ссылки на суперкласс для доступа к объекту подкласса, как пояснялось в
главе 7.
Ниже приведен пример программы, демонстрирующий применение интерфейсной
ссылки. По такой ссылке в данной программе будут вызываться методы, принадлежащие
классам ByТwos и ByТhrees.
!/ Использование интерфейсных ссылок
class ByTwos implements Series (
int start;
int val;
ByTwos ()
start = О;
val = О;
puЫic int getNext()
val += 2;
return val;
puЫic void reset()
start = О;
val = О;
puЫic void setStart(int х) (
start = х;
val = х;
class ByThrees implements Series (
int start;
int val;
ByThrees ()
start = О;
val = О;
306 Java 8: руководство для начинающих. 6-е издание
puЫic int getNext()
val += 3;
return val;
puЫic void reset()
start = О;
val = О;
puЫic void setStart ( int х) {
start = х;
val = х;
class SeriesDemo2 {
puЫic static void main(String args[])
ByTwos twoOb = new ByTwos();
ByThrees threeOb = new ByThrees();
Series оЬ;
for (int i=O; i < 5; i++) {
оЬ = twoOb;
System.out.println("Cлeдyющee значение ByTwos: " +
ob.getNext());
оЬ = threeOb;
System.out.println("Cлeдyющee значение Next ByThrees: " +
ob.getNext());
Доступ
к объекту
по интерфейс·
ной ссыпке
В методе main () переменная оЬ объявляется как ссылка на интерфейс Series. Это
означает, что в данной переменной может храниться ссылка на любой объект, реализующий
интерфейс Series. В данном случае в переменной оЬ сохраняется ссылка на
объекты twoOb и threeOb, т.е. в разные моменты времени переменная представляет собой
ссылку на объект класса ByTwos или же на объект класса ByThrees. Оба эти класса
реализуют интерфейс Series. Переменная ссылки на интерфейс содержит сведения
только о методах, объявленных в этом интерфейсе. Следовательно, переменная оЬ не
может быть использована для доступа к любым другим переменным и методам, которые
поддерживаются в объекте, но не объявлены в интерфейсе.
Упражнение 8.1
:··················· .. ············:
\ ICharQ.java )
: .. 􀀆􀀇􀀈.􀀉􀀊􀀋.:.􀀌. .􀀅 .􀀆.􀀇 ... :
Соэдание интерфейса дnя очереди
Для того чтобы продемонстрировать истинные возможности интерфейсов,
обратимся к конкретному практическому примеру. В предыдущих
главах был создан класс Queue, реализующий простую очередь
фиксированного размера для хранения символов. Но обеспечить функционирование
очереди можно разными способами. В частности, очередь может быть фиксированного
размера или "растущей", линейной (т.е. переполняться по достижении верхней границы
выделенной памяти) или кольцевой (в этом случае при удалении символов из
Глава 8. Пакеты и интерфейсы 307
очереди освобождается место для новых элементов). Кроме того, очередь может быть
реализована на базе массива, связного списка, двоичного дерева и т.п. Как бы ни была
реализована очередь, интерфейс для нее остается неизмененным, т.е. методы put () и
get () , определяющие этот интерфейс, выполняют одинаковые действия независимо от
внуrренней организации очереди. А поскольку интерфейс для очереди не зависит от ее
конкретной реализации, его нетрудно определить, а конкретные детали разработать в
каждой реализации очереди по отдельности.
В этом проекте предстоит сначала создать интерфейс для очереди, хранящей символы,
а затем реализовать его тремя способами. Во всех трех реализациях для хранения
символов будет использоваться массив. Одна из очередей будет линейной и фиксированного
размера, т.е. такая же, как и реализованная ранее. Вторая очередь будет кольцевой.
В кольцевой очереди по достижении границ массива значения индексов будуr
автоматически изменяться таким образом, чтобы указывать на начало очереди. Таким
образом, в кольцевую очередь можно будет поместить любое количество элементов,
но при условии своевременного удаления элементов, включенных в нее ранее. И наконец,
третья очередь будет динамической. Это означает, что ее размеры будут увеличиваться
по мере необходимости. Поэтапное описание процесса создания программы
приведено ниже.
1. Создайте файл ICharQ. java и поместите в него следующее определение интерфейса.
// Интерфейс для очереди символов
puЫic interface ICharQ {
// Поместить символ в очередь
void put(char ch);
// Извлечь символ из очереди
char get();
Как видите, этот интерфейс чрезвычайно прост: в нем объявлены только два метода.
Эти методы должны быть определены в любом классе, реализующем интерфейс
ICharQ.
2. Создайте файл IQDemo. java.
3. Начните создавать программу в файле IQDemo. j ava, добавив в него следующий
код класса FixedQueue.
// Класс, реализующий очередь фиксированного размера
// для хранения символов
class FixedQueue implements ICharQ {
private char q[]; // массив для хранения элементов очереди
private int putloc, getloc; // индексы вставляемых и
// извлекаемых элементов
// Создать пустую очередь заданного размера
puЫic FixedQueue(int size) {
q = пеw char[size+l]; // выделить память для очереди
putloc = getloc = О;
// Поместить символ в очередь
puЫic void put(char ch) {
308 Java 8: руководство для начинающих. 6-е издание
if(putloc==q.length-1)
Systern.out.println(" - Очередь заполнена");
return;
putloc++;
q[putloc] ch;
// Извлечь символ из очереди
puЫic char get() {
if (getloc == putloc) {
Systern.out.println(" - Очередь пуста");
return (char) О;
getloc++;
return q[getloc];
Эта реализация интерфейса ICharQ выполнена на основе уже знакомого вам
класса Queue, разработанного в главе 5.
4. Добавьте в файл IQDemo. j ava приведенный ниже класс CircularQueue. Он реализует
кольцевую очередь для хранения символов.
// Кольцевая очередь
class CircularQueue irnplernents ICharQ {
private char q[]; // массив для хранения элементов очереди
private int putloc, getloc; // индексы вставляемых и
// извлекаемых элементов
// Создать пустую очередь заданного размера
puЫic CircularQueue{int size) {
q = new char[size+l]; // выделить память для очереди
putloc = getloc = О;
// Поместить символ в очередь
puЫic void put(char ch) {
/* Очередь считается полной, если индекс putloc на единицу
меньше индекса getloc или если индекс putloc указывает
на конец массива, а индекс getloc - на его начало */
if(putloc+l==getloc I
((putloc== q.length-1) & (getloc== O))) {
Systern.out.println(" - Очередь заполнена");
return;
putloc++;
if(putloc==q.length) putloc
q[putloc] = ch;
О; // перейти в начало массива
// Извлечь символ из очереди
puЫic char get() {
Глава 8. Пакеты и интерфейсы 309
if(getloc == putloc) {
System.out.println(" - Очередь пуста");
return (char) О;
getloc++;
if(getloc==q.length) getloc
return q[getloc];
О; // вернуться в начало очереди
В кольцевой очереди повторно используются элементы массива, освобожденные
при извлечении символов. Поэтому в нее можно помещать неограниченное
число элементов (при условии, что элементы, помещенные в очередь ранее, будут
вовремя удалены). Отслеживание границ массива производится очень просто
(достаточно обнулить индекс по достижении верхней границы), хотя условие достижения
этих границ может, на первый взгляд, показаться не совсем понятным.
Кольцевая очередь переполняется не тогда, когда достигается верхняя граница
массива, а тогда, когда число элементов, ожидающих извлечения из очереди, становится
слишком большим. Поэтому в методе put () проверяется ряд условий с
целью определить момент переполнения очереди. Как следует из комментариев к
коду, очередь считается заполненной, если индекс putloc оказывается на единицу
меньше индекса getloc или если индекс putloc указывает на конец массива,
а индекс getloc - на его начало. Как и прежде, очередь считается пустой, если
индексы getloc и putloc равны. С целью упрощения соответствующих проверок
размер создаваемого массива на единицу превышает размер очереди.
5. Введите в файл IQDemo. java приведенный ниже код класса DynQueue. Этот код
реализует динамическую, или "растущую", очередь, т.е. такую очередь, размеры
которой увеличиваются, когда в ней не хватает места для символов.
// Динамическая очередь
class DynQueue implements ICharQ {
private char q[]; // массив для хранения элементов очереди
private int putloc, getloc; // индексы вставляемых и
// извлекаемых элементов
// Создать пустую очередь заданного размера
puЫic DynQueue(int size)
q = new char[size+l]; // выделить память для очереди
putloc = getloc = О;
// Поместить символ в очередь
puЬlic void put(char ch) {
if(putloc==q.length-1) {
// увеличить размер очереди
char t[] = new char[q.length * 2];
// Скопировать элементы в новую очередь
for(int i= O; i < q.length; i++)
t[i] = q[i];
31 О Java 8: руководство для начинающих, 6-е издание
q t;
putloc++;
q[putloc] ch;
// Извлечь символ из очереди
puЬlic char get() {
if (getloc == putloc) {
System.out.println(" - Очередь пуста");
return (char) О;
getloc++;
return q[getloc];
В данной реализации при попытке поместить в заполненную очередь еще один
элемент создается новый массив, размеры которого в два раза превышают размеры
исходного, текущее содержимое очереди копируется в новый массив, а ссылка
на него помещается в переменную q.
6. Для того чтобы продемонстрировать все три реализации интерфейса ICharQ, добавьте
в файл I QDemo . j а v а приведенный ниже класс, в котором для доступа ко всем
трем очередям используется переменная, хранящая ссьmку на интерфейс ICharQ.
// Демонстрация трех реализаций интерфейса ICharQ
class IQDemo {
puЫic static void main(String args[])
FixedQueue ql = new FixedQueue(lO);
DynQueue q2 = new DynQueue(5);
CircularQueue qЗ = new CircularQueue(lO);
ICharQ iQ;
char ch;
int i;
iQ = ql;
// Поместить ряд символов в очередь фиксированного размера
for(i=O; i < 10; i++)
iQ.put((char) ('А' + i));
// Отобразить содержимое очереди
System.out.print("Coдepжимoe фиксированной очереди: ");
for (i=O; i < 10; i++) {
ch = iQ.get();
System.out.print(ch);
System.out.println();
iQ = q2;
// Поместить ряд символов в динамическую очередь
for(i=O; i < 10; i++)
iQ.put((char) ('Z' - i));
Глава 8. Пакеты и интерфейсы 311
// Отобразить содержимое очереди
System.out.print("Coдepжимoe динамической очереди: ");
for (i=O; i < 10; i++) {
ch = iQ.get();
System.out.print(ch);
System.out.println();
iQ = qЗ;
// Поместить ряд символов в кольцевую очередь
for(i=O; i < 10; i++)
iQ.put((char) ('А' + i));
// Отобразить содержимое очереди
System.out.print("Coдepжимoe кольцевой очереди: ");
for (i=O; i < 10; i++) {
ch = iQ.get();
System.out.print(ch);
System.out.println();
// Поместить больше символов в кольцевую очередь
for(i=lO; i < 20; i++)
iQ.put((char) ('А' + i));
// Отобразить содержимое очереди
System.out.print("Coдepжимoe кольцевой очереди: ");
for (i=O; i < 10; i++) {
ch = iQ.get();
System.out.print(ch);
System.out.println("\nCoxpaнeниe и использование данных" +
" кольцевой очереди");
// Поместить символы в кольцевую очередь и извлечь их оттуда
for (i=O; i < 20; i++) {
iQ.put ( (char) ( 'А' + i));
ch = iQ. get () ;
System.out.print(ch);
7. Выполнение этой программы дает следующий результат.
Содержимое фиксированной очереди: ABCDEFGHIJ
Содержимое динамической очереди: ZYXWVUTSRQ
Содержимое кольцевой очереди: ABCDEFGHIJ
Содержимое кольцевой очереди: KLMNOPQRST
Сохранение и использование данных кольцевой очереди
ABCDEFGHIJKLMNOPQRST
312 Java 8: руководство для начинающих. 6-е издание
8. А теперь попробуйте самостоятельно поупражняться в организации очередей.
Создайте кольцевой вариант очереди DynQueue. Добавьте в интерфейс ICharQ метод
reset ( ) , сбрасывающий очередь в исходное состояние. Создайте статический
метод для копирования содержимого одной очереди в другую.
Переменные в интерфейсах
Как упоминалось выше, в интерфейсах могут объявляться переменные, но они неявно
принимают модификаторы puЫic, static и final. На первый взгляд, такие переменные
находят лишь ограниченное применение, но это не совсем так. В крупных
программах часто используются константы, описывающие размеры массивов, граничные
и специальные значения и т.п. Для крупных программ обычно создается несколько
исходных файлов, а следовательно, требуется удобный способ доступа к константам из
любого файла. В Java решить эту задачу помогают интерфейсы.
Для того чтобы определить набор общедоступных констант, достаточно создать интерфейс,
в котором объявлялись бы не методы, а только нужные константы. Каждый
класс, которому требуются эти константы, должен просто "реализовать" интерфейс,
чтобы сделать константы доступными. Ниже приведен простой пример, демонстрирующий
такой подход.
// Интерфейс, содержащий только константы
interface IConst {
int MIN = О; i n t МАХ = 1 О ; J-Это асе константы
String ERRORМSG = "Ошибка диапазона";
class IConstD implements IConst (
puЫic static void rnain(String args[])
int nurns[] = new int[МAX];
for(int i=MIN; i < 11; i++)
if(i >= МАХ) Systern.out.println(ERRORМSG);
else {
nurns [i] = i;
Systern.out.print(nurns[i] + " ");
ПРИМЕЧАНИЕ
Относительно целесообразности испольэо1юния интерфейсов для определения констант ведутся
дискуссии. Эта техника описана эдесь исключительно ради полноты рассмотрения.
Глава 8. Пакеты и интерфейсы 313
Наследование интерфейсов
Один интерфейс может наследовать другой, для чего служит ключевое слово
extends. Синтаксис наследования интерфейсов ничем не отличается от того, который
используется для наследования классов. Если класс реализует один интерфейс, наследующий
другой интерфейс, в нем следует определить все методы, объявленные в интерфейсах
по всей цепочке наследования. Ниже приведен пример, демонстрирующий
наследование интерфейсов.
// Наследование интерфейсов
interface А {
void rnethl();
void rneth2();
// Интерфейс В содержит методы rnethl() и rneth2(), а
// кроме того, в него добавляется метод rnethЗ()
interface В extends А { Интерфейс В наспедует интерфейс А
void rnethЗ();
// Этот класс должен реализовать все методы,
// объявленные в интерфейсах А и В
class MyClass irnplernents В {
puЬlic void rnethl() {
Systern.out.println("Peaлизaция метода rnethl() .");
puЫic void rneth2() {
Systern.out.println("Peaлизaция метода rneth2() .");
puЫic void rnethЗ() {
Systern.out.println("Peaлизaция метода rnethЗ() .");
class IFExtend {
puЫic static void rnain(String arg[J) {
MyClass оЬ = new MyClass();
ob.rnethl();
ob.rneth2();
ob.rnethЗ();
В качестве эксперимента можете удалить из класса MyClass реализацию метода
methl () . Это приведет к ошибке при компиляции. Как упоминалось выше, в каждом
классе, реализующем интерфейс, должны быть определены все методы, объявленные в
интерфейсе, в том числе те, которые бьши унаследованы от других интерфейсов.
И хотя пакеты и интерфейсы редко используются в примерах программ, представленных
в этой книге, следует все же иметь в виду, что эти языковые средства являются
З 14 Java 8: руководство для начинающих. 6-е издание
важной частью Java. Практически во всех реальных программах и аплетах, написанных
на Java, применяются пакеты, а многие классы реализуют интерфейсы. Поэтому данные
языковые средства необходимо знать, чтобы уметь пользоваться ими в практике программирования
на Java.
Методы интерфейсов, используемые
по умолчанию
Как ранее уже отмечалось, до появления JDK 8 интерфейс не мог определять никакую
реализацию вообще. Это означает, что во всех предьщущих версиях Java методы,
специфицируемые интерфейсом, могли быть только абстрактными, т.е. не имели тела.
Все наши предыдущие обсуждения относятся к интерфейсам именно такой традиционной
формы. Выпуск JDK 8 расширил функциональность интерфейсов, добавив возможность
определения в них методов, используемых по умолчанию. Благодаря этому интерфейс
теперь может включать реализации методов, которые будут использоваться по
умолчанию, если другие реализации не предоставляются. Иными словами, теперь метод
интерфейса может иметь тело, а не быть исключительно абстрактным. В процессе разработки
этой идеи для данного средства использовалось также другое название - метод
расширения, так что вам, скорее всего, будут встречаться оба эти термина.
Основным мотивом для введения методов по умолчанию было стремление обеспечить
возможность расширения интерфейсов без разрушения существующего кода (нарушения
его работоспособности). Вспомните, что для каждого из методов, определенных
в интерфейсе, должна в обязательном порядке предоставляться реализация. В прошлом,
если в популярный, широко используемый интерфейс добавлялся новый метод, это
приводило к разрушению существующего кода ввиду отсутствия в нем соответствующей
реализации. Введение механизма методов по умолчанию разрешает эту проблему, позволяя
предоставлять реализацию метода, которая будет использована в том случае, если
никакая иная реализация не бьmа предоставлена явно. Таким образом, возможность использования
методов по умолчанию обеспечивает сохранение работоспособности существующего
кода, даже если интерфейс бьm обновлен.
Среди других причин, обусловивших введение методов по умолчанию, было желание
иметь возможность определять методы интерфейса, являющиеся, по сути, необязательными
и используемыми лишь при определенных условиях. Например, интерфейс
может определять группу методов, воздействующих на последовательности элементов.
Один из этих методов может называться remove ( ) и предназначаться для удаления
элементов последовательности. В то же время, если интерфейс предназначен для
поддержки не только изменяемых, но и фиксированных последовательностей, то метод
remove () является, по существу, опциональным, поскольку в случае фиксированных
последовательностей необходимости в его использовании не возникает. До этого класс,
реализующий фиксированную последовательность элементов, должен бьш определять
пустую реализацию метода remove () , даже если этот метод и не требуется. Теперь же
для метода remove () в интерфейсе может быть определена реализация по умолчанию,
которая либо вообще ничего не делает, либо выводит сообщение об ошибке. Предоставление
такой реализации позволяет избавиться от необходимости определять собственную
"заглушку" для метода remove () в классе, используемом для фиксированных
последовательностей. Благодаря этому реализация метода remove () классом становится
необязательной.
Глава 8. Пакеты и интерфейсы 315
Важно подчеркнуть, что введение методов по умолчанию никоим образом не влияет
на одно из фундаментальных свойств интерфейсов - интерфейсу по-прежнему
запрещено иметь переменные экземпляра. Таким образом, ключевое различие межцу
интерфейсом и классом состоит в том, что класс может поддерживать информацию о
состоянии, а интерфейс - не может. Кроме того, создание собственных экземпляров
интерфейса, как и ранее, невозможно. Интерфейсы должны реализовываться классами.
Поэтому, даже несмотря на то, что с выходом JDK 8 у интерфейсов появилась возможность
определять методы, используемые по умолчанию, экземпляры можно создавать
только посредством реализации интерфейсов классами.
И последнее замечание. Методы по умолчанию представляют собой специальное
средство, обеспечивающее дополнительные возможности. Создаваемые вами интерфейсы
будут использоваться главным образом дпя того, чтобы указать, что именно должно
делаться, а не предоставлять способ реализации этих намерений. Вместе с тем включение
в интерфейс методов, используемых по умолчанию, обеспечивает дополнительную
гибкость в процессе разработки.
Основные сведения о методах по умолчанию
Определение метода по умолчанию в интерфейсе следует той же схеме, что и обычное
определение метода в классе. Отличие состоит лишь в том, что объявление метода
начинается с ключевого слова default. Рассмотрим, например, следующий простой интерфейс.
puЫic interface MyIF {
// Объявление "обычного" метода интерфейса, которое НЕ включает
// определение реализации по умолчанию
int getUserID();
// Объявление метода по умолчанию, включающее его реализацию
default int getAdminID() {
return 1;
В интерфейсе MyIF объявляются два метода. Для первого из них, getUserID (), используется
стандартное объявление метода интерфейса, не содержащее определение какой-
либо реализации. Объявление второго метода, getAdminID, включает определение
реализации по умолчанию. В данном случае она всего лишь возвращает целочисленное
значение 1. Обратите внимание на наличие модификатора default в начале объявления.
Это общее правило: дпя определения метода по умолчанию следует предварить его
объявление словом default.
Поскольку определение метода getAdminID () включает определение реализации по
умолчанию, класс, реализующий интерфейс, не обязан переопределять данный метод.
Иными словами, если реализующий класс не предоставит собственной реализации метода,
будет использоваться реализация, определенная по умолчанию. Например, приведенное
ниже определение класса MyIFirnp, является вполне допустимым.
// Реализация интерфейса MyIF
class MyIFimp implements MyIF {
// Реализации подлежит лишь метод getUserID() интерфейса My!F.
// Делать это для метода getAdminID() необязательно, поскольку
316 Java 8: руководство для начинающих, 6-е издание
// при необходимости может быть использована его реализация,
// заданная по умолчанию.
puЬlic int getUserID () {
return 100;
Следующий код создает экземпляр класса MyIFimp и использует его для вызова обоих
методов, getUserID () и getAdminID ().
// Использование интерфейсного метода по умолчанию
class DefaultMethodDemo {
puЫic static void main(String args[])
MyIFimp obj = new MyIFimp();
// Вызов метода getUserID() возможен, поскольку он явно
// реализован классом MyIFimp
System.out.println("Идeнтификaтop пользователя " +
obj.getUserID());
// Вызов метода getAdminID() также возможен, поскольку
// предоставляется его реализация по умолчанию
System.out.println("Идeнтификaтop администратора: " +
obj.getAdminID());
Выполнив программу, вы получите следующий вывод.
Идентификатор пользователя: 100
Идентификатор администратора: 1
Как видите, программа автоматически использовала реализацию метода
getAdminID (), заданную по умолчанию. Классу MyIFimp необязательно было реализовывать
данный метод. Таким образом, реализация метода getAdminID () является опциональной.
(Разумеется, если класс должен возвращать другое значение идентификатора,
собственная реализация метода станет необходимой.)
Класс вполне может - и эта практика является общеупотребительной - определить
собственную реализацию метода, определенного по умолчанию в интерфейсе. В качестве
примера рассмотрим приведенный ниже класс MyIFimp2, переопределяющий метод
getAdminID ()
class MyIFimp2 implements MyIF {
// Предоставляются реализации обоих методов -
// getUserID() и getAdminID()
puЫic int getUserID() {
return 100;
puЫic int getAdminID()
return 42;
Теперь при вызове метода getAdminID () будет возвращено значение, отличное от
того, которое задано по умолчанию.
Глава 8. Пакеты и интерфейсы З 17
Практический пример использования метода по умолчанию
Предыдущее рассмотрение интерфейсных методов, определяемых по умолчанию,
позволило продемонстрировать технику их применения, однако не показало, насколько
они могут быть полезными, на примерах, более приближенных к практике. С этой
целью вновь обратимся к примеру интерфейса Series, рассмотренного ранее. Предположим,
что интерфейс завоевал широкую популярность и от него зависит работа многих
программ. Также допустим, что согласно результатам исследования во многих случаях
в реализации интерфейса Series добавлялся метод, который возвращает массив,
содержащий следующие n элементов ряда. Учитывая это обстоятельство, вы решаете
усовершенствовать интерфейс, включив в него такой метод, которому присваиваете имя
getNextArray () и который объявляете следующим образом:
int [] getNextArray(int n)
где n - количество извлекаемых элементов. До появления методов, используемых по
умолчанию, добавление этого метода в интерфейс Series нарушило бы работоспособность
существующего кода, поскольку оказалось бы, что в имеющихся реализациях
определение этого метода отсутствует. В то же время предоставление для нового метода
версии, используемой по умолчанию, позволяет это безболезненно сделать. Рассмотрим,
как это работает.
Иногда при добавлении в существующий интерфейс метода, используемого по умолчанию,
в его реализации предусматривают всего лишь вывод сообщения об ошибке. Такой
подход требуется использовать тогда, когда для метода по умолчанию невозможно
предоставить реализацию, одинаково пригодную для всех возможных случаев его использования.
По существу, код подобных методов может быть произвольным. Но иногда
удается определить метод по умолчанию, который будет способен выполнять полезные
функции в любом случае. Именно таким является наш метод getNextArray ().
Поскольку интерфейс Series уже содержит требование, чтобы класс реализовал метод
getNext (), версия по умолчанию getNextArray () может использовать его. Таким образом,
можно предложить следующий способ реализации новой версии интерфейса
Series, которая включает используемый по умолчанию метод getNextArray ().
// Усовершенствованная версия интерфейса Series, которая включает
// используемый по умолчанию метод getNextArray()
puЫic interface Series (
int getNext(); // вернуть следующее число в ряду
// Возвратить массив, который содержит n элементов,
// располагающихся в ряду вслед за текущим элементом
default int[] getNextArray(int n) (
int[] vals = new int[n];
for(int i=O; i < n; i++) vals[i]
return vals;
void reset(); // сброс
getNext();
void setStart(int х); // установка начального значения
З 18 Java 8: руководство для начинающих. 6-е издание
Обратите внимание на то, как реализован метод getNextArray (). Поскольку метод
getNext () являлся частью первоначальной спецификации интерфейса Series, он должен
предоставляться любым классом, реализующим данный интерфейс. Следовательно,
метод getNextArray () может использовать его для получения следующих n элементов
ряда. В результате любой класс, реализующий усовершенствованную версию интерфейса
Series, сможет использовать метод getNextArray () в том виде, как он есть, без какой-
либо необходимости переопределять его. Поэтому работоспособность кода не будет
нарушена. Разумеется, класс всегда может предоставить собственную реализацию метода
getNextArray (), если это окажется необходимым.
Как показывает предыдущий пример, двумя главными преимушествами использования
методов по умолчанию являются следующие:
􀂣 это позволяет обновлять интерфейсы, не нарушая при этом работоспособности
существующего кода;
l'f' это дает возможность предоставлять дополнительную функциональность и при
этом не требовать реализации "заглушек" классами, которым эта функциональность
не нужна.
Множественное наследование
Ранее уже отмечалось, что множественное наследование классов в Java не поддерживается.
Теперь, когда в состав интерфейсов могут входить методы по умолчанию,
вполне закономерно возникает вопрос: а нельзя ли обойти это ограничение с помощью
интерфейсов? На этот вопрос следует дать отрицательный ответ. Вспомните о ключевом
различии, существующем между классами и интерфейсами: класс может поддерживать
состояние (посредством переменных экземпляра), а интерфейс - не может.
И все же механизм методов по умолчанию открывает некоторые возможности, которые
обычно связывают с понятием множественного наследования. Например, класс может
реализовать два интерфейса. Если каждый из этих интерфейсов предоставляет методы
для использования по умолчанию, то определенные аспекты поведения наследуются
сразу от обоих интерфейсов. Таким образом, методы по умолчанию в какой-то мере
способны обеспечивать поддержку множественного наследования поведения. Нетрудно
догадаться, что в подобных ситуациях возможно возникновение конфликтов имен.
Предположим, например, что класс MyClass реализует два интерфейса: Alpha и
Beta. Что произойдет в том случае, если оба интерфейса определяют метод reset () и
оба предоставляют его реализацию по умолчанию? Какую версию метода будет использовать
класс MyClass: Alpha или Beta? А что если класс MyClass предоставит собственную
реализацию данного метода? Для ответа на эти и другие вопросы в Java определен
набор правил, позволяющих разрешать подобные конфликты.
Во-первых, реализация, определенная в классе, всегда имеет более высокий приоритет
по сравнению с методами по умолчанию, определенными в интерфейсах. Таким образом,
если MyClass переопределяет метод по умолчанию reset (), вводя собственную
версию этого метода, то использоваться будет именно эта версия. Сказанное относится
и к тем ситуациям, в которых класс MyClass реализует как интерфейс Alpha, так и Beta.
В этом случае реализация метода, предлагаемая классом MyClass, переопределяет обе
реализации, заданные по умолчанию.
Во-вторых, в тех случаях, когда класс наследует два интерфейса, определяющие
метод по умолчанию с одним и тем же именем, но не переопределяет этот метод,
Глава 8. Пакеты и интерфейсы З 19
возникает ошибка. В рассматриваемом примере ошибка возникнет в том случае, если
класс MyClass наследует интерфейсы Alpha и Beta, но не переопределяет метод
reset ().
Если же один интерфейс наследует другой, причем оба они определяют метод по
умолчанию с одним и тем же именем, то приоритет имеет версия метода, определенная
в наследующем интерфейсе. Поэтому, в продолжение рассмотрения нашего примера,
если интерфейс Beta расширяет интерфейс Alpha, то использоваться будет версия метода
reset () , определенная в интерфейсе Beta.
На заданную по умолчанию реализацию можно ссылаться явно, используя ключевое
слово super. Общая форма подобного обращения приведена ниже.
имя_интерфейса.sиреr.имя_метода{)
Так, если из интерфейса Beta необходимо обратиться к методу по умолчанию интерфейса
Alpha, то для этого можно воспользоваться следующей инструкцией:
Alpha.super.reset();
Использование статических методов интерфейса
В JDK 8 была добавлена еще одна новая возможность, а именно: теперь интерфейс
может определять один или несколько статических методов. Как и статические методы
класса, статические методы, определенные в интерфейсе, можно вызывать без привлечения
объектов. Таким образом, чтобы вызвать статический метод, ни реализация интерфейса,
ни создание его экземпляра не требуются. Для вызова статического метода
следует указать его имя интерфейса, а после него, используя точечную нотацию, имя
самого метода. Ниже приведена общая форма такого вызова:
имя_ интерфейса. имя_ статического _метода () ;
Обратите внимание на сходство этой формы с формой вызова статического метода
класса.
Ниже приведен пример добавления статического метода getUniversalID (), возвращающего
О, в рассмотренный ранее интерфейс MyIF.
puЫic interface MyIF {
// Объявление обычного метода интерфейса, которое НЕ включает
// определение реализации по умолчанию
int getUserID();
// Объявление метода по умолчанию, включающее его реализацию
default int getAdminID() {
return 1;
// Объявление статического метода интерфейса
static int getUniversalID()
return О;
А вот пример вызова метода getUni versalID ():
int uID = MyIF.getUniversalID();
320 Java 8: руководство для начинающих. 6-е издание
Как уже упоминалось, никакой реализации интерфейса MyIF или создания его экземпляра
для вызова метода getUni versalID () не требуется, поскольку он статический.
Следует также отметить, что статические методы интерфейса не наследуются ни реализующим
его классом, ни производными интерфейсами.
Последнние замечания относительно
пакетов и интерфейсов
В примерах, включенных в данную книгу, пакеты и интерфейсы используются редко,
однако оба этих средства являются важной частью Java. Практически любая реальная
программа, которую вам придется написать на Java, будет находиться в каком-либо пакете.
Точно так же можно не сомневаться, что многие из ваших программ будут включать
в себя интерфейсы. Поэтому уверенная работа с интерфейсами будет играть очень
важную роль в вашей практической деятельности.
\"􀀂'
Вопросы и упражнения для сомопроверки
1. Используя код, созданный в упражнении 8.1, поместите в пакет qpack интерфейс
ICharQ и все три реализующих его класса. Оставив класс IQDemo в пакете, используемом
по умолчанию, покажите, как импортировать и использовать классы
из пакета qpack.
2. Что такое пространство имен? Почему так важна возможность его разделения на
отдельные области в Java?
3. Содержимое пакетов хранится в ______ _
4. В чем отличие доступа, определяемого ключевым словом protected, от доступа
по умолчанию?
5. Допустим, классы, содержащиеся в одном пакете, требуется использовать в другом
пакете. Какими двумя способами можно добиться этого?
6. "Один интерфейс - множество методов" - таков главный принцип Java. Какое
языковое средство лучше всего демонстрирует этот принцип?
7. Сколько классов могут реализовать один и тот же интерфейс? Сколько интерфейсов
может реализовать класс?
8. Может ли один интерфейс наследовать другой?
9. Создайте интерфейс для класса Vehicle, рассмотренного в главе 7, назвав его
IVehicle.
10. Переменные, объявленные в интерфейсе, неявно принимают модификаторы
static и final. Какие преимущества это дает?
11. Пакет по сути является контейнером для классов. Верно или не верно?
12. Какой стандартный пакет автоматически импортируется в любую программу на
Java?
13. Какое ключевое слово используется для объявления в интерфейсе метода по
умолчанию?
14. Возможно ли, начиная с JDK 8, определение статического метода интерфейса?
Глава 8. Пакеты и интерфейсы 321
15. Предположим, что интерфейс ICharQ, представленный в упражнении 8 .1, получил
широкое распространение в течение нескольких лет. В какой-то момент вы
решили добавить в него метод reset () , который будет использоваться для сброса
очереди в ее исходное пустое состояние. Как это можно осуществить, не нарушая
работоспособности сушествующего кода, в случае использования комплекта
JDK8?
16. Как можно вызвать статический метод интерфейса?

Глава 9
Обработка исключений
324 Java 8: руководство дnя начинающих. 6-е издание
В этой главе ...
􀃗 Представление об иерархии исключений
,i}!: Ключевые слова try и catch
􀃘 Необработанные исключения
􀃙· Множественные операторы catch
if. Перехват исключений подклассов
􀃚· Вложенные блоки try
􀃛 Генерирование исключений
fi Класс ThrowaЫe
􀃜 Ключевое слово finally
􀃝 Ключевое слово throws
i#J Встроенные классы исключений Java
􀃞 Создание специальных классов исключений
в этой главе речь пойдет об обработке исключительных ситуаций, или, как говорят,
- исключений. Исключение - это ошибка, возникающая в процессе выполнения
программы. Используя подсистему обработки исключений Java, можно управлять
реакцией программы на появление ошибок во время выполнения. Средства обработки
исключений в том или ином виде имеются практически во всех современных языках
программирования. Можно смело утверждать, что в Java подобные инструментальные
средства отличаются большей гибкостью, более понятны и удобны в применении по
сравнению с большинством других языков программирования.
Преимущество обработки исключений заключается в том, что она предусматривает
автоматическую реакцию на многие ошибки, избавляя от необходимости писать вручную
соответствующий код. Например, в некоторых старых языках программирования
предусматривается возврат специального кода при возникновении ошибки в ходе выполнения
метода. Этот код приходится проверять вручную при каждом вызове метода.
Такой подход к обработке ошибок вручную трудоемок и чреват погрешностями. Обработка
исключений упрощает этот процесс, предоставляя возможность определять в
программе блок кода, называемый обработчиком исключения и автоматически выполняющийся
при возникновении ошибки. Это избавляет от необходимости проверять вручную,
насколько удачно или неудачно была выполнена та или иная операция или вызов
метода. Если возникнет ошибка, все необходимые действия по ее обработке выполнит
обработчик исключений.
Для наиболее часто встречающихся программных ошибок, в том числе деления на
нуль или попытки открыть несуществующий файл, в Java определены стандартные исключения.
Чтобы обеспечить требуемую реакцию на конкретную ошибку, в программу
следует включить соответствующий обработчик событий. Исключения широко применяются
в стандартной библиотеке Java API.
Глава 9. Обработка исключений 325
Другими словами, для успешного программирования на Java нужно уметь обращаться
с подсистемой обработки исключений, предусмотренной в этом языке программирования.
Иерархия исключений
В Java все исключения представлены отдельными классами. Все классы исключений
являются потомками класса ThrowaЫe. Так, если в программе возникнет исключительная
ситуация, будет сгенерирован объект класса, соответствующего определенному типу
исключения. У класса ThrowaЫe имеются два непосредственных подкласса: Exception
и Error. Исключения типа Error относятся к ошибкам, возникающим в виртуальной
машине Java, а не в прикладной программе. Контролировать такие исключения невозможно,
поэтому реакция на них в прикладной программе, как правило, не предусматривается.
В связи с этим исключения данного типа не будут описываться в этой книге.
Ошибки, связанные с работой программы, представлены отдельными подклассами,
производными от класса Exception. В частности, к этой категории относятся ошибки
деления на нуль, выхода за границы массива и обращения к файлам. Подобные ошибки
следует обрабатывать в самой программе. Важным подклассом, производным от
Exception, является класс RuntimeException, который служит для представления различных
видов ошибок, часто встречающихся во время выполнения программ.
Общее представление об обработке исключений
Для обработки исключений в Java предусмотрены пять ключевых слов: try, catch,
throw, throws и finally. Они образуют единую подсистему, в которой использование
одного ключевого слова почти всегда автоматически влечет за собой употребление другого.
Каждое из упомянутых выше ключевых слов будет подробно рассмотрено далее.
Но прежде следует получить общее представление об их роли в процессе обработки исключений.
Поэтому ниже вкратце поясняется, каким образом они действуют.
Операторы, в которых требуется отслеживать появление исключений, помещаются
в блок try. Если в блоке try будет сгенерировано исключение, его можно перехватить
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Можно ли подробнее описать условия, при которых генерируются исключения?
ОТВЕТ. Исключения генерируются при выполнении одного из трех условий.
Во-первых, исключение может сгенерировать виртуальная машина Java в качестве
реакции на некоторую внутреннюю ошибку, но такие исключения в
прикладных программах не контролируются. Во-вторых, причиной исключения
может стать ошибка в коде программы. Примерами подобных ошибок являются
деление на нуль и выход за границы массива. Такие исключения подлежат
обработке в прикладных программах. И в-третьих, исключения можно
сгенерировать вручную, используя ключевое слово throw. Порядок обработки
исключений не зависит от того, как именно они были сгенерированы.
326 Java 8: руководство для начинающих, 6-е издание
и обработать нужным образом. Системные исключения генерируются автоматически.
А д;1я того чтобы сгенерировать исключение вручную, следует воспользоваться ключевым
словом throw. Иногда возникает потребность обрабатывать исключения за пределами
метода, в котором они возникают, и в этом случае необходимо указывать их с помощью
ключевого слова throws. Код, который в любом случае должен быть выполнен
после выхода из блока try, помещается в блок finally.
Использование ключевых слов try и catch
Основными языковыми средствами обработки исключений являются ключевые слова
try и catch. Они используются совместно. Это означает, что в коде нельзя указать
ключевое слово catch, не указав ключевое слово try. Ниже приведена общая форма записи
блоков try/catch, предназначенных д;1я обработки исключений.
try {
// блок кода, в котором должны отслеживаться ошибки
catch (тип_исключения_l объект_исключения)
// обработчик исключения тип исключения 1
catch (тип_исключения_2 объект_исключения)
// обработчик исключения тип исключения 2
В скобках, следующих за ключевым словом catch, указываются тип исключения и
переменная, ссылающаяся на объект данного типа. Когда возникает исключение, оно
перехватывается соответствующим оператором catch, обрабатывающим это исключение.
Как следует из приведенной выше общей формы записи, с одним блоком try
может быть связано несколько операторов catch. Тип исключения определяет, какой
именно оператор catch будет выполняться. Так, если тип исключения соответствует
типу оператора catch, то именно он и будет выполнен, а остальные операторы catch -
пропущены. При перехвате исключения переменной, указанной в скобках после ключевого
слова catch, присваивается ссьmка на объект_исключения.
Следует иметь в виду, что если исключение не генерируется, то блок try завершается
обычным образом и ни один из его операторов catch не выполняется. Выполнение программы
продолжается с первого оператора, следующего за последним оператором catch.
Таким образом, операторы catch выполняются только при появлении исключения.
ПРИМЕЧАНИЕ
Начиная с версии JDK 7 используется новая форма оператора try, подцерживающая автоматическое
управления ресурсами и называемая оператором t ry с ресурсами. Более подробно
эта форма оператора try будет описана в главе 1 О при рассмотрении потоков ввода-вывода, в
том числе и тех, которые связаны с файлами, поскольку потоки ввода-вывода относятся к числу
ресурсов, наиболее часто используемых в прикладных программах.
Глава 9. Обработка исключений 327
Простой пример обработки исключений
Р а с с м о т р и м п р о с т о й п р и м ер, демонстрирующий перехват и обработку
исключения. Как известно, попытка обратиться за границы массива приводит
к ошибке, и виртуальная машина Java генерирует соответствующее исключение
ArrayindexOutOfBoundsException. Ниже приведен код программы, в которой намеренно
создаются условия для появления данного исключения, которое затем перехватывается.
// Демонстрация обработки исключений
class ExcDemol {
puЫic static void main(String args(]}
int nums[] new int[4];
try Создается бnок try
System.out.println("Дo генерации исключения"};
n ums [ 7 ] = 1 О ; Попытка исnо11ь3овать индекс, выходящий 30 rраиицы массива
System.out.println("Этa строка не будет отображаться"};
catch (ArrayindexOutOfBoundsException ехс) ( 4----Перехват искnючений,
System.out.println("Bыxoд за границы массива!"};
System.out.println("Пocлe оператора catch"};
обусnовnенных выходом 30
rраницы массива
Результат выполнения данной программы выглядит следующим образом.
До генерации исключения
Выход за границы массива!
После оператора catch
Несмотря на всю простоту данного примера программы, он наглядно демонстрирует
несколько важных особенностей обработки исключений. Во-первых, контролируемый
код помещается в блок try. И во-вторых, когда возникает исключение (в данном случае
это происходит при попытке использования индекса, выходящего за границы массива),
выполнение блока try прерывается и управление получает блок catch. Следовательно,
явного обращения к блоку catch не происходит, но переход к нему осуществляется лишь
при определенном условии, возникающем в ходе выполнения программы. Так, оператор
вызова метода println (), следующий за выражением, в котором происходит обращение
к несуществующему элементу массива, вообще не может быть выполнен. При выходе
из блока catch выполнение программы продолжается с оператора, следующего за этим
блоком. Таким образом, обработчик исключений предназначен для устранения программных
ошибок, приводящих к исключительным ситуациям, а также для обеспечения
нормального продолжения выполняемой программы.
Как упоминалось выше, в отсутствие появления исключений в блоке try операторы
в блоке catch управления не получают, и выполнение программы продолжается после
блока catch. Для того чтобы убедиться в этом, замените в предыдущей программе строку
кода
nums[7] = 10;
328 Java 8: руководство для начинающих. 6-е издание
следующей строкой:
nums [О] = 10;
Теперь исключение не возникнет и блок catch не выполнится.
Важно понимать, что исключения отслеживаются во всем коде, находящемся в блоке
try. Это относится и к исключениям, которые могут быть сгенерированы методом,
вызываемым из блока try. Исключения, возникающие в вызываемом методе, перехватываются
операторами в блоке catch, связанном с блоком try. Правда, это произойдет
лишь в том случае, если метод не обрабатывает исключения самостоятельно. Рассмотрим
в качестве примера следующую программу.
/* Исключение может быть сгенерировано одним методом,
а перехвачено другим */
class ExcTest {
// Генерация исключения
static void genException()
int nums[] = new int[4];
System.out.println("Дo генерации исключения");
// Сгенерировать исключение в связи с
// выходом индекса за границы массива
n ums [ 7 ] = 1 О ; Здесь rенернруетС11 нсм�оченне
System.out.println("Этa строка не будет отображаться");
class ExcDemo2 {
puЬlic static void main (String args []) {
try {
ExcTest.genException();
// А здесь исключение перехватывается
catch (ArrayindexOutOfBoundsException ехс) { --------Здесь нсм�оченне
System.out.println("Bыxoд за границы массива!"); перехватываете•
System.out.println("Пocлe оператора catch");
Выполнение этой версии программы дает тот же результат, что и предьщущая версия.
До генерации исключения
Вь􀃬од за границы массива!
После оператора catch
Метод genException () вызывается из блока try, и поэтому генерируемое, но не перехватываемое
в нем исключение перехватывается далее в блоке catch, находящемся в
методе main (). Если бы метод genException () сам перехватывал исключение, оно вообще
не достигло бы метода main () .
Глава 9. Обработка исключений 329
Необработанные исключений
Перехват стандартного исключения Java, продемонстрированный в предыдущем
примере, позволяет предотвратить завершение программы вследствие ошибки. Генерируемое
исключение должно быть перехвачено и обработано. Если исключение не обрабатывается
в программе, оно будет обработано виртуальной машиной Java. Но это
закончится тем, что по умолчанию виртуальная машина Java аварийно завершит программу,
выведя сообщение об ошибке и трассировку стека исключений. Допустим, в
предыдущем примере попытка обращения за границы массива не отслеживается и исключение
не перехватывается.
// Обработка ошибки средствами виртуальной машины Java
class NotHandled {
puЬlic static void main (String args []} {
int nums[J = new int[4);
System.out.println("Дo генерации исключения"};
// Сгенерировать исключение в связи с
// выходом индекса за границы массива
nums[7] = 10;
При появлении ошибки, связанной с обращением за границы массива, выполнение
программы прекращается, и выводится следующее сообщение:
Exception in thread "main" java.lang.ArrayindexOutOfBoundsException: 7
at NotHandled.main(NotHandled.java:9}
Такие сообщения полезны на этапе отладки, но пользователям программы эта информация
вряд ли нужна. Именно поэтому очень важно, чтобы программы обрабатывали
исключения самостоятельно и не поручали эту задачу виртуальной машине Java.
Как упоминалось выше, тип исключения должен соответствовать типу, указанному
в операторе са tch. В противном случае исключение не будет перехвачено. Так,
в приведенном ниже примере программы делается попытка перехватить исключение,
связанное с выходом индекса за границы массива, с помощью оператора catch,
в котором указан тип ArithmeticException - еще одного встроенного исключения
Java. При некорректном обращении к массиву будет сгенерировано исключение
ArraylndexOutOfBoundsException, не соответствующее типу, указанному в операторе
catch. В результате программа будет завершена аварийно.
// Эта программа не будет работать!
class ExcTypeMismatch {
puЬlic static void main(String args[]}
int nums[] = new int[4);
try
System.out.println("Дo генерации исключения"};
// Сгенерировать исключение в связи с
// выходом индекса за границы массива
nums [ 7] = 10; Здесь rенерируется искпючение ArrayindexOutOfBoundsException
System.out.println("Этa строка не будет отображаться"};
330 Java 8: руководство для начинающих. 6-е издание
/* Исключение, связанное с обращением за границы массива,
нельзя обработать с помощью оператора catch, в котором
указан тип исключения ArithmeticException. */
catch (ArithmeticException ехс) {
// Перехватить исключение
4--------Здесь деяается яопытка
System.out.println("Bыxoд за границы массива!");
System.out.println("Пocлe оператора catch");
Ниже приведен результат выполнения данной программы.
До генерации исключения
перехватить указанное выwе
искяючение с помощью
перехватчика искяючеиий
ArithmeticException
Exception in thread "main" java.lang.ArrayindexOutOfBoundsException: 7
at ExcTypeMismatch.main(ExcTypeMismatch.java:10)
Нетрудно заметить, что оператор catch, в котором указан тип исключения Arithrnetic
Exception, не может перехватить исключение ArrayindexOutOfBoundsException.
Обработка исключений - изящный способ
устранения программных ошибок
Одно из главных преимуществ обработки исключений заключается в том, что это позволяет
вовремя отреагировать на ошибку в программе и затем продолжить ее выполнение.
В качестве примера рассмотрим еще одну программу, в которой элементы одного
массива делятся на элементы другого. Если при этом происходит деление на нуль, то
генерируется исключение ArithrneticException. Обработка подобного исключения заключается
в том, что программа уведомляет об ошибке и затем продолжает свое выполнение.
Таким образом, попытка деления на нуль не приведет к аварийному завершению
программы из-за появления ошибки во время выполнении. Вместо этого осуществляется
корректная обработка ошибки, не прерывающая выполнения программы.
// Корректная обработка исключения и продолжение выполнения программы
class ExcDemoЗ {
puЬlic static void main (String args []) {
int numer[] { 4, 8, 16, 32, 64, 128 };
int denom[] = { 2, О, 4, 4, О, 8 } ;
for(int i=O; i<numer.length; i++)
try {
System.out.println(numer[i] + " / " +
denom[i] + " равно " +
numer[i]/denom[i]);
catch (ArithmeticException ехс) {
// Перехватить исключение
System.out.println("Пoпыткa деления на нуль!");
Глава 9. Обработка исключений 331
Результат выполнения данной программы выглядит следующим образом.
4 / 2 равно 2
Попытка деления на нуль!
16 / 4 равно 4
32 / 4 равно 8
Попытка деления на нуль!
128 / 8 равно 16
Данный пример демонстрирует еще одну важную особенность: обработанное исключение
удаляется из системы. Иными словами, на каждом шаге цикла блок try выполняется
заново, а все возникшие ранее исключения считаются обработанными. Благодаря
этому в программе могут обрабатываться повторно возникающие ошибки.
Множественные операторы catch
Как пояснялось ранее, с блоком try можно связать несколько операторов catch.
Обычно разработчики так и поступают на практике. Каждый из операторов catch должен
перехватывать отдельный тип исключений. Например, в приведенной ниже программе
обрабатываются как исключения, связанные с обращением за границы массива,
так и ошибки деления на нуль.
// Применение нескольких операторов catch
class ExcDemo4 {
puЬlic static void main(String args[]) {
// Длина массива nurner превЫПiает длину массива denom
int nurner[] { 4, 8, 16, 32, 64, 128, 256, 512 };
int denom[] = { 2, О, 4, 4, О, 8 } ;
for(int i=O; i<numer.length; i ++)
try {
System.out.println(numer[i] +" / " +
denom[i] +" равно " +
numer[i]/denom[i]);
catch (ArithmeticException ехс) { Забnоком trycneдyeт / / Перехватить исключение нескоnько бnоков catch подр11д System. out. println ( "Попытка деления на нуль"); 1
catch (ArrayindexOutOfBoundsException ехс) { 􀁫
// Перехватить исключение
System.out.println("Cooтвeтcтвyющий элемент не найден");
Выполнение этой программы дает следующий результат.
4 / 2 равно 2
Попытка деления на нуль
16 / 4 равно 4
32 / 4 равно 8
332 Java 8: руководство для начинающих, 6-е издание
Попытка деления на нуль
128 / 8 равно 16
Соответствующий элемент не найден
Соответствующий элемент не найден
Как подтверждает приведенный выше результат выполнения программы, в каждом
блоке оператора catch обрабатывается свой тип исключения.
Вообще говоря, выражения с операторами catch проверяются в том порядке, в котором
они встречаются в программе. И выполняется лишь тот из них, который соответствует
типу возникшего исключения. Остальные блоки операторов catch просто игнорируются.
Перехват исключений, генерируемых подклассами
В случае использования множественных операторов catch важно знать об одной интересной
особенности: условие перехвата исключений для суперкласса будет справедливо
и для любых его подклассов. Например, класс ThrowaЫe является суперклассом
для всех исключений, поэтому для перехвата всех возможных исключений в операторах
catch следует указывать тип ThrowaЫe. Если же требуется перехватывать исключения
суперкласса и подкласса, то в блоке операторов первым должен быть указан тип исключения,
генерируемого подклассом. В противном случае вместе с исключением суперкласса
будут перехвачены и все исключения производных от него классов. Это правило
соблюдается автоматически, так что указание сначала исключения суперкласса, а затем
всех остальных приведет к созданию недостижимого кода, поскольку условие перехвата
исключения, генерируемого подклассом, никогда не будет выполнено. При этом следует
учитывать, что в Java наличие недостижимого кода считается ошибкой.
Рассмотрим в качестве примера следующую программу.
// В операторах catch исключения подкласса должны
// предшествовать исключениям суперкласса
class ExcDemo5 (
puЬlic static void main(String args(]) (
// Длина массива numer превьШiает длину массива denom
int numer(J ( 4, 8, 16, 32, 64, 128, 256, 512 };
int denom[] = ( 2, О, 4, 4, О, 8 } ;
for(int i=O; i<numer.length; i++)
try (
System.out.println(numer(i] + " / " +
denom(i] + " равно " +
numer(i]/denom(i]);
catch (ArraylndexOutOfBoundsException ехс) Перехват исключениА
/ / Перехватить исключение подкnоссо
System.out.println("Cooтвeтcтвyющий элемент не найден");
catch (ThrowaЫe ехс) ( Перехаот исключениА суперклоссо
System.out.println("Boзниклo исключение");
Глава 9. Обработка исключений 333
Ниже приведен результат выполнения данной программы.
4 / 2 равно 2
Возникло исключение
16 / 4 равно 4
32 / 4 равно 8
Возникло исключение
128 / 8 равно 16
Соответствующий элемент не найден
Соответствующий элемент не найден
В данном случае оператор catch (ThrowaЬle) перехватывает все исключения, кроме
ArraylndexOutOfBoundsException. Соблюдение правильного порядка следования операторов
catch приобретает особое значение в тех случаях, когда исключения генерируются
в самой программе.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Зачем перехватывать исключения, генерируемые суперклассами?
ОТВЕТ. На это могут быть самые разные причины. Ограничимся рассмотрением
двух из них. Во-первых, включив в программу блок catch для перехвата исключений
типа Exception, вы получаете универсальный механизм обработки всех
исключений, связанных с выполнением вашей программы. Такой универсальный
обработчик исключений оказывается удобным, например, в тех случаях,
когда требуется предотвратить аварийное завершение программы, независимо
от возникшей ситуации. И во-вторых, для обработки некоторой категории исключений
иногда подходит единый алгоритм. Перехватывая эти исключения,
генерируемые суперклассом, можно избежать дублирования кода.
Вложенные блоки try
Блоки try могут быть вложенными друг в друга. Исключение, возникшее во внутреннем
блоке try и не перехваченное связанным с ним блоком catch, распространяется
далее во внешний блок try и обрабатывается связанным с ним блоком catch.
Такой порядок обработки исключений демонстрируется в приведенном ниже примере
программы, где исключение ArrayindexOutOfBoundsException не перехватывается во
внутреннем блоке catch, но обрабатывается во внешнем.
// Использование вложенных блоков try
class NestTrys (
puЫic static void rnain(String args[J)
// Длина массива nurner превЬШiает длину массива denorn
int nurner[] ( 4, 8, 16, 32, 64, 128, 256, 512 } ;
in t denorn [ J = ( 2, О, 4 , 4 , О, 8 } ;
try ( / / внешний блок try Вnоженные бnокн try
for(int i=O; i<nurner.length; i++)
try { // внутренний блок try
334 Java 8: руководство для начинающих. 6-е издание
System.out.println(numer[i] + " / " +
denom[i] + " равно " +
numer[i]/denom[i]);
catch (ArithmeticException ехс) (
// Перехватить исключение
System.out.println("Пoпыткa деления на нуль");
catch (ArrayindexOutOfBoundsException ехс) (
// Перехватить исключение
System.out.println("Cooтвeтcтвyющий элемент не найден");
System.out.println("Фaтaльнaя ошибка - выполнение
программы прервано!");
Выполнение этой программы может дать, например, следующий результат.
4 / 2 равно 2
Попытка деления на нуль
16 / 4 равно 4
32 / 4 равно 8
Попытка деления на нуль
128 / 8 равно 16
Соответствующий элемент не найден
Фатальная ошибка - выполнение программы прервано!
В данном примере исключение, которое может быть обработано во внутреннем блоке
try (в данном случае ошибка деления на нуль), не мешает дальнейшему выполнению
программы. А вот ошибка превышения границ массива перехватывается во внешнем
блоке try, что приводит к аварийному завершению программы.
Ситуация, продемонстрированная в предыдущем примере, является не единственной
причиной для применения вложенных блоков try, хотя она встречается очень часто.
В этом случае вложенные блоки try помогают по-разному обрабатывать разные типы
ошибок. Одни ошибки невозможно устранить, а для других достаточно предусмотреть
сравнительно простые действия. Внешний блок try чаще всего используется для перехвата
критических ошибок, а менее серьезные ошибки обрабатываются во внутреннем
блоке try.
Генерирование исключений
В предыдущих примерах программ обрабатывались исключения, автоматически генерируемые
виртуальной машиной Java. Но генерировать исключения можно и вручную,
используя для этого оператор throw. Вот общая форма этого оператора:
throw объект
_
исключения;
где объект
_
исключения должен быть объектом класса, производного от класса
ThrowaЫe.
Глава 9. Обработка исключений 335
Ниже приведен пример программы, демонстрирующий применение оператора
throw. В этой программе исключение Ari thmeticException генерируется вручную.
// Генерирование исключения вручную
class ThrowDemo {
puЫic static void main(String args[])
try {
System.out.println("Дo оператора throw");
throw new Ari thmeticException () ; Сrенернровот�, искпюченн11
catch (ArithmeticException ехс) {
!/ Перехватить исключение
System.out.println("Иcключeниe перехвачено");
System.out.println("Пocлe блока try/catch");
Выполнение этой программы дает следующий результат.
До оператора throw
Исключение перехвачено
После блока try/catch
Обратите внимание на то, что исключение ArithmeticException генерируется с помощью
ключевого слова new в операторе throw. Дело в том, что оператор throw генерирует
исключение в виде объекта. Поэтому после ключевого слова throw недостаточно
указать только тип исключения, нужно еще создать объект для этой цели.
Повторное генерирование исключений
Исключение, перехваченное блоком catch, может быть повторно сгенерировано для
обработки другим аналогичным блоком. Чаще всего повторное генерирование исключений
применяется с целью предоставить разным обработчикам доступ к исключению.
Так, например, повторное генерирование исключения имеет смысл в том случае, если
один обработчик оперирует одним свойством исключения, а другой ориентирован на
другое его свойство. Повторно сгенерированное исключение не может быть перехвачено
тем же самым блоком catch. Оно распространяется в следующий блок catch.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Зачем генерировать исключения вручную?
ОТВЕТ. Чаще всего генерируемые вручную исключения являются экземплярами
создаваемых классов исключений. Как будет показано далее, создание собственных
классов исключений позволяет обрабатывать ошибки в рамках единой
стратегии обработки исключений в разрабатываемой прикладной программе.
336 Java 8: руководство для начинающих. 6-е издание
Ниже приведен пример программы, демонстрирующий повторное генерирование
исключений.
// Повторное генерирование исключений
class Rethrow {
puЫic static void genException(} {
// Длина массива numer превышает длину массива denom
int numer[J { 4, 8, 16, 32, 64, 128, 256, 512 };
int denom[J = { 2, О, 4, 4, О, 8 };
for(int i=O; i<numer.length; i++)
try {
System.out.println(numer[i] + " / " +
denom[i] + " равно " +
numer[i]/denom[i]);
catch (ArithmeticException ехс) {
// Перехватить исключение
System.out.println("Пoпыткa деления на нуль");
catch (ArraylndexOutOfBoundsException ехс) {
// Перехватить исключение
System.out.println("Cooтвeтcтвyющий элемент не найден"};
throw ехс; // повторно сгенерировать исключение
t.... _ ________ Повторное rенернроаонне нскпюченн•
class RethrowDemo {
puЫic static void main(String args[]) {
try {
Rethrow.genException();
catch(ArraylndexOutOfBoundsException ехс) { 4---- Перехаот повторно
// Повторно перехватить исключение сrенернровонноrо нскпючення
System.out.println("Фaтaльнaя ошибка - " +
"выполнение программы прервано!");
В данной программе ошибка деления на нуль обрабатывается локально в методе
genException (), а при попытке обращения за границы массива исключение генерируется
повторно. На этот раз оно перехватывается в методе main (}.
Подробнее о классе ТhrowaЬle
В приведенных до сих примерах программ только перехватывались исключения, но
не выполнялось никаких действий над представляющими их объектами. В выражении
оператора catch указываются тип исключения и параметр, принимающий объект исключения.
А поскольку все исключения представлены подклассами, производными от
Глава 9. Обработка исключений 337
класса ThrowaЫe, то они подцерживают методы, определенные в этом классе. Некоторые
наиболее употребительные методы из класса ThrowaЫe приведены в табл. 9.1.
Таблица 9.1. Наиболее употребительные методы из класса ТhrowaЬle
Метод
ThrowaЫe fillinStackTrace ()
String getLocalizedМessage ()
String getMessage ()
void printStackTrace ()
void printStackTrace
( PrintStrearn поток)
void printStackTrace
(PrintWriter поток)
String toString ()
Описание
Возвращает объект типа ThrowaЬle, содержащий полную
трассировку стека исключений. Этот объект пригоден для повторного
генерирования исключений
Возвращает описание исключения, локализованное по региональным
стандартам
Возвращает описание исключения
Выводит трассировку стека исключений
Выводит трассировку стека исключений в указанный поток
Направляет трассировку стека исключений в указанный поток
Возвращает объект типа String, содержащий полное описание
исключения. Этот метод вызывается из метода println ()
при выводе объекта типа ThrowaЫe
Среди методов, определенных в классе ThrowaЫe, наибольший интерес представляют
методы printStackTrace () и toString (). С помощью метода printStackTrace ()
можно вывести стандартное сообщение об ошибке и запись последовательности вызовов
методов, которые привели к возникновению исключения. А метод toString () позволяет
получить стандартное сообщение об ошибке. Этот метод также вызывается в том
случае, когда объект исключения передается в качестве параметра методу println ().
Применение этих методов демонстрируется в следующем примере программы.
// Использование методов класса ThrowaЫe
class Excтest {
static void genException()
int nums[J = new int[4];
System.out.println("Дo генерации исключения");
// Сгенерировать исключение в связи с
// выходом индекса за границы массива
nurns [7] = 10;
System.out.println("Этa строка не будет отображаться");
class UseThrowaЫeMethods {
puЫic static void main(String args[]) {
try {
ExcTest.genException();
338 Java 8: руководство для начинающих. 6-е издание
catch (ArrayindexOutOfBoundsException ехс) {
// перехватить исключение
System.out.println("Cтaндapтнoe сообщение: ");
System.out.println(exc);
System.out.println("\nCтeк вызовов: ");
exc.printStackTrace();
System.out.println("Пocлe оператора catch");
Результат выполнения данной программы выглядит следующим образом.
До генерации исключения
Стандартное сообщение:
java.lang.ArrayindexOutOfBoundsException: 7
Стек вызовов:
java.lang.ArrayindexOutOfBoundsException: 7
at ExcTest.genException(UseThrowaЫeMethods.java:10)
at UseThrowaЫeMethods.main(UseThrowaЫeMethods.java:19)
После оператора catch
Использование ключевого слова finally
Иногда требуется определить блок кода, который должен выполняться по завершении
блока try/catch. Допустим, в процессе работы программы возникло исключение,
требующее ее преждевременного завершения. Но в программе открыт файл или установлено
сетевое соединение, а следовательно, файл нужно закрыть, а соединение - разорвать.
Для выполнения подобных операций, связанных с нормальным завершением
программы, удобно воспользоваться ключевым словом finally.
Для тоrо чтобы определить код, который должен выполняться по завершении блока
try/catch, нужно указать блок finally в конце последовательности операторов try/
catch. Ниже приведена общая форма записи блока try/catch вместе с блоком finally.
try {
// Блок кода, в котором отслеживаются ошибки
са tch (тип_ исключения_ 1 объект_ исключения)
// Обработчик исключения тип исключения 1
catch (тип_исключения_2 объект_исключения)
// Обработчик исключения тип исключения 2
// . . .
finally
// Код блока finally
Глава 9. Обработка исключений 339
Блок finally выполняется всегда по завершении блока try/catch, независимо от
того, какое именно условие к этому привело. Следовательно, блок finally получит
управление как при нормальной работе программы, так и при возникновении ошибки.
Более того, он будет вызван даже в том случае, если в блоке try или в одном из блоков
catch будет присутствовать оператор return для немедленного возврата из метода.
Ниже приведен краткий пример программы, демонстрирующий использование блока
finally.
// Использование блока finally
class UseFinally {
puЫic static void genException(int what} {
int t;
int nums[J = new int[2];
System.out.println("Пoлyчeнo: " + what};
try {
switch(what}
case О:
t = 10 / what; // сгенерировать ошибку деления на нуль
break;
case 1:
nums[4]
break;
case 2:
4; // сгенерировать ошибку обращения к массиву
return; // возвратиться из блока try
catch (ArithmeticException ехс} {
// Перехватить исключение
System.out.println("Пoпыткa деления на нуль"};
return; // вернуться из блока catch
catch (ArrayindexOutOfBoundsException ехс} {
// перехватить исключение
System.out.println("Cooтвeтcтвyющий элемент не найден"};
finally { 4------------------Этот бnок вwnоnняется незовнснмо
System.out.println("Bыxoд из блока try"};
class FinallyDemo {
puЫic static void main(String args[J) {
for (int i=O; i < З; i++} {
UseFinally.genException(i);
System.out.println(};
от тоrо, каким образом заверwаета
бnок try/catch
340 Java 8: руководство для начинающих. 6-е издание
В результате выполнения данной программы получается следующий результат.
Получено: О
Попытка деления на нуль
Выход из блока try
Получено: 1
Соответствующий элемент не найден
Выход из блока try
Получено: 2
Выход из блока try
Нетрудно заметить, что блок finally выполняется независимо от того, каким образом
завершается блок try/catch.
Использование ключевого слова throws
Иногда исключения нецелесообразно обрабатывать в том методе, в котором они возникают.
В таком случае их следует указывать с помощью ключевого слова throws. Ниже
приведена общая форма объявления метода, в котором присутствует ключевое слово
throws.
возвращаемый_тип имя_метода(список_параметров) throws
список исключений {
// Тело метода
В списке исключений через запятую указываются исключения, которые может генерировать
метод.
Возможно, вам покажется странным, что в ряде предыдущих примеров ключевое
слово throws не указывалось при генерировании исключений за пределами методов.
Дело в том, что исключения, генерируемые подклассом Error или RuntimeException,
можно не указывать в списке оператора throws. Исполняющая система Java по умолчанию
предполагает, что метод может их генерировать. Возможные исключения всех
остальных типов вы обязаны объявить с помощью ключевого слова throws. Если этого
не сделать, возникнет ошибка во время компиляции программы.
Пример использования оператора throws уже был представлен ранее. Напомним,
что при организации ввода с клавиатуры в метод main () потребовалось включить следующее
выражение:
throws java.io.IOException
Теперь вы знаете, зачем это было нужно. При вводе данных может возникнуть исключение
IOException, а на тот момент вы еще не знали, как оно обрабатывается.
Поэтому мы и указали, что исключение должно обрабатываться за пределами метода
main (). Теперь, ознакомившись с исключениями, вы сможете без труда обработать исключение
IOException самостоятельно.
Рассмотрим пример, в котором осуществляется обработка исключения IOException.
В методе prompt () отображается сообщение, а затем выполняется ввод символов
с клавиатуры. Такой ввод данных может привести к возникновению исключения
IOException. Но это исключение не обрабатывается в методе prompt (). Вместо этого
Глава 9. Обработка исключений 341
в объявлении метода указан оператор throws, т.е. обязанности по обработке данного
исключения поручаются вызывающему методу. В данном случае вызывающим является
метод main () , в котором и перехватывается исключение.
// Использование ключевого слова throws
class ThrowsDemo {
puЬlic static char prompt(String str)
throws java.io.IOException { -----Обратнтеаннманне на оператор
throws в объявnеннн метода
System.out.print(str + ": ");
return (char) System.in.read();
puЫic static void main(String args[]) {
char ch;
try {
ch = prompt("Enter а letter") 4---- В методе prornpt () может быть
сгенерировано нскnюченне, поэтому его
аызов сnедует nоместнть в бnок try
catch(java.io.IOException ехс) {
System.out.println("Пpoизoшлo исключение ввода-вывода");
ch = 'Х';
System.out.println("Bы нажали клавишу " + ch);
Обратите внимание на одну особенность приведенного выше примера. Класс
IOException относится к пакету java. io. Как будет разъяснено в главе 10, в этом пакете
содержатся многие языковые средства Java для организации ввода-вывода. Следовательно,
пакет j ava. io можно импортировать, а в программе указать только имя класса
IOException.
Новые средства обработки исключений,
появившиеся в версии JDK 7
С появлением версии JDK 7 механизм обработки исключений в Java бьш значительно
усовершенствован благодаря включению в него трех новых средств. Первое из них
поддерживает автоматическое управление ресурсами, позволяющее автоматизировать
процесс освобождения таких ресурсов, как файлы, когда они больше не нужны. В основу
этого средства положена расширенная форма оператора try, называемая оператором
try с ресурсами и описываемая в главе 10 при рассмотрении файлов. Второе новое
средство называется групповым перехватом, а третье - окончательным или уточненным
повторным генерированием исключений. Два последних средства рассматриваются ниже.
Групповой перехват позволяет перехватывать два или более исключения одним оператором
catch. Как пояснялось ранее, после оператора try можно (и даже принято)
указывать два или более оператора catch. И хотя каждый блок оператора catch, как
правило, содержит свой собственный код, нередко в двух или более блоках оператора
са tch выполняется один и тот же код, несмотря на то что в них перехватываются
342 Java 8: руководство для начинающих. 6-е издание
разные исключения. Вместо того чтобы перехватывать каждый тип исключения в отдельности,
теперь можно воспользоваться единым блоком оператора catch для обработки
исключений, тем самым избегая дублирования кода.
Для организации группового перехвата следует указать список исключений в одном
операторе catch, разделив их типы оператором поразрядного ИЛИ. Каждый параметр
группового перехвата неявно указывается как final. (По желанию модификатор доступа
final можно указать и явным образом, н􀁹 это совсем не обязательно.) А поскольку
каждый параметр группового перехвата неявно указывается как final, то ему нельзя
присвоить новое значение.
В приведенной ниже строке кода показывается, каким образом групповой перехват
исключений ArithmeticException и ArrayindexOutOfBoundsException указывается в
одном операторе catch.
catch(final ArithmeticException I ArrayindexOutOfBoundsException е) {
Ниже приведен пример программы, демонстрирующий применение группового перехвата
исключений.
// Использование средства группового перехвата исключений.
// Примечание: для компиляции этого кода требуется JDK 7
// или более поздняя версия комплекта разработчика.
class MultiCatch {
puЫic static void main(String args[]) {
int а=88, Ь= О;
int result;
char chrs [] = { 'А', 'В' , 'С' } ;
for (int i= O; i < 2; i++) {
try {
}
if (i == О)
// Сгенерировать исключение ArithmeticException
result = а/ Ь;
else
// Сгенерировать исключение ArrayindexOutOfBoundsException
chrs[S] = 'Х';
// В этом операторе catch организуется перехват
// обоих исключений
catch(ArithmeticException I ArrayindexOutOfBoundsException е) {
System.out.println("Пepexвaчeннoe исключение: " + е);
System.out.println("Пocлe группового перехватчика исключений");
В данном примере программы исключение ArithrneticException генерируется при
попытке деления на нуль, а исключение ArrayindexOutOfBoundsException - при попытке
обращения за границы массива chrs. Оба исключения перехватываются одним
оператором catch.
Средство уточненного повторного генерирования исключений ограничивает этот
процесс лишь теми проверяемыми типами исключений, которые генерируются в
Глава 9. Обработка исключений 343
соответствующем блоке try и не обрабатываются в предыдущем блоке оператора catch,
а также относятся к подтипу или супертипу указываемого параметра. И хотя такая возможность
требуется нечасто, ничто не мешает теперь воспользоваться ею в полной мере.
А для организации окончательного повторного генерирования исключений параметр
оператора catch должен быть, по существу, указан как final. Это означает, что ему
нельзя присвоить новое значение в блоке catch. Он может быть указан как final явным
образом, хотя это и не обязательно.
Встроенные классы исключений Java
В стандартном пакете java. lang определены некоторые классы, представляющие
стандартные исключения Java. Часть из них использовалась в предыдущих примерах
программ. Наиболее часто встречаются исключения из подклассов стандартного класса
RuntimeException. А поскольку пакет j ava. lang импортируется по умолчанию во все
программы на Java, то исключения, производные от класса RuntimeException, становятся
доступными автоматически. Их даже обязательно включать в список оператора
throws. В терминологии языка Java такие исключения называют непроверяемыми, поскольку
компилятор не проверяет, обрабатываются или генерируются подобные исключения
в методе. Непроверяемые исключения, определенные в пакете java. lang, приведены
в табл. 9.2, тогда как в табл. 9.3 - те исключения из пакета java. lang, которые
следует непременно включать в список оператора throws при объявлении метода, если,
конечно, в методе содержатся операторы, способные генерировать эти исключения, а
их обработка не предусмотрена в теле метода. Такие исключения принято называть проверяемыми.
В Java предусмотрен также ряд других исключений, определения которых
содержатся в различных библиотеках классов. К их числу можно отнести упомянутое
ранее исключение IOException.
Таблица 9 .2. Непроверяемые исключения, определенные в пакете java. lanq
Исключение Описание
ArithmeticException Арифметическая ошибка, например попытка деления но нуль
ArrayindexOutOfBoundsException Попытка обращения за границы массива
ArrayStoreException
ClassCastException
EnumConstNotPresentException
IllegalArgumentException
IllegalMonitorStateException
IllegalStateException
IllegalThreadStateException
IndexOutOfBoundsException
NegativeArraySizeException
Попытка ввести в массив элемент, несовместимый с ним по
типу
Недопустимое приведение типов
Попытка использования нумерованного значения, которое не
было определено ранее
Недопустимый параметр при вызове метода
Недопустимая операция контроля, например, ожидание раз·
блокировки потока
Недопустимое состояние среды выполнения или приложения
Запрашиваемая операция несовместима с текущим состояни·
ем потока
Недопустимое значение индекса
Создание массива отрицательного размера
344 Java 8: руководство для начинающих. 6-е издание
Исключение Описание
Окончание табл. 9.2
NullPointerException Недопустимое использование пустой ссылки
NumЬerFormatException Неверное преобразование символьной строки в число
SecurityException Попытка нарушить систему защиты
StringindexOutOfBounds Попытка обращения к символьной строке за ее границами
TypeNotPresentException Неизвестный тип
Uns uppo rt edOper а t i onExcept i on Неподдерживаемая операция
Таблица 9.3. Проверяемые исключения, определенные в пакете java.lang
Исключение Описание
ClassNotFoundException Класс не найден
CloneNotSupportedException Попытка клонирования объекта, не реализующего интерфейс
CloneaЫe
IllegalAccessException Доступ к классу запрещен
InstantiationException Попытка создания объекта абстрактного класса или интерфейса
InterruptedException Прерывание одного потока другим
NoSuchFieldException Требуемое поле не существует
NoSuchМethodException Требуемый метод не существует
ReflectiveOperationException Суперкласс исключений, связанных с рефлексией (добавлен в
версии JDK 7)
Создание подклассов, производных
от класса Exception
Несмотря на то что встроенные в Java исключения позволяют обрабатывать большинство
ошибок, механизм обработки исключений не ограничивается только этими
ошибками. В частности, можно создавать исключения дЛЯ обработки потенциальных
ошибок в прикладной программе. Создать исключение несложно. Для этого достаточно
определить подкласс, производный от класса Exception, который, в свою очередь,
представляет собой подкласс, порожденный классом ThrowaЫe. В создаваемый подкласс
не обязательно включать реализацию каких-то методов. Сам факт существования
такого подкласса позволяет использовать его в качестве исключения.
В классе Exception не определены новые методы. Он лишь наследует методы, предоставляемые
классом ThrowaЫe. Таким образом, все исключения, включая и создаваемые
вами, содержат методы класса ThrowaЫe. Конечно же, вы вольны переопределить
в создаваемом вами классе один или несколько методов.
Ниже приведен пример, в котором создается исключение NonintResultException.
Оно генерируется в том случае, если результатом деления двух целых чисел является
дробное число. В классе NonintRes ul tException содержатся два поля,
СПРОСИМ У ЭКСПЕРТА
Глава 9. Обработка исключений 345
ВОПРОС. Говорят, что в языке Java поддерживаются специальные исключения, называемые
цепочечными. Что это такое?
ОТВЕТ. Цепочечные исключения - сравнительно недавнее дополнение Java.
Это языковое средство позволяет указывать одно исключение как причину
другого. Представьте себе ситуацию, когда метод генерирует исключение
Ari thmeticException как реакцию на попытку деления на нуль. Но на самом
деле в программе возникает ошибка ввода-вывода, из-за которой делитель
устанавливается неверно. Поэтому было бы желательно уведомить вызывающую
часть программы, что истинной причиной служит не попытка деления на
нуль, а ошибка ввода-вывода, хотя исключение ArithmeticException безусловно
должно быть сгенерировано. И это позволяют сделать цепочечные исключения.
Они применимы и в других ситуациях, когда имеют место многоуровневые
исключения.
Для поддержки цепочечных исключений в класс ThrowaЫe введены два конструктора
и два метода. Ниже приведены общие формы объявления обоих конструкторов.
ThrowaЫe(ThrowaЫe причинное_исключение)
ThrowaЫe(String сообщение, ThrowaЫe причинное_исключение)
В первой форме конструктора причинное_ исключение обозначает предьщущее
исключение, послужившее причиной текущего исключения. Вторая форма
конструктора позволяет указывать не только причинное_ исключение, но и
сообщение. Эти же конструкторы были введены в классы Error, Exception и
RuntimeException.
Помимо конструкторов, в классе ThrowaЫe бьши также определены методы
getCause () и initCause (). Ниже приведены общие формы объявления этих
методов.
ThrowaЬle getCause()
ThrowaЫe initCause(ThrowaЫe причинное_исключение)
Метод getCause () возвращает исключение, которое стало причиной текущего
исключения. Если такого исключения не было, возвращается пустое значение
null. А метод ini tCause () связывает причинное_ исключение с тем исключением,
которое должно быть сгенерировано, возвращая ссьшку на это исключение.
Подобным способом можно связать причину с исключением уже после
того, как исключение было сгенерировано. Как правило, метод ini tCa use ()
применяется для установления истинной причины исключения, сгенерированного
устаревшими классами, не поддерживающими описанные выше конструкторы.
Цепочечные исключения требуются далеко не в каждой программе. Но в тех
случаях, когда необходимо выяснить истинную причину исключения, это языковое
средство позволяет легко решить подобную задачу.
346 Java 8: руководство для начинающих, 6-е издание
предназначенные мя хранения целых чисел, а также конструктор. В нем также переопределен
метод toString (), что дает возможность выводить описание исключения с
помощью метода println ().
// Использование специально создаваемого исключения
// Создать исключение
class NonintResultException extends Exception {
int n;
int d;
NonintResultException { int i, int j) {
n i;
d = j;
puЫic String toString {) {
return "Результат операции " + n + " / " + d +
" не является целым числом";
class CustomExceptDemo {
puЫic static void main{String args[]) {
// В массиве numer содержатся нечетные числа
int numer[] = { 4, 8, 15, 32, 64, 127, 256, 512 };
int denom[J = { 2, О, 4, 4, О, 8 } ;
for {int i=O; i<numer. length; i++) {
try {
if { {numer[i] %2) != О)
throw new
NonintResultException{numer[i], denom[i]);
System.out.println{numer[i] + " / " +
denom[i] + " равно " +
numer[i]/denom[i]);
catch {ArithmeticException ехс) {
// перехватить исключение
System.out.println{"Пoпыткa деления на нуль");
catch (ArrayindexOutOfBoundsException ехс) {
// перехватить исключение
System.out.println("Cooтвeтcтвyющий элемент не найден");
catch (NonintResultException ехс) {
System.out.println(exc);
Глава 9. Обработка исключений 347
Результат выполнения данной программы выглядит следующим образом.
4 / 2 равно 2
Попытка деления на нуль
Результат операции 15 / 4 не является целым числом
32 / 4 равно 8
Попытка деления на нуль
Результат операции 127 / 8 не является целым числом
Соответствующий элемент не найден
Соответствующий элемент не найден
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Когда следует предусматривать обработку исключений в программе?
И в каких случаях имеет смысл самостоятельно определять классы исключений?
ОТВЕТ. Поскольку в библиотеке Java API для формирования сообщений об ошибках
широко применяются исключения, обработчики исключений должны присутствовать
практически во всех прикладных программах. Ответ на вопрос,
следует ли в конкретном случае обрабатывать исключения, практически очевиден.
Сложнее принять решение о том, следует ли определить собственное
исключение. Обычно сообщения об ошибках формируются двумя способами:
путем возврата специальных кодов и с помощью исключений. Какому из этих
способов отдать предпочтение? Традиционный для программирования на Java
подход состоит в использовании исключений. Разумеется, полностью отказываться
от обработки возвращаемого кода ошибок не стоит. Ведь в некоторых
случаях такой способ оказывается очень удобным. Но исключения предоставляют
более эффективный и структурированный механизм обработки ошибок.
Именно так профессионалы организуют в своих программах реакцию на потенциальные
ошибки.
Упражнение 9.1 Добавnение исключений в кпасс очереди
QueueFullException.java
QueueEmptyException.java
FixedQueue.java
В этом проекте предстоит создать два класса исключений,
которые будут использоваться классом
очереди, разработанным в упражнении 8.1. Эти ис-
QExcDemo. j ava ключения должны указывать на переполнение и
...................................................................... опустошение очереди, а генерировать их будут мето-
ды put () и get () соответственно. Ради простоты эти исключения добавляются в класс
FixedQueue, но вы можете без труда внедрить их в любые другие классы очереди, разработанные
в упражнении 8.1. Поэтапное описание процесса создания программы приведено
ниже.
1. Создайте файл QExcDemo. java.
2. Определите следующие исключения в файле QExcDemo. j ava.
/*
Упражнение 9.1
348 Java 8: руководство для начинающих, 6-е издание
Добавление обработчиков исключений в класс очереди.
*/
// Исключение, указывающее на переполнение очереди
class QueueFullException extends Exception {
int size;
QueueFullException(int s) { size s; }
puЫic String toString () {
return "\nОчередь заполнена. Максимальный размер очереди: " +
size;
// Исключение, указывающее на исчерпание очереди
class QueueErnptyException extends Exception {
puЬlic String toString () {
return "\nОчередь пуста.";
Исключение QueueFullException генерируется при попытке поместить элемент
в уже заполненную очередь, а исключение QueueEmptyException - в ответ на
попытку извлечь элемент из пустой очереди.
3. Измените класс FixedQueue таким образом, чтобы при возникновении ошибки
он генерировал исключение. Соответствующий код приведен ниже. Введите этот
код в файл QExcDemo. java.
// Класс, реализующий очередь фиксированного размера
// для хранения символов
class FixedQueue irnplernents ICharQ {
private char q[]; // массив для хранения элементов очереди
private int putloc, getloc; // индексы вставки и извлечения
// элементов очереди
// Создание пустой очереди заданного размера
puЬlic FixedQueue(int size) {
q = new char[size+l); // выделить память для очереди
putloc = getloc = О;
// Поместить символ в очередь
puЬlic void put(char ch)
throws QueueFullException
if(putloc==q.length-1)
throw new QueueFullException(q.length-1);
putloc++;
q [putloc] ch;
// Извлечь символ из очереди
puЫic char get()
throws QueueEmptyException
if(getloc == putloc)
Глава 9. Обработка исключений 349
throw new QueueEmptyException();
getloc++;
return q[getloc];
Добавление исключений в класс FixedQueue выполняется в два этапа. Сначала в
определении методов get () и put () указывается оператор throws с типом генерируемого
исключения. А затем в этих методах организуется генерирование исключений
при возникновении ошибок. Используя исключения, можно организовать
обработку ошибок в вызывающей части программы наиболее рациональным
способом. Как вы помните, в предыдущих версиях рассматриваемой здесь программы
выводились только сообщения об ошибках. А генерирование исключений
является более профессиональным подходом к разработке данной программы.
4. В качестве проведения самостоятельного эксперимента с усовершенствованным
классом FixedQueue введите в файл QExcDerno. j ava приведенный ниже исходный
код класса QExcDerno.
// Демонстрация исключений при работе с очередью
class QExcDemo {
puЫic static void main(String args[])
FixedQueue q = new FixedQueue(lO);
char ch;
int i;
try
// Переполнение очереди
for (i=O; i < 11; i++) {
System.out.print("Пoпыткa сохранения: " +
(char) ('А' + i));
q.put((char) ('А' + i));
System.out.println(" - ОК");
System.out.println();
catch (QueueFullException ехс)
System.out.println(exc);
System.out.println();
try {
// Попытка извлечь символ из пустой очереди
for (i=O; i < 11; i++) {
System.out.print("Пoлyчeниe очередного символа: ");
ch = q.get();
System.out.println(ch);
350 Java 8: руководство для начинающих. 6-е издание
catch (QueueEmptyException ехс) {
System.out.println(exc);
5. Класс FixedQueue реализует интерфейс ICharQ, в котором определены методы
get () и put (), и поэтому интерфейс ICharQ необходимо изменить таким образом,
чтобы в нем отражалось наличие операторов throws. Ниже приведен видоизмененный
соответственно код интерфейса ICharQ. Не забывайте о том, что он
должен храниться в файле ICharQ. java.
// Интерфейс очереди для хранения символов с генерированием
// исключений
puЫic interface ICharQ {
// Поместить символ в очередь
void put(char ch) throws QueueFullException;
// Извлечь символ из очереди
char get() throws QueueEmptyException;
6. Скомпилируйте сначала новую версию исходноrо файла IQChar. j ava, а затем
исходный файл QExcDemo. j ava и запустите программу QExcDemo на выполнение.
В итоге вы получите следующий результат ее выполнения.
Попытка сохранения: А - ок
Попытка сохранения: в - ок
Попытка сохранения: с - ок
Попытка сохранения: D - ок
Попытка сохранения: Е - ок
Попытка сохранения: F - ок
Попытка сохранения: G - ок
Попытка сохранения: н - ок
Попытка сохранения: I - ок
Попытка сохранения: J - ок
Попытка сохранения: к
Очередь заполнена. Максимальный размер очереди: 10
Получение очередного символа: А
Получение очередного символа: в
Получение очередного символа: с
Получение очередного символа: D
Получение очередного символа: Е
Получение очередного символа: F
Получение очередного символа: G
Получение очередного символа: н
Получение очередного символа: I
Получение очередного символа: J
Получение очередного символа:
Очередь пуста.
Глава 9. Обработка исключений 351
-􀀚 Вопросы и упражнения для самопроверки
1. Какой класс находится на вершине иерархии исключений?
2. Объясните вкратце, как используются ключевые слова try и catch?
З. Какая ошибка допущена в приведенном ниже фрагменте кода?
// . . .
vals[l8] = 10;
catch (ArrayindexOutOfBoundsException ехс) {
// обработать ошибку
4. Что произойдет, если исключение не будет перехвачено?
5. Какая ошибка допущена в приведенном ниже фрагменте кода?
class А extends Exception { ...
class В extends А { ...
/ / . . .
try {
// . . .
catch (А ехс) { ... }
catch (В ехс) { . . . }
6. Может ли внутренний блок catch повторно генерировать исключение, которое
будет обработано во внешнем блоке catch?
7. Блок finally - последний фрагмент кода, выполняемый перед завершением
программы. Верно или неверно? Обоснуйте свой ответ.
8. Исключения какого типа необходимо явно объявлять с помощью оператора
throws, включаемого в объявление метода?
9. Какая ошибка допущена в приведенном ниже фрагменте кода?
class MyClass { // ...
/ / . . .
throw new MyClass();
10. Отвечая на вопрос 3 упражнения для самопроверки по материалу главы 6, вы создали
класс Stack. Добавьте в него специальные исключения, реагирующие на
попытку поместить элемент в переполненный стек и извлечь элемент из пустого
стека.
11. Назовите три причины, по которым могут генерироваться исключения.
12. Назовите два непосредственных подкласса класса ThrowaЫe.
13. Что такое групповой перехват исключений?
14. Следует ли перехватывать в программе исключения типа Error?

Глава 10
Ввод-вывод данных
354 Java 8: руководство для начинающих, 6-е издание
В этой главе ...
f􀂵 Потоки ввода-вывода
• Отличия байтовых и символьных потоков
􀂶 Классы для поддержки байтовых потоков
4'J1; Классы для поддержки символьных потоков
􀂷 Представление о встроенных потоках
􀂸 Использование байтовых потоков
'IJJ Использование байтовых потоков для файлового ввода-вывода
·􀂹 Автоматическое закрытие файлов с помощью оператора try с ресурсами
* Чтение и запись двоичных данных
􀂺 Манипулирование файлами с произвольным доступом
$ Использование символьных потоков
􀂻 Использование символьных потоков для файлового ввода-вывода
* Применение оболочек типов Java для преобразования числовых строк
в предыдущих главах вы уже сталкивались с примерами программ, в которых использовались
отдельные элементы системы ввода-вывода Java, в частности, метод
println (), но все это делалось без каких-либо формальных пояснений. В Java система
ввода-вывода основана на иерархии классов, и поэтому ее невозможно было рассматривать,
не узнав предварительно, что такое классы, наследование и исключения. Теперь,
когда вы уже в достаточной степени к этому подготовлены, мы можем приступить к обсуЖДению
средств ввода-вывода.
Следует отметить, что система ввода-вывода Java очень обширна и включает множество
классов, интерфейсов и методов. Отчасти это объясняется тем, что в Java определены
фактически две полноценные системы ввода-вывода: одна - для обмена байтами,
другая - для обмена символами. Здесь нет возможности рассмотреть все аспекты ввода-
вывода в Java, ведь для этого потребовалась бы отдельная книга. Поэтому в данной
главе будут рассмотрены лишь наиболее важные и часто используемые языковые средства
ввода-вывода. Правда, элементы системы ввода-вывода в Java тесно взаимосвязаны,
и поэтому, уяснив основы, вы легко освоите все остальные свойства этой системы.
Прежде чем приступать к рассмотрению системы ввода-вывода, необходимо сделать
следующее замечание. Классы, описанные в этой главе, предназначены для консольного
и файлового ввода-вывода. Они не используются для создания графических пользовательских
интерфейсов. Поэтому при создании оконных приложений они вам не пригодятся.
Для создания графических интерфейсов в Java предусмотрены другие средства.
Они будут представлены в главе 15 при рассмотрении аплетов, а также в главах 16 и 17,
знакомящих вас с библиотеками Swing и JavaFX соответственно.
Глава 1 О. Ввод-вывод данных 355
Потоковая организация системы
ввода-вывода Java
В Java операции ввода-вывода реализованы на основе потоков. Поток - это абстрактная
сущность, представляющая устройства ввода-вывода, которая выдает и получает
информацию. За связь потоков с физическими устройствами отвечает система
ввода-вывода, что позволяет работать с разными устройствами, используя одни и те же
классы и методы. Например, методы вывода на консоль в равной степени могут быть
использованы для записи данных в дисковый файл. Для реализации потоков используется
иерархия классов, содержащихся в пакете j ava. io.
Байтовые и символьные потоки
В современных версиях Java определены два типа потоков: байтовые и символьные.
(Первоначально в Java бьши доступны только байтовые потоки, но вскоре бьши реализованы
и символьные.) Байтовые потоки предостамяют удобные средства для упрамения
вводом и выводом байтов. Например, их можно использовать для чтения и записи
двоичных данных. Потоки этого типа особенно удобны при работе с файлами. С другой
стороны, символьные потоки ориентированы на обмен символьными данными. В них
применяется кодировка Unicode, и поэтому их легко интернационализировать. Кроме
того, в некоторых случаях символьные потоки более эффективны по сравнению с байтовыми.
Необходимость поддерживать два разных типа потоков ввода-вывода привела к
созданию двух иерархий классов (одна для байтовых, другая для символьных данных).
Из-за того что число классов достаточно велико, на первый взгляд система ввода-вывода
кажется сложнее, чем она есть на самом деле. Просто знайте, что в большинстве
случаев функциональные возможности символьных потоков повторяют возможности
байтовых.
Вместе с тем на самом нижнем уровне все средства ввода-вывода имеют байтовую
организацию. Символьные потоки лишь предостамяют удобные и эффективные средства,
адаmированные к специфике обработки символов.
Классы байтовых потоков
Байтовые потоки определены с использованием двух иерархий классов, на вершинах
которых находятся абстрактные классы InputStrearn и OutputStrearn соответственно.
В классе InputStrearn определены свойства, общие для байтовых потоков ввода,
а в классе OutputStrearn - свойства, общие для байтовых потоков вывода.
Производными от классов InputStrearn и OutputStrearn ямяются конкретные подклассы,
реализующие различные функциональные возможности и учитывающие особенности
обмена данными с разными устройствами, например ввода-вывода в файлы на
диске. Классы байтовых потоков перечислены в табл. 10.1. Пусть вас не пугает большое
количество этих классов: изучив один из них, вы легко освоите остальные.
356 Java 8: руководство дnя начинающих. 6-е издание
Таблица 10.1. Классы байтовых потоков
Класс байтового потока
BufferedinputStrearn
BufferedOutputStrearn
ByteArrayinputStrearn
ByteArrayOutputStrearn
DatainputStrearn
DataOutputStrearn
FileinputStrearn
FileOutputStrearn
FilterinputStrearn
FilterOutputStrearn
InputStrearn
ObjectinputStrearn
ObjectOutputStrearn
OutputStrearn
PipedinputStrearn
PipedOutputStrearn
PrintStrearn
PushЬackinputStrearn
SequenceinputStrearn
Описание
Буферизовонный входной поток
Буферизовонный выходной поток
Входной поток для чтения из байтового массива
Выходной поток для записи в байтовый массив
Входной поток, включающий методы для чтения стандартных типов
донныхJоvо
Выходной поток, включающий методы для записи стандартных типов
донных Jovo
Входной поток для чтения из файла
Выходной поток для записи в файл
Реализация класса InputStrearn
Реализация класса OutputStrearn
Абстрактный класс, описывающий потоковый ввод
Входной поток для объектов
Выходной поток для объектов
Абстрактный класс, описывающий потоковый вывод
Входной конал
Выходной конал
Выходной поток, включающий методы print () и println ()
Входной поток, позволяющий возвращать байты обратно в поток
Входной поток, сочетающий в себе несколько потоков, которые читаются
последовательно, один после другого
Классы символьных потоков
Символьные потоки также определены с использованием двух иерархий классов,
вершины которых на этот раз представлены абстрактными классами Reader и Wri ter
соответственно. Класс Reader и его подклассы используются для чтения, а класс Writer
и его подклассы - для записи данных. Конкретные классы, производные от классов
Reader и Wri ter, оперируют символами в кодировке Unicode.
Классы, производные от классов Reader и Writer, предназначены для выполнения
различных операций ввода-вывода символов. В целом символьные классы представляют
собой аналоги соответствующих классов, предназначенных для работы с байтовыми потоками.
Классы символьных потоков перечислены в табл. 10.2.
Таблица 10.2. Классы символьных потоков
Класс символьного потока Описание
BufferedReader Буферизовонный входной символьный поток
BufferedWri ter Буферизовонный выходной символьный поток
Глава 1 О. Ввод-вывод данных 357
Окончание табл. 10.2
Класс символьного потока Описание
CharArrayReader Входной поток дnя чтения из символьного массива
CharArrayWriter Выходной поток дnя записи в символьный массив
FileReader Входной поток для чтения из файла
FileWriter Выходной поток для записи в файл
FilterReader Фильтрующий входной поток
FilterWriter Фильтрующий выходной поток
InputStreamReader Входной поток, транслирующий байты в символы
LineNurnЬerReader Входной поток, подсчитывающий строки
OutputStreamWriter Выходной поток, транслирующий символы в байты
PipedReader Входной конал
PipedWriter Выходной конал
PrintWri ter Выходной поток, включающий методы print () и println ()
PushЬackReader Входной поток, позволяющий возвращать символы обратно в поток
Reader Абстрактный класс, описывающий символьный ввод
StringReader Входной поток для чтения из строки
StringWriter Выходной поток для записи в строку
Wri ter Абстрактный класс, описывающий символьный вывод
Встроенные потоки
Как вы уже знаете, во все программы на Java автоматически импортируется пакет
j ava. lang. В этом пакете определен класс System, инкапсулирующий некоторые свойства
среды выполнения. Помимо прочего, в нем содержатся предопределенные переменные
in, out и err, представляющие стандартные потоки ввода-вывода. Эти поля
объявлены как puЫic, final и static, т.е. к ним можно обращаться из любой другой
части программы, не ссылаясь на конкретный объект типа System.
Переменная System.out ссылается на стандартный выходной поток, который по
умолчанию связан с консолью. Переменная System. in ссылается на стандартный
входной поток, который по умолчанию связан с клавиатурой. И наконец, переменная
System. err ссылается на стандартный поток ошибок, который, как и выходной поток,
также связан по умолчанию с консолью. При необходимости каждый из этих потоков
может быть перенаправлен на любое другое устройство.
Поток System. in - это объект типа InputStream, а потоки System. out и System.
err - объекты типа PrintStream. Все эти потоки - байтовые, хотя обычно они используются
для чтения и записи символов с консоли и на консоль. Дело в том, что в
первоначальной спецификации Java, в которой символьные потоки вообще отсутствовали,
все предопределенные потоки были байтовыми. Как вы далее увидите, по мере
необходимости их можно поместить в классы-оболочки символьных потоков.
358 Java 8: руководство для начинающих. 6-е издание
Использование байтовых потоков
Начнем рассмотрение системы ввода-вывода в Java с байтовых потоков. Как уже
отмечалось, на вершине иерархии байтовых потоков находятся классы InputStream и
OutputStream. Методы класса InputStream перечислены в табл. 10.3, а методы класса
OutputStream - в табл. 10.4. При возникновении ошибок во время выполнения методы
классов InputStream и OutputStream могут генерировать исключения IOException.
Определенные в этих двух абстрактных классах методы доступны во всех подклассах.
Таким образом, они образуют минимальный набор функций ввода-вывода, общий для
всех байтовых потоков.
Консольный ввод
Первоначально байтовые потоки были единственным средством, позволяющим выполнять
консольный ввод, и во многих существующих программах на Java для этой цели
по-прежнему используются исключительно байтовые потоки. Сейчас имеется возможность
выбора между байтовыми и символьными потоками. В коммерческом коде для чтения
консольного ввода предпочтительнее использовать символьные потоки. Такой подход
упрощает интернационализацию программ и облегчает их сопровоЖдение. Ведь намного
удобнее оперировать непосредственно символами, не тратя время и усилия на преобразование
символов в байты, и наоборот. Однако в простых служебных и прикладных программах,
где данные, введенные с клавиатуры, обрабатываются непосредственно, удобно пользоваться
байтовыми потоками. Именно по этой причине они здесь и рассматриваются.
Таблица 10.3. Методы, определенные в классе InputStream
Метод
int availaЫe ()
void close ()
void mark (int numBytes)
boolean markSupported ()
int read(}
int read (byte buffer[])
Описание
Возвращает количество байтов ввода, доступных в донный момент
для чтения
Закрывает источник ввода. Дальнейшие попытки чтения будут гене·
рировоть исключение IOException
Помещает в текущую позицию входного потока метку, которая будет
находиться том до тех пор, пока не будет прочитано количество байтов,
определяемое параметром numBytes
Возвращает значение true, если методы mark () и reset (} подо.ер-
живаются вызывающим потоком
Возвращает целочисленное представление следующего байта в потоке.
При достижении конца потока возвращается значение -1
Пытается прочитать buffer. length байтов в массив buffer, возвращая
фактическое количество успешно прочитанных байтов. По
достижении конца потока возвращается значение -1
int read (byte buffer[], Пытается прочитать numBytes байтов в массив buffer, начиная с
int offset, int numBytes) элемента buffer [ offset], и возвращает фактическое количество
успешно прочитанных байтов. По достижении конца потока возвра-
void reset (}
long skip (long numBytes)
щается значение -1
Сбрасывает входной указатель но ранее установленную метку
Пропускает numBytes входных байтов, возвращая фактическое количество
пропущенных байтов
Глава 1 О. Ввод-вывод данных 359
Таблица 10.4. Методы, определенные в классе OutputStream
Метод
void close ( )
void flush ()
void write (int Ь)
void write (byte buffer[])
void write (byte buffer[],
int offset, int numBytes)
Описание
Закрывает выходной поток. Дальнейшие попытки записи будут генерировать
исключение IOException
Выполняет принудительную передачу содержимого выходного буфера
в место назначения (тем самым очищая выходной буфер)
Записывает один байт в выходной поток. Обратите внимание на
то, что параметр имеет тип int, что позволяет вызывать метод
write () с выражениями, не приводя их к типу byte
Записывает полный массив байтов в выходной поток
Записывает часть массива buffer в количестве numBytes байтов,
начиная с элемента buffer[offset]
Поток System. in является экземпляром класса InputStream, и благодаря этому обеспечивается
автоматический доступ к методам, определенным в классе InputStream.
К сожалению, для чтения байтов в классе InputStream определен только один метод
ввода: read () . Ниже приведены три возможные формы объявления этого метода.
int r ead() throws IOException
int r ead(byte data[J) throws IOException
int r ead(byte data[], int start, int max) throws IOException
В главе 3 было показано, как пользоваться первой формой метода read () для чтения
отдельных символов с клавиатуры (а по сути, из потока стандартного ввода System.
in). Достигнув конца потока, этот метод возвращает значение -1. Вторая форма метода
read () предназначена для чтения данных из входного потока в массив da ta. Чтение
завершается по достижении конца потока, по заполнении массива или при возникновении
ошибки. Метод возвращает количество прочитанных байтов или -1, если достигнут
конец потока. И третья форма данного метода позволяет разместить прочитанные
данные в массиве data, начиная с элемента, заданного с помощью индекса start.
Максимальное количество байтов, которые могут быть введены в массив, определяется
параметром тах. Метод возвращает число прочитанных байтов или значение -1, если
достигнут конец потока. При возникновении ошибки в каждой из этих форм метода
read () генерируется исключение IOException. Признак конца потока ввода при чтении
из System. in устанавливается после нажатия клавиши <Enter>.
Ниже приведен пример короткой программы, демонстрирующий чтение байтов из
потока ввода System. in в массив. Следует иметь в виду, что исключения, которые могут
быть сгенерированы при выполнении данной программы, обрабатываются за пределами
метода main (). Такой подход часто используется при чтении данных с консоли. По мере
необходимости вы сможете самостоятельно организовать обработку ошибок.
// Чтение байтов с клавиатуры в массив
import java.io.*;
cl ass ReadBytes {
puЫic static void main(String args[J)
throws IOException {
byte data[J = new byte[lOJ;
360 Java 8: руководство для начинающих. 6-е издание
System.out.println("Bвeдитe символы.");
System. in. read ( data) ; Прочитать массив бантов, введенных с мавнатуры.
System.out.print("Bы ввели: ");
for(int i=O; i < data.length; i++)
System.out.print((char) data[i]);
Выполнение этой программы дает следующий результат:
Введите символы.
Read Bytes
Вы ввели: Read Bytes
Запись консольного вывода
Как и в случае консольноrо ввода, в Java для консольноrо вывода первоначально
были предусмотрены только байтовые потоки. Символьные потоки были добавлены
в версии Java 1.1. Для переносимоrо кода в большинстве случаев рекомендуется использовать
символьные потоки. Однако, поскольку поток System.out - байтовый, он
по-прежнему широко используется для побайтовоrо вывода данных на консоль. Именно
такой подход до сих пор применялся в примерах, представленных в книrе. Поэтому существует
необходимость рассмотреть ero более подробно.
Вывод данных на консоль проще всеrо осуществлять с помощью у же знакомых вам
методов print () и println (). Эrи методы определены в классе PrintStream (на обьект
данноrо типа ссылается переменная потока стандартноrо вывода System.out). Несмотря
на то что System. out является байтовым потоком, ero вполне можно использовать
для простоrо консольноrо вывода.
Поскольку класс PrintStream является выходным потоком, производным от класса
OutputStream, он также реализует низкоуровневый метод wri te () , который может
быть использован для записи на консоль. Ниже приведена простейшая форма метода
wri te (), определенноrо в PrintStream:
void write(int byteval)
Данный метод записывает в файл значение байта, переданное с помощью параметра
byteval. Несмотря на то что этот параметр объявлен как int, в нем учитываются
только младшие 8 бит. Ниже приведен простой пример программы, в которой метод
write () используется для вывода символа s и символа перевода строки на консоль.
// Демонстрация метода System.out.write()
class WriteDemo (
puЫic static void main (String args []) {
int Ь;
ь = 's';
System.out.write(b);
System.out.write('\n');
----- Вывод бантов на экрон
Вам не часто придется использовать метод write () для вывода на консоль, хотя в
некоторых ситуациях он оказывается весьма кстати. Для этой цели намноrо удобнее
пользоваться методами print () и println ().
Глава 1 О. Ввод-вывод данных 361
В классе PrintStream реализованы два дополнительных метода, p rintf () и
format (), которые позволяют управлять форматированием выводимых данных. Например,
они позволяют указать для выводимых данных количество десятичных цифр,
минимальную ширину поля или способ представления отрицательных числовых значений.
И хотя эти методы не используются в примерах, представленных в данной книге,
вам стоит обратить на них пристальное внимание, поскольку они могут пригодиться вам
при написании прикладных программ.
Чтение и запись файлов
с использованием байтовых потоков
Язык Java предоставляет множество классов и методов, позволяющих читать и записывать
данные из файлов и в файлы. Разумеется, чаще всего приходится обращаться
к файлам, хранящимся на дисках. В Java все файлы имеют байтовую организацию, и
поэтому для побайтового чтения и записи данных из файла и в файл предусмотрены
соответствующие методы. Таким образом, файловые операции с использованием байтовых
потоков довольно распространены. Кроме того, для байтовых потоков ввода-вывода
в файлы в Java допускается создавать оболочки в виде символьных объектов. Классыоболочки
будут рассмотрены далее.
Байтовые потоки, связанные с файлами, создаются с помощью классов Filelnput
Stream или FileOutputStream. Чтобы открыть файл, достаточно создать объект одного
из этих классов, передав конструктору имя файла в качестве параметра. Открытие файла
необходимо для того, чтобы с ним можно было выполнять файловые операции чтения
и записи.
Ввод данных из файла
Файл открывается для ввода созданием объекта типа FileinputStream. Для этой
цели чаще всего используется следующая форма конструктора данного класса:
FileinputStream(String имя_файла) throws FileNotFoundException
Имя файла, который требуется открыть, передается конструктору в параметре
имя_файла. Если указанный файл не существует, генерируется исключение FileNot
FoundException.
Для чтения данных из файла используется метод read (). Ниже приведена форма
объявления этого метода, которой мы будем пользоваться в дальнейшем.
int read() throws IOException
При каждом вызове метод read () читает байт из файла и возвращает его в виде целочисленного
значения. По достижении конца файла этот метод возвращает значение
-1. При возникновении ошибки метод генерирует исключение IOException. Как видите,
в этой форме метод read () выполняет те же самые действия, что и одноименный
метод, предназначенный для ввода данных с консоли.
Завершив операции с файлом, следует закрыть его с помощью метода close (), имеющего
следующую общую форму объявления:
void close() throws IOException
362 Java 8: руководство для начинающих. 6-е издание
При закрытии файла освобождаются связанные с ним системные ресурсы, которые
вновь можно будет использовать для работы с другими файлами. Если этого не сделать,
возможна утечка памяти из-за того, что часть памяти остается выделенной для ресурсов,
которые больше не используются.
Ниже приведен пример программы, в которой метод read () используется для получения
и отображения содержимого текстового файла. Имя файла указывается в командной
строке при запуске программы. Обратите внимание на то, что ошибки ввода-вывода
обрабатываются с помощью блока try/catch.
/* Отображение текстового файла.
*/
При вызове этой программы следует указать имя файла,
содержимое которого требуется просмотреть.
Например, для вывода на экран содержимого файла TEST.TXT
необходимо ввести в командной строке следующую команду:
java ShowFile TEST.TXT
import java.io.*;
class ShowFile {
puЫic static void main(String args[])
{
int i;
FileinputStream fin;
// Прежде всего необходимо убедиться в том, что программе
// передается имя файла
if(args.length != 1) {
System.out.println("Иcnoльзoвaниe: ShowFile имя_файла");
return;
try
fin = new FilelnputStream(args(O]);
catch(FileNotFoundException ехс) {
System.out.println("Фaйл не найден");
return;
-----Открыть фойn
try
// Читать байты, пока не встретится символ EOF
do {
i = fin.read(); 4-------------Чтенне нз фойnо
if(i != -1) System.out.print((char) i);
while(i != -1); 4------------Значение переменной i, ровное -1,
catch(IOException ехс) {
System.out.println("Oшибкa при чтении файла");
try
означает достижение конца фойnа
f in. close () ; ..---------------Закрыть фойn
} catch(IOException ехс) {
Глава 1 О. Ввод-вывод данных 363
System.out.println("Oшибкa при закрытии файла");
Обратите внимание на то, что в этом примере файловый поток закрывается после завершения
выполнения блока try, в котором осуществляется чтение данных. Такой способ
не всегда оказывается удобным, и поэтому в Java предоставляется более совершенный
и чаще используемый способ, предполагающий помещение вызова метода close ()
в блок finally. В этом случае все методы, получающие доступ к файлу, помещаются в
блок try, а для закрытия файла используется блок finally. Благодаря этому файл закрывается
независимо от того, как завершится блок try. Учитывая это, перепишем блок
try из предьщущего примера в таком виде.
try {
do {
i = fin. read () ;
if(i != -1) System.out.print((char) i);
while(i !=-1);
catch(IOException ехс) {
System.out.println("Oшибкa при чтении файла");
// Для закрытия файла используется блок finally
finally { 􀀄41--􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅􀀅-,
/ / Закрыть файл при выходе из блока try L Испопьзоаоть бп􀃔ж finally
t r у { , - - дnя зокрwтн11 фонпо
fin.close(); 􀃕40--􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃖􀃗
catch(IOException ехс) (
System.out.println("Oшибкa при закрытии файла");
Данный способ имеет, в частности, то преимущество, что в случае аварийного завершения
программы из-за возникновения исключения, не связанного с операциями
ввода-вывода, файл все равно будет закрываться в блоке finally. И если с аварийным
завершением простых программ, как в большинстве примеров книги, с непредвиденными
исключениями еще можно как-то мириться, то в крупных программах подобная
ситуация вряд ли может считаться допустимой. Использование блока finally позволяет
справиться с этой проблемой.
Иногда части программы, ответственные за открытие файла и осуществление доступа
к нему, удобнее поместить в один блок try (не разделяя их), а для закрытия файла
использовать блок finally. В качестве примера ниже приведена видоизмененная версия
рассмотренной выше программы ShowFile.
/* В этой версии программы те ее части, которые отвечают
за открытие файла и получение доступа к нему, помещены
в один блок try. Файл закрывается в блоке finally.
*/
import java.io.*;
class ShowFile (
puЫic static void main(String args[])
(
364 Java 8: руководство для начинающих, 6-е издание
int i;
FileinputStream fin = null; ,. ___ Иннцнаnиэация переменной fin значением null
// Прежде всего необходимо убедиться в том, что программе
// передается имя файла
if(args.length != 1) {
System.out.println("Иcпoльзoвaниe: ShowFile имя_файла");
return;
// Открытие файла, чтение из него символов, пока
// не встретится признак конца файла EOF, и
// последующее закрытие файла в блоке finally
try {
fin = new FileinputStream(args[O]);
do {
i = fin.read();
if(i != -1) System.out.print((char) i);
while(i != -1);
catch(FileNotFoundException ехс) {
System.out.println("Фaйл не найден.");
catch(IOException ехс) {
System.out.println("Owибкa ввода-вывода");
finally {
// Файл закрывается в любом случае
try {
if(fin != null) fin.close(); ----- Закрыть fin,ecnи ан не null
catch(IOException ехс) {
System.out.println("Oшибкa при закрытии файла");
Обратите внимание на то, что переменная fin инициализируется значением null.
В блоке finally файл закрывается только в том случае, если значение переменной fin
не равно null. Это будет работать, поскольку переменная fin не содержит значение
null лишь в том случае, если файл был успешно открыт. Следовательно, если во время
открытия файла возникнет исключение, метод close () не будет вызываться.
В этом примере блок try/catch можно сделать несколько более компактным.
Поскольку исключение FileNotFoundException является подклассом исключения
IOException, его не нужно перехватывать отдельно. В качестве примера ниже приведен
блок catch, которым можно воспользоваться для перехвата обоих типов исключений,
избегая независимого перехвата исключения FileNotFoundException. В данном случае
выводится стандартное сообщение о возникшем исключении с описанием ошибки.
catch(IOException ехс) {
System.out.println("Owибкa ввода-вывода: " + ехс);
finally {
СПРОСИМ У ЭКСПЕРТА
Глава 1 О. Ввод-вывод данных 365
ВОПРОС. Метод read () возвращает значение -1 по достижении конца файла, но
д11я ошибки при попытке доступа к файлу специально возвращаемое значение
не предусмотрено. Почему?
ОТВЕТ. В Java д11я обработки ошибок используются исключения. Поэтому если метод
read () или любой другой метод возвращает конкретное значение, то это
автоматически означает, что в процессе его работы ошибка не возникла. Такой
подход многие считают гораздо более удобным, чем использование специальных
кодов ошибок.
При таком подходе любая ошибка, в том числе и ошибка открытия файла, будет обработана
единственным оператором catch. Благодаря своей компактности в большинстве
примеров ввода-вывода, представленных в этой книге, используется именно такой
способ. Следует, однако, иметь в виду, что он может оказаться не вполне пригодным в
тех случаях, когда требуется отдельно обрабатывать ошибку открытия файла, вызванную,
например, опечаткой при вводе имени файла. В подобных случаях рекомендуется
сначала пред11ожить пользователю заново ввести имя файла, а не входить сразу же в
блок try, в котором осуществляется доступ к файлу.
Запись в файл
Чтобы открыть файл д11я записи, следует создать объект типа FileOutputStream.
Ниже приведены две наиболее часто используемые формы конструктора этого класса.
FileOutputStream(String имя_файла) throws FileNotFoundException
FileOutputStream(String имя_файла, boolean append)
throws FileNotFoundException
В случае невозможности создания файла возникает исключение FileNotFound
Exception. Если файл с указанным именем уже существует, то в тех случаях, когда используется
первая форма конструктора, этот файл удаляется. Вторая форма отличается
от первой наличием параметра append. Если этот параметр принимает значение true, то
записываемые данные добавляются в конец файла. В противном случае старые данные в
файле перезаписываются новыми.
Для записи данных в файл вызывается метод wri te (). Наиболее простая форма объявления
этого метода выглядит так:
void write(int byteval) throws IOException
Данный метод записывает в поток байтовое значение, передаваемое с помощью параметра
byteva 1. Несмотря на то что этот параметр объявлен как int, учитываются
только младшие 8 бит его значения. Если в процессе записи возникает ошибка, генерируется
исключение IOException.
По завершении работы с файлом его нужно закрыть с помощью метода close () ,
представленного ниже.
void close() throws IOException
366 Java 8: руководство для начинающих. 6-е издание
При закрытии файла освобождаются связанные с ним системные ресурсы, что позволяет
использовать их в дальнейшем для работы с друrими файлами. Кроме того, процедура
закрытия файла гарантирует, что оставшиеся в буфере данные будУТ записаны на диск.
В следующем примере осуществляется копирование текстового файла. Имена исходного
и целевого файлов указываются в командной строке.
/* Копирование текстового файла.
*/
При вызове этой программы следует указать имена исходного
и целевого файлов. Например, для копирования файла FIRST.TXT
в файл SECOND.TXT в командной строке нужно ввести следующую
команду:
java CopyFile FIRST.TXT SECOND.TXT
import java.io.*;
class CopyFile {
puЫic static void main(String args[J) throws IOException
{
int i;
FileinputStream fin = null;
FileOutputStream fout = null;
// Прежде всего необходимо убедиться в том, что программе
// передаются имена обоих файлов
if (args. length ! = 2) {
System.out.println("Иcпoльзoвaниe: CopyFile откуда куда");
return;
// Копирование файла
try {
// Попытка открытия файлов
fin = new FileinputStream(args[O]);
fout = new FileOutputStream(args[l]);
do {
i = fin. read () ; 4 Прочнтот�. байты
􀀘из одиоrо файnа if(i != -1) fout.write(i); ... ,. ________ ...,_ и записот�.адруrой
while(i != -1);
catch(IOException ехс) {
System.out.println("Oшибкa ввода-вывода: " + ехс);
} finally {
try {
if(fin != null) fin.close();
catch(IOException ехс) {
System.out.println("Oшибкa при закрытии входного файла");
try {
if(fout != null) fout.close();
catch(IOException ехс) {
System.out.println("Oшибкa при закрытии выходного файла");
Глава 1 О. Ввод-вывод данных 367
Автоматическое закрытие файлов
В примерах программ, представленных в предьщущем разделе, для закрытия файлов,
которые больше не нужны, метод close () вызывался явным образом. Такой способ
закрытия файлов используется еще с тех пор, как вышла первая версия Java. Именно
поэтому он часто встречается в существующих программах. Более того, он до сих пор
остается вполне оправданным и полезным. Однако в версию JDK 7 включено новое
средство, предоставляющее другой, более рациональный способ управления ресурсами,
в том числе и потоками файлового ввода-вывода, автоматизирующий процесс закрытия
файлов. Этот способ основывается на новой разновидности оператора try, называемой
оператором try с ресурсами, а иногда еще - автоматическим управлением ресурсами.
Главное преимущество оператора try с ресурсами заключается в том, что он предотвращает
ситуации, в которых файл (или другой ресурс) непреднамеренно остается неосвобожденным
и после того, как необходимость в его использовании отпала. Как пояснялось
ранее, если не позаботиться о своевременном закрытии файлов, то это может
привести к утечке памяти и прочим осложнениям в работе программы.
Так выглядит общая форма оператора try с ресурсами.
try (описание_ресурса) {
// использовать ресурс
Здесь описание
_
ресурса включает в себя объявление и инициализацию ресурса,
такого как файл. По сути, в это описание входит объявление переменной, которая
инициализируется ссылкой на объект управляемого ресурса. По завершении блока try
объявленный ресурс автоматически освобождается. Если этим ресурсом является файл,
то он автоматически закрывается, что избавляет от необходимости вызывать метод
close () явным образом. Оператор try с ресурсами также может включать блоки catch
и finally.
Область применимости таких операторов try ограничена ресурсами, которые реализуют
интерфейс AutoCloseaЬle, определенный в пакете j ava. lang. В этом интерфейсе
определен метод close (). Интерфейс AutoCloseaЫe наследуется интерфейсом
CloseaЬle, определенным в пакете j ava. io. Оба интерфейса реализуются классами
потоков, в том числе FileinputStream и FileOutputStream. Следовательно, оператор
try с ресурсами может применяться вместе с потоками, включая потоки файлового ввода-
вывода.
В качестве примера ниже приведена переработанная версия программы ShowFile, в
которой оператор try с ресурсами используется для автоматического закрытия файла.
/* В этой версии программы ShowFile оператор try с ресурсами
применяется для автоматического закрытия файла, когда в нем
больше нет необходимости.
*/
import java.io.*;
class ShowFile {
puЫic static void main(String args(])
{
int i;
368 Java 8: руководство для начинающих. 6-е издание
// Прежде всего необходимо убедиться в том, что программе
// передаются имена обоих файлов
if(args.length != 1) (
Systern.out.println("Иcпoльзoвaниe: ShowFile имя_файла");
return;
// Использование try с ресурсами для открытия
// файла с последующим его закрытием после того,
// как будет покинут блок try
try(FileinputStrearn fin = new FileinputStrearn(args[OJ))
do ( 'l i = fin.read();
if(i != -1) Systern.out.print((char) i);
while(i != -1);
catch(IOException ехс) (
Systern.out.println("Oшибкa ввода-вывода: " + ехс);
Бnок оnероторо try
с ресурсами
Обратите внимание на то, как открывается файл в операторе try с ресурсами:
try(FileinputStrearn fin = new FileinputStrearn(args[O])) (
Здесь сначала объявляется переменная fin типа FileinputStream, а затем этой переменной
присваивается ссылка на файл, который выступает в роли объекта, открываемого
с помощью конструктора класса FileinputStream. Таким образом, в данной
версии программы переменная fin является локальной по отношению к блоку try и
создается при входе в этот блок. При выходе из блока try файл, связанный с переменной
fin, автоматически закрывается с помощью неявно вызываемого метода close ().
Это означает, что теперь отсутствует риск того, что вы забудете закрыть файл путем явного
вызова метода close () . В этом и состоит главное преимущество автоматического
управления ресурсами.
Важно понимать, что ресурс, объявленный в операторе try, неявно принимает модификатор
final. Это означает, что после создания ресурсной переменной ее значение
не может быть изменено. Кроме того, ее область действия ограничивается блоком оператора
try.
С помощью одного подобного оператора try можно управлять несколькими ресурсами.
Для этого достаточно указать список объявлений ресурсов, разделенных точкой
с запятой. В качестве примера ниже приведена переработанная версия программы
CopyFile. В этой версии оба ресурса, fin и fout, управляются одним оператором try.
/* Версия программы CopyFile, в которой используется оператор
*/
try с ресурсами. В ней демонстрируется управление двумя ресурсами
(в данном случае - файлами) с помощью единственного оператора try.
irnport java.io.*;
class CopyFile (
puЫic static void rnain(String args[J) throws IOException
Глава 1 О. Ввод-в ывод данных 369
int i;
// Прежде всего необходимо убедиться в том, что программе
// передаются имена обоих файлов
if(args.length != 2) {
System.out.println("Иcпoльзoвaниe: CopyFile откуда куда ");
return;
// Открытие двух файлов и управление ими с помощью оператора try
try (FileinputStream fin = new FileinputStream(args[O]);
FileOutputStream fout = new FileOutputStream(args[l])􀃘)
{
do {
i = fin.read();
if(i != -1) fout.write(i);
while(i != -1);
catch(IOException ехс) {
System.out.println("Oшибкa ввода-вывода: "+ ехс);
Управnенне
двумя ресурсами
Обратите внимание на то, как входной и выходной файлы открываются в операторе
try.
try (FileinputStream fin = new FileinputStream(args[O]);
FileOutputStream fout = new FileOutputStream(args[l]))
По завершении этого блока try оба файла, на которые ссылаются переменные fin
и fout, будут автоматически закрыты. Если сравнить эту версию программы с предыдущей,
то можно заметить, что ее исходный код намного компактнее. Возможность создания
более компактного кода является еще одним, дополнительным преимуществом
оператора try с ресурсами.
Стоит упомянуть еще об одной особенности оператора try с ресурсами. Вообще
говоря, возникшее при выполнении блока try исключение может породить другое исключение
при закрытии ресурса в блоке finally. В случае "обычного" оператора try
первоначальное исключение теряется, будучи прерванным вторым исключением. Но в
случае оператора try с ресурсами второе исключение подавляется. При этом оно не теряется,
а просто добавляется в список подавленных исключений, связанных с первым
исключением. Этот список можно получить, вызвав метод getSuppressed () , определенный
в классе ThrowaЫe.
Благодаря своим преимуществам оператор try с ресурсами будет использоваться
во многих, хотя и не всех, оставшихся примерах программ в книге. Однако не менее
важным остается и умение использовать рассмотренный ранее традиционный способ
освобождения ресурсов с помощью явного вызова метода close () . И на то имеется ряд
веских причин. Во-первых, среди уже существующих и повсеместно эксплуатируемых
программ на Java немало таких, в которых применяется традиционный способ управления
ресурсами. Поэтому вы должны как следует усвоить традиционный подход и уметь
370 Java 8: руководство для начинающих, 6-е издание
использовать его для сопровождения устаревшего кода. Во-вторых, переход к использованию
версии JDK 7 может произойти не сразу, а следовательно, вы будете вынуждены
работать с предыдущей версией данного комплекта. В этом случае воспользоваться преимуществами
оператора try с ресурсами не удастся, и придется применять традиционный
способ управления ресурсами. И наконец, в некоторых случаях закрытие ресурса
явным образом оказывается более эффективным, чем его автоматическое освобождение.
И все же, если вы работаете с версией JDK 7, JDK 8 или более поздней, вариант автоматического
управления ресурсами, как более рациональный и надежный, следует считать
предпочтительным.
Чтение и запись двоичных данных
В приведенных до сих пор примерах программ читались и записывались байтовые
значения, содержащие символы в коде ASCII. Но аналогичным образом можно организовать
чтение и запись любых типов данных. Допустим, требуется создать файл, содержащий
значения типа int, douЫe или short. Для чтения и записи простых типов
данных в Java предусмотрены классы DatainputStream и DataOutputStream.
Класс DataOutputStream реализует интерфейс DataOutput, в котором определены
методы, позволяющие записывать в файл значения любых примитивных типов. Следует,
однако, иметь в виду, что данные записываются во внутреннем двоичном формате, а не
в виде последовательности символов. Методы, наиболее часто применяемые для записи
простых типов данных в Java, приведены в табл. 10.5. При возникновении ошибки ввода-
вывода каждый из них может генерировать исключение IOException.
Таблица 10.5. Наиболее часто используемые методы вывода данных,
определенные в классе DataOUtputStream
Метод
void wri teBoolean (boolean va 1)
void writeByte (int val)
void writeChar (int val)
void writeDouЬle(douЫe val)
void writeFloat(float val)
void writeint (int val)
void writeLong(long val)
void writeShort (int val)
Описание
Записывает логическое значение, определяемое параметром
val
Записывает младший байт целочисленного значения, определяемого
параметром val
Записывает значение, определяемое параметром val, интерпретируя
его как символ
Записывает значение типа douЫe, определяемое параметром
val
Записывает значение типа float, определяемое параметром
val
Записывает значение типа int, определяемое параметром
val
Записывает значение типа long, определяемое параметром
val
Записывает целочисленное значение, определяемое параметром
val, преобразуя его в тип short
Глава l О. Ввод-вывод данных 371
Ниже приведен конструктор класса DataOutputStream. Обратите внимание на то,
что при вызове ему передается экземпляр класса OutputStream.
DataOutputStream(OutputStream outputStream)
Здесь outputStream - выходной поток, в который записываются данные. Для того
чтобы организовать запись данных в файл, следует передать конструктору в качестве параметра
outputStream объект типа FileOutputStream.
Класс DatainputStream реализует интерфейс Datainput, предоставляющий методы
для чтения всех примитивных типов данных Java (табл. 10.6). При возникновении
ошибки ввода-вывода каждый из них может генерировать исключение IOException.
Класс DatainputStream построен на основе экземпляре класса InputStream, перекрывая
его методами для чтения различных типов данных Java. Однако в потоке типа
DatainputStream данные читаются в двоичном виде, а не в удобной для чтения форме.
Ниже приведен конструктор класса DatainputStream:
DatainputStream(InputStream inputStream)
где inputStream - это поток, связанный с создаваемым экземпляром класса Data
InputStream. Для того чтобы организовать чтение данных из файла, следует передать
конструктору в качестве параметра inputStream объект типа FileinputStream.
Таблица 10.6. Наиболее часто используемые методы ввода данных,
определенные в классе DatainputStream
Метод
boolean readBoolean ()
byte readByte ()
char readChar ()
douЫe readDouЫe ()
float readFloat ()
int readint ()
long readLong ()
short readShort ()
Описание
Читает значение типа boolean
Читает значение типа byte
Читает значение типа char
Читает значение типа douЫe
Читает значение типа float
Читает значение типа int
Читает значение типа long
Читает значение типа short
Ниже приведен пример программы, демонстрирующий использование классов Data
OutputStream и DatainputStream. В этой программе данные разных типов сначала записываются
в файл, а затем читаются из него.
// Запись и чтение двоичных данных
import java.io.*;
class RWData {
puЫic static void main(String args[J)
{
int i = 10;
douЫe d = 1023.56;
boolean Ь = true;
372 Java 8: руководство дnя начинающих. 6-е издание
// Записать ряд значений
try (DataOutputStream dataOut
new DataOutputStream(new FileOutputStream("testdata")))
System.out.println("Зaпиcaнo: " + i);
dataOut.writeint(i);
System.out.println ("Записано: " + d); ..- ----------1
dataOut.writeDouЬle(d); Запись даоичиwх
-ДОИНWХ • фойn
System.out.println("Зaпиcaнo: " + Ь ); testdata
dataOut.writeBoolean(b);
System.out.println("Зaпиcaнo: " + 12.2 * 7.4); ..- -----'
dataOut.writeDouЫe(l2.2 * 7.4);
catch(IOException ехс) {
System.out.println("Oшибкa при записи");
return;
System.out.println();
// А теперь прочитать записанные значения
try (DatainputStream datain =
new DatainputStream(new FileinputStream("testdata")))
i datain.readint();
System.out.println("Пpoчитaнo: " + i); .. :::;о---------􀁪
d = datain.readDouЫe();
System.out.println("Пpoчитaнo: " + d ); ..- ---------1
Ь = datain.readBoolean();
System.out.println("Пpoчитaнo: " + Ь);----------
d = datain.readDouЫe();
Чтение даоичиwх
-донных из файnа
testdata
System.out.println("Пpoчитaнo: " + d); ..􀁫- -------􀁬
catch(IOException ехс) {
System.out.println("Oшибкa при чтении");
Выполнение этой программы дает следующий результат.
Записано: 10
Записано: 1023.56
Записано: true
Записано: 90.28
Прочитано: 10
Прочитано: 1023.56
Прочитано: true
Прочитано: 90.28
Глава 1 О. Ввод-вывод данных 373
Упражнение 1 0.1 Утилита сравнения файлов
:
.
.·
·
c
·
·
·;··
·
􀁴
·
··
·
P·· ·
·
F··
·
􀁵
:
·
··i
·
·
.
􀁶
·
·
.
􀁷.·
.
·.:.·
.
􀁸
:.·
.
􀁹
.
·
.
􀁺
.
·
.
􀁻
.
·
.·
..
·.\
.
В этом проекте предстоит соз д ать про стую, но очень полезную утилиту для сравнения содержимого файл ов. В ходе выпо лнени я этой сервисной программы сначала открыв аются два сравниваемых файла, а затем данные
читаются из них и сравниваются по соответствующему количеству байтов. Если на
какой-то стадии операция сравнения дает отрицательный результат, это означает, что
содержимое обоих файлов не одинаково. Если же конец обоих файлов достигается одновременно,
это означает, что они содержат одинаковые данные. Поэтапное описание
процесса создания программы приведено ниже.
1. Создайте файл CompFiles. java.
2. Введите в файл CompFiles. java приведенный ниже исходный код.
/*
*/
Упражнение 10.1
Сравнение двух файлов.
При вызове этой программы следует указать имена
сравниваемых файлов. Например, чтобы сравнить файл
FIRST.TXT с файлом SECOND.TXT, в командной строке
нужно ввести следующую команду:
java CompFile FIRST.TXT SECOND.TXT
import java.io.*;
class CompFiles
puЫic static void main(String args[])
{
int i=O, j=O;
// Прежде всего необходимо убедиться в том, что программе
// передаются имена обоих файлов.
if (args. length ! =2 ) {
System.out.println("Иcпoльзoвaниe: CompFiles файл! файл2");
return;
// Сравнить файлы
try (FileinputStream fl
FileinputStream f2
new FileinputStream(args[O]);
new FileinputStream(args[l]))
// Проверить содержимое каждого файла
do {
i = f1. read () ;
j = f2. read () ;
if(i != j) break;
while (i != -1 && j != -1);
37 4 Java 8: руководство для начинающих. 6-е издание
if(i != j)
System.out.println("Coдepжимoe файлов отличается");
else
System.out.println("Coдepжимoe файлов совпадает");
catch(IOException ехс) {
System.out.println("Omибкa ввода-вывода: " + ехс);
3. Перед запуском программы скопируйте файл CompFiles. j ava во временный
файл temp, а затем введите в командной строке следующую команду:
java CompFiles CompFiles.java temp
Программа сообщит, что файлы имеют одинаковое содержимое. Далее сравните
файл CompFiles. java с рассмотренным ранее файлом CopyFile. java, введя в
командной строке следующую команду:
java CompFiles CompFiles.java CopyFile.java
Эти файлы имеют различное содержимое, о чем и сообщит программа CompFiles.
4. Попытайтесь самостоятельно включить в программу CompFiles дополнительные
возможности. В частности, предусмотрите возможность выполнять сравнение без
учета регистра символов. Кроме того, программу CompFiles можно доработать
так, чтобы она выводила номер позиции, в которой находится первая пара отличающихся
символов.
Файлы с произвольным доступом
До сих пор мы имели дело с последовательными файлами, содержимое которых вводилось
и выводилось побайтово, т.е. строго по порядку. Но в Java предоставляется также
возможность обращаться к хранящимся в файле данным в произвольном порядке.
Для этой цели предусмотрен класс RandomAccessFile, инкапсулирующий файл с произвольным
доступом. Класс RandomAccessFile не является производным от класса
InputStream или OutputStream. Вместо этого он реализует интерфейсы Datainput и
DataOutput, в которых объявлены основные методы ввода-вывода. Кроме того, он поддерживает
запросы с позиционированием, т.е. позволяет задавать положение указателя
файла произвольным образом. Ниже приведен конструктор класса RandomAccessFile,
который мы будем использовать далее.
RandomAccessFile(String имя_файла, String доступ)
throws FileNotFoundException
Здесь конкретный файл указывается с помощью параметра имя_файла, а параметр
доступ определяет, какой именно тип доступа будет использоваться для обращения к
файлу. Если параметр доступ принимает значение "r", то данные могут читаться из
файла, но не записываться в него. Если же указан тип доступа "rw", то файл открывается
как для чтения, так и для записи.
Метод seek (}, общая форма объявления которого приведена ниже, предназначен
для установки текущего положения указателя файла.
void seek(long новая_позиция) throws IOException
Глава 1 О. Ввод-вывод данных 375
Здесь параметр новая_ позиция определяет новое положение указателя файла в
байтах относительно начала файла. Операция чтения или записи, следующая после вызова
метода seek (), будет выполняться относительно нового положения указателя.
В классе RandomAccessFile определены методы read () и wri te (). Этот класс реализует
также интерфейсы Datainput и DataOuput, т.е. в нем доступны методы чтения и
записи простых типов, например readint () и wri teDouЫe ().
Ниже приведен пример программы, демонстрирующий ввод-вывод с произвольным
доступом. В этой программе шесть значений типа douЫe сначала записываются в файл,
а затем читаются из него, причем порядок их чтения отличается от порядка записи.
// Демонстрация произвольного доступа к файлам
import java.io.*;
class RandomAccessDemo
puЬlic static void main(String args[])
{
douЫe data[] = { 19.4, 10.1, 123.54, 33.0, 87.9, 74.25 };
douЫe d; Оrкрытне файла
с произвольным доступом J // Открыть и использовать файл с произвольным доступом
try (RandomAccessFile raf = new RandomAccessFile("random.dat", "rw"))
{
// Записать значения в файл
for(int i=O; i < data.length; i++) {
raf.writeDouЫe(data[i]);
// Прочитать отдельные значения из файла
raf.seek(O); // найти первое значение типа douЫe
d = raf.readDouЫe();
4----Устоновко
укозотеn• файла
System.out.println("Пepвoe значение: " + d);
raf.seek(8); // найти второе значение типа douЫe
d = raf.readDouЫe();
System.out.println("Bтopoe значение: " + d);
raf.seek(8 * 3); // найти четвертое значение типа douЫe
d = raf.readDouЬle();
System.out.println("Чeтвepтoe значение: " + d);
System.out.println();
// Прочитать значения через одно
System.out.println("Чтeниe значений с нечетными
порядковыми номерами: " ) ;
for(int i=O; i < data.length; i+=2) {
raf.seek(8 * i); // найти i-e значение типа douЫe
d = raf.readDouЫe();
System.out.print(d + " ");
с помощью метода
seek()
376 Java 8: руководство для начинающих, 6-е издание
catch(IOException ехс) {
System.out.println("Oшибкa ввода-вывода: " + ехс);
Результат выполнения данной программы выглядит следующим образом.
Первое значение: 19.4
Первое значение: 10.1
Четвертое значение 33.О
Чтение значений с нечетными порядковыми номерами:
19.4 123.54 87.9
Отдельное замечание следует сделать относительно позиций расположения значений
в файле. Поскольку для хранения значения типа douЫe требуется 8 байтов, каждое последующее
значение начинается на 8-байтовой границе предьшущего значения. Иными
словами, первое числовое значение начинается с нулевого байта, второе - с 8-ro байта,
третье - с 16-ro байта и т.д. Поэтому для чтения четвертого значения указатель файла
должен быть установлен при вызове метода seek () на позиции 24-ro байта.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. В документации по JDK упоминается класс Console. Можно ли воспользоваться
этим классом для обмена данными с консолью?
ОТВЕТ. Да, можно. Класс Console впервые появился в версии Java 6 и служит для
ввода-вывода данных на консоль. Этот класс создан в основном для удобства
работы с консолью, поскольку большая часть его функциональных возможностей
доступна в стандартных потоках ввода-вывода System. in и System. out.
Но пренебрегать классом Console все же не следует, ведь с его помощью можно
упростить некоторые типы операций с консолью, в том числе чтение символьных
строк, вводимых с клавиатуры.
Класс Console не предоставляет конструкторы. Для получения объекта данного
типа следует вызывать статический метод System. console (), который также был
включен в версию Java 6. Ниже приведена общая форма объявления этого метода:
static Console console()
Если консоль доступна, этот метод возвращает ссылку на соответствующий
объект. В противном случае возвращается пустое значение null. Консоль доступна
не всегда: обращение к ней запрещено, если программа выполняется в
фоновом режиме.
В классе Console определен ряд методов, поддерживающих ввод-вывод, например
readLine () и printf (). В нем также содержится метод readPassword (),
предназначенный для получения пароля. При вводе пароля с клавиатуры его
символы отображаются на экране с помощью замещающих знаков, не раскрывая
пароль. Средствами класса Console можно также получить ссылки на объекты
типа Reader и Writer, связанные с консолью. Таким образом, класс Console
может оказаться очень полезным при написании некоторых видов приложений.
Глава l О. Ввод-вывод данных 377
Использование символьных потоков Java
Как следует из предыдущих разделов, байтовые потоки Java отличаются эффективностью
и удобством использования. Но во всем, что касается ввода-вывода символов,
они далеки от идеала. Для преодоления этого недостатка в Java определены классы символьных
потоков. На вершине иерархии классов, поддерживающих символьные потоки,
находятся абстрактные классы Reader и Writer. Методы класса Reader приведены
в табл. 10.7, а методы класса Writer - в табл. 10.8. В большинстве этих методов может
генерироваться исключение IOException. Методы, определенные в этих абстрактных
классах, доступны во всех их подклассах. В совокупности эти методы предоставляют минимальный
набор функций ввода-вывода, которые будут иметь все символьные потоки.
Таблица 10.7. Методы, определенные в классе Reader
Метод
abstract void close ()
void mark (int numChars)
boolean markSupported ()
int read()
int read(char buffer[])
abstract int read(char
buffer[], int offset,
int numChars)
int read (CharBuffer buffer)
boolean ready ()
void reset ()
long skip(long numChars)
Описание
Закрывает источник ввода. Дальнейшие лопытки чтения будут генерировать
исключение IOException
Помещает в текущую позицию входного потока метку, которая
будет находиться там до тех пор, пока не будет прочитано количество
байтов, определяемое параметром numChars
Возвращает значение true, если методы mark () и reset () поддерживаются
вызывающим потоком
Возвращает целочисленное представление следующего символа
в вызывающем входном потоке. По достижении конца потока
возвращается значение -1
Пытается прочитать b u f fer. length символов в массив
buffer, возвращая фактическое количество успешно прочитанных
символов. По достижении конца потока возвращается значение
-1
Пытается прочитать количество символов, определяемое параметром
numChars, в массив buffer, начиная с элемента
buffer[offset]. По достижении конца потока возвращается
значение -1
Пытается заполнить буфер, определяемый параметром
buffer, и возвращает количество успешно прочитанных символов.
По достижении конца потока возвращается значение -1.
CharBuffer - это класс, инкапсулирующий последовательность
символов, например строку
Возвращает значение true, если следующий запрос на получение
символа может быть выполнен без ожидания. В противном
случае возвращается значение false
Сбрасывает входной указатель на ранее установленную метку
Пропускает numChars символов во входном потоке, возвращая
фактическое количество пропущенных символов
378 Java 8: руководство для начинающих. 6-е издание
Таблица 10.8. Методы, определенные в классе Writer
Метод
Writer append (char ch)
Writer append (CharSequence
chars)
Writer append (CharSequence
chars, int begin, int елd)
abstract void close ()
abstract void flush ()
void write (int ch)
void write (char buffer[])
abstract void write (char
buffer(], int offset,
int numChars)
void write(String str)
void write (String str,
int offset, int numChars)
Описание
Добавляет символ ch в конец вызывающего выходного потока,
возвращая ссылку но вызывающий поток
Добавляет последовательность символов cha rs в конец вызывающего
потока, возвращая ссылку но вызывающий поток. CharSequence
- это интерфейс, определяющий операции над последовательностями
символов, выполняемые в режиме "только чтение"
Добавляет последовательность символов chars в конец текущего
потока, начиная с позиции, определяемой параметром begin, и
заканчивая позицией, определяемой параметром end. Возвращает
ссылку но вызывающий поток. CharSequence - это интерфейс,
определяющий операции над последовательностями символов, выполняемые
в режиме "только чтение"
Закрывает выходной поток. Дальнейшие попытки чтения будут генерировать
исключение IOException
Выполняет принудительную передачу содержимого выходного буфера
в место назначения {тем самым очищая выходной буфер)
Записывает один символ в вызывающий выходной поток. Обратите
внимание но то, что параметр имеет тип int, что позволяет вызывать
метод wri te () с выражениями, не приводя их к типу char
Записывает полный массив символов buffer в вызывающий выходной
поток
Записывает часть массива символов Ь и f f е r в количестве
numChars символов, начиная с элемента buffer[offset], в
вызывающий выходной поток
Записывает строку str в вызывающий выходной поток
Записывает часть строки str в количестве numChars символов,
начиная с позиции, определяемой параметром offset, в вызывающий
поток
Консольный ввод с использованием символьных потоков
В случае программ, подлежащих интернационализации, для ввода символов с клавиатуры
проще и удобнее использовать символьные потоки, а не байтовые. Но поскольку
System. in - это байтовый поток, то для него придется построить оболочку в виде класса,
производного от класса Reader. Наиболее подходящим для ввода с консоли является
класс BufferedReader, поддерживающий буферизованный входной поток. Однако
объект типа BufferedReader нельзя создать непосредственно на основе стандартного
потока ввода System. in. Сначала нужно преобразовать байтовый поток в символьный.
Для этого используется класс InputStreamReader, преобразующий байты в символы.
Чтобы получить объект типа InputStreamReader, связанный с потоком стандартного
ввода System. in, необходимо воспользоваться следующим конструктором:
InputStreamReader(InputStream inputStream)
Глава 1 О. Ввод-вывод данных 379
Поток ввода System. in - это экземпляр класса InputStream, и поэтому его можно
указать в качестве параметра inputStream данного конструктора.
Затем с помощью объекта, созданного на основе объекта типа InputStreamReader,
можно получить объект типа BufferedReader, используя следующий конструктор:
BufferedReader(Reader inputReader)
где inputReader - поток, который связывается с создаваемым экземпляром класса
BufferedReader. Объединяя обращения к указанным выше конструкторам в одну
операцию, мы получаем приведенную ниже строку кода. В ней создается объект типа
BufferedReader, связанный с клавиатурой.
BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
После выполнения этого кода переменная br будет содержать ссылку на символьный
поток, связанный с консолью через поток ввода System. in.
Чтение символов
Чтение символов из потока System. in с помощью метода read () осуществляется
в основном так, как если бы это делалось с помощью байтовых потоков. Ниже приведены
общие формы объявления трех версий метода read () , предусмотренных в классе
BufferedReader.
int read() throws IOException
int read(char data[J) throws IOException
int read(char data[], int start, int max) throws IOException
Первая версия метода read () читает одиночный символ в кодировке Unicode. По достижении
конца потока метод возвращает значение -1. Вторая версия метода read ()
читает символы из входного потока и помещает их в массив. Этот процесс продолжается
до тех пор, пока не будет достигнут конец потока, или пока массив da ta не заполнится
символами, или не возникнет ошибка, в зависимости от того, какое из этих событий
произойдет первым. В этом случае метод возвращает число прочитанных символов, а
в случае достижения конца потока, - значение -1. Третья версия метода read () помещает
прочитанные символы в массив da ta, начиная с элемента, определяемого параметром
start. Максимальное число символов, которые могут быть записаны в массив,
определяется параметром тах. В данном случае метод возвращает число прочитанных
символов или значение -1, если достигнут конец потока. При возникновении ошибки
в каждой из вышеперечисленных версий метода read () генерируется исключение
IOException. При чтении данных из потока ввода System. in конец потока устанавливается
нажатием клавиши <Enter>.
Ниже приведен пример программы, демонстрирующий применение метода read ()
для чтения символов с консоли. Символы читаются до тех пор, пока пользователь не
введет точку. Следует иметь в виду, что исключения, которые могут быть сгенерированы
при выполнении данной программы, обрабатываются за пределами метода main (). Как
уже отмечалось, такой подход к обработке ошибок является типичным при чтении данных
с консоли. По желанию можно использовать другой механизм обработки ошибок.
// Использование класса BufferedReader для чтения символов с консоли
import java.io.*;
380 Java 8: руководство для начинающих. 6-е издание
class ReadChars {
puЫic static void main(String args[J)
throws IOException
char с;
.----------Создание объекта BufferReader,
связонноrо с потоком System. in
BufferedReader br = new
BufferedReader(new
InputStreamReader(System.in));
System.out.println("Bвeдитe символы; окончание ввода -
символ точки");
// читать символы
do {
с = (char) br.read();
System.out.println(c);
while(c != '. ');
Результат выполнения данной программы выглядит следующим образом.
Введите символы; окончание ввода - символ точки
One Two.
о
n
е
т
w
о
Чтение строк
Для ввода строки с клавиатуры используют метод readLine () класса Buffered
Reader. Вот общая форма объявления этого метода:
String readLine() throws IOException
Этот метод возвращает объект типа String, содержащий прочитанные символы. При
попытке прочитать строку по достижении конца потока метод возвращает пустое значение
null.
Ниже приведен пример программы, демонстрирующий использование класса
BufferedReader и метода readLine (). В этой программе текстовые строки читаются и
отображаются до тех пор, пока не будет введено слово "stop".
// Чтение символьных строк с консоли с использованием
// класса BufferedReader
import java.io.*;
class ReadLines {
puЫic static void main(String args[])
throws IOException
Глава 1 О. Ввод-вывод данных 381
// Создать объект типа BufferedReader,
// связанный с потоком System.in
BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
String str;
System.out.println("Bвeдитe текстовые строки");
System.out.println("Пpизнaк конца ввода - строка 'stop' ");
do {
str = br.readLine(); 4--------Чтенне текстовой строкн с помощью
System.out.println(str);
while(!str.equals("stop"));
метода readLine () клоссо Bufferec!Reader
Консольный вывод с использованием символьных потоков
Несмотря на то что поток стандартного вывода System. out вполне пригоден для вывода
на консоль, в большинстве случаев такой подход рекомендуется использовать лишь
в целях отладки или при создании очень простых программ наподобие тех, которые
приведены в данной книге в виде примеров. В реальных прикладных программах на Java
вывод на консоль обычно организуется через поток PrintWriter. Класс PrintWriter
является одним из классов, представляющих символьные потоки. Как уже упоминалось,
применение потоков упрощает локализацию прикладных программ.
В классе PrintWriter определен целый ряд конструкторов. Далее будет использоваться
следующий конструктор:
PrintWriter(OutputStream outputStream, boolean flushOnNewline)
где в качестве первого параметра, outputStream, конструктору передается объект типа
OutputStream, а второй параметр, f lushOnNewline, указывает, должен ли буфер выходного
потока сбрасываться каЖдый раз, когда вызывается (среди прочих других) метод
println (). Если параметр f lushOnNewline принимает значение true, сбрасывание
буфера выполняется автоматически.
В классе PrintWriter поддерживаются методы print () и println () для всех типов,
включая Obj ect. Следовательно, методы print () и println () можно использовать точно
так же, как и совместно с потоком вывода System.out. Если значение аргумента не
относится к простому типу, то методы класса PrintWri ter вызывают метод toString ()
для объекта, указанного в качестве параметра, а затем выводят результат.
Для вывода данных на консоль через поток типа PrintWri ter следует указать
System. out в качестве выходного потока и обеспечить вывод данных из буфера после
каждого вызова метода println (). Например, при выполнении следующей строки кода
создается объект типа PrintWriter, связанный с консолью:
PrintWriter pw = new PrintWriter(System.out, true);
Ниже приведен пример программы, демонстрирующий использование класса Print
Wri ter для организации вывода на консоль.
// Использование класса PrintWriter
import java.io.*;
382 Java 8: руководство для начинающих. 6-е издание
puЫic class PrintWriterDemo { Соэдание объекта типа 􀁶--PrintWriter, связанноrо
puЫic static void main(String args[]) { ,/ cnoтoкoмSystem.out
PrintWriter pw = new PrintWriter(System.out, true);
int i = 10;
douЫe d = 123.65;
pw.println("Иcnoльзoвaниe класса PrintWriter");
pw.println(i);
pw.println(d);
pw.println(i +" +" + d +" " + (i+d));
Выполнение этой программы дает следующий результат.
Использование класса PrintWriter
10
123.65
10 + 123.65 = 133.65
Как ни удобны символьные потоки, не следует забывать, что для изучения языка Java
или отладки программ вам будет вполне достаточно использовать поток System. out.
Если вы используете поток PrintWriter, программу будет проще интернационализировать.
Для небольших программ наподобие тех, которые представлены в данной книге в
виде примеров, использование потока PrintWriter не дает никаких существенных преимуществ
по сравнению с потоком System. out, поэтому далее для вывода на консоль
будет использоваться поток System. out.
Файловый ввод-вывод с использованием
символьных потоков
Несмотря на то что файловые операции ввода-вывода чаще всего выполняются с
помощью байтовых потоков, для этой цели можно использовать также символьные
потоки. Преимущество символьных потоков заключается в том, что они оперируют
непосредственно символами в кодировке Unicode. Так, если вам надо сохранить текст
в кодировке Unicode, то для этой цели лучше всего воспользоваться символьными потоками.
Как правило, для файлового ввода-вывода символов используются классы
FileReader и FileWriter.
Класс FileWri ter
Класс FileWriter создает объект типа Wri ter, который можно использовать для записи
данных в файл. Ниже приведены общие формы объявления двух наиболее часто
используемых конструкторов данного класса.
FileWriter(String имя_файла) throws IOException
FileWriter(String имя_файла, boolean append) throws IOException
Здесь имя_файла обозначает полный путь к файлу. Если параметр append принимает
значение true, данные записываются в конец файла, в противном случае запись
Глава 1 О. Ввод-вывод данных 383
осуществляется поверх существующих данных. При возникновении ошибки в каждом
из указанных конструкторов генерируется исключение IOException. Класс FileWriter
является производным от классов OutputStreamWriter и Writer. Следовательно, в нем
доступны методы, объявленные в его суперклассах.
Ниже приведен пример небольшой программы, демонстрирующий ввод текстовых
строк с клавиатуры и последующую их запись в файл test. txt. Набираемый текст
читается до тех пор, пока пользователь не введет слово "stop". Для вывода текстовых
строк в файл используется класс FileWriter.
// Пример простой утилиты для ввода данных с клавиатуры и
// записи их на диск, демонстрирующий использование класса
// FileWriter
import java.io.*;
class KtoD {
puЫic static void main(String args[])
{
String str;
BufferedReader br =
new BufferedReader(
new InputStreamReader(System.in));
System.out.println("Пpизнaк конца ввода - строка 'stop' ");
try (FileWriter fw = new FileWriter("test.txt"))
{
-----Создоние объекта
FileWriter
do {
System.out.print(": ");
str = br.readLine();
if(str.compareTo("stop") == О) break;
str = str + "\r\n"; // добавить символы перевода строки
fw. wri te ( str); Записнекстовых строк в файл
while(str.compareTo("stop") != О);
catch(IOException ехс) {
System.out.println("Oшибкa ввода-вывода: " + ехс);
Использование класса FileReader
Класс FileReader создает объект типа Reader, который можно использовать для
чтения содержимого файла. Чаще всего используется следующая форма конструктора
этого класса:
FileReader(String имя_файла) throws FileNotFoundException
где имя_файла обозначает полный путь к файлу. Если указанный файл не существует,
генерируется исключение FileNotFoundException. Класс FileReader является производным
от классов InputStreamReader и Reader. Следовательно, в нем доступны методы,
объявленные в его суперклассах.
384 Java 8: руководство для начинающих. 6-е издание
В приведенном ниже примере создается простая утилита, отображающая на экране
содержимое текстового файла test. txt. Она является своего рода дополнением к утилите,
рассмотренной в предьщущем разделе.
// Пример простой утилиты для чтения данных с диска и вывода их
// на экран, демонстрирующий использование класса FileReader
import java.io.*;
class DtoS {
puЫic static void main(String args[]) {
String s;
// Создать и использовать объект FileReader, помещенный
// в оболочку на основе класса BufferedReader
try (BufferedReader br = Соэдание объекта FileReader
new BufferedReader(new FileReader("test.txt")))
while((s = br.readLine()) != null) {
System.out.println(s);
catch(IOException ехс) {
4---- Чтение строк иэ фойnо и отображение
их но экране
System. out. println ( "Ошибка ввода-вывода: " + ехс);
Обратите внимание на то, что для потока FileReader создается оболочка на основе
класса BufferedReader. Благодаря этому появляется возможность обращаться к методу
readLine (}. Кроме того, закрытие потока типа BufferedReader, на который в данном
примере ссылается переменная br, автоматически приводит к закрытию файла.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Я слышал об отдельной системе NIO с классами для поддержки ввода-
вывода. Что она собой представляет?
ОТВЕТ. Система NIO (сокращение от New 1/0) бьmа реализована в версии JDK 1.4.
В ней поддерживается канальный подход к организации операций ввода-вывода.
Классы новой системы ввода-вывода относятся к пакету j ava. nio и его
подчиненным пакетам, включая java.nio.channels и java.nio.charset.
Система NIO опирается на два основных понятия: буферы и каналы. Буфер содержит
данные, а канал представляет собой соединение, устанавливаемое с устройством
ввода-вывода, например, с файлом на диске или сетевым сокетом. Как
правило, д11я применения новой системы ввода-вывода нужно получить канал доступа
к устройству и буфер для хранения данных. После этого можно выполнять
необходимые операции с буфером, в частности, вводить или выводить данные.
Кроме буфера и канала, в NIO используются также понятия набора символов
и селектора. Набор символов определяет способ преобразования байтов в сим-
Глава 1 О. Ввод-вывод данных 385
волы. Для представления последовательности символов в виде набора байтов
используется шифратор. Обратное преобразование осуществляет дешифратор.
А селектор поддерживает неблокирующий мультиплексированный ввод-вывод
с ключом шифрования. Иными словами, селекторы позволяют выполнять обмен
данными по нескольким каналам. Селекторы находят наибольшее применение
в каналах, поддерживаемых сетевыми сокетами.
В версии JDK 7 новая система ввода-вывода была значительно усовершенствована,
и поэтому нередко ее называют N/0.2. К числу ее усовершенствований относятся
три новых пакета (java .nio. file, java. nio. file. attribute и java.
nio. file. spi), ряд новых классов, интерфейсов и методов, а также непосредственная
поддержка потокового ввода-вывода. Все эти дополнения в значительной
степени расширили область применения NIO, и особенно это касается обработки
файлов.
Однако новая система ввода-вывода не призвана заменить классы ввода-вывода,
существующие в пакете java. io. Классы NIO лишь дополняют стандартную
систему ввода-вывода, предлагая альтернативный подход, вполне уместный в
ряде случаев.
Использование классов-оболочек
для преобразования числовых строк
Прежде чем завершить обсуждение средств ввода-вывода, необходимо обсудить еще
одну технику, которая оказывается весьма полезной при чтении числовых строк. Как
вам уже известно, метод println () предоставляет удобные средства для вывода на консоль
различных типов данных, в том числе целых чисел и чисел с плавающей точкой.
Он автоматически преобразует числовые значения в удобную для чтения форму. Но в
Java отсутствует метод, который читал бы числовые строки и преобразовывал их во внутреннюю
двоичную форму. Например, не существует варианта метода read () , который
читал бы числовую строку "100" и автоматически преобразовывал ее в целое число,
пригодное для хранения в переменной типа int. Но для этой цели в Java имеются другие
средства. И проще всего подобное преобразование осуществляется с помощью так
называемых оболочек типов (объектных оболочек) Java.
Объектные оболочки в Java представляют собой классы, которые инкапсулируют
простые типы. Оболочки типов необходимы, поскольку простые типы не являются объектами,
что ограничивает их применение. Так, простой тип нельзя передать методу по
ссылке. Для того чтобы исключить ненужные ограничения, в Java были предусмотрены
классы, соответствующие каждому из простых типов.
Объектными оболочками являются классы DouЬle, Float, Long, Integer, Short,
Byte, Character и Boolean, которые предоставляют обширный ряд методов, позволяющих
полностью интегрировать простые типы в иерархию объектов Java. Кроме того, в
классах-оболочках числовых типов содержатся методы, предназначенные для преобразования
числовых строк в соответствующие двоичные эквиваленты. Эти методы приведены
ниже. Каждый из них возвращает двоичное значение, соответствующее числовой
строке.
386 Java 8: руководство для начинающих. 6-е издание
Оболочка типа Метод преобразования
DouЫe
Float
Long
Integer
Short
Byte
static douЫe parseDouЫe (String str) throws NшnЬerFormatException
static float parseFloat (String str) throws NшnЬerFormatException
static long parseLong (String str) throws NшnЬerFormatException
static int parse!nt (String str) throws NшnЬerFormatException
static short parseShort (String str) throws NшnЬerFormatException
static byte parseByte(String str) throws NшnЬerFormatException
Оболочки целочисленных типов также предоставляют дополнительный метод синтаксического
анализа, позволяющий задавать основание системы счисления.
Методы синтаксического анализа позволяют без труда преобразовать во внутренний
формат числовые значения, введенные в виде символьных строк с клавиатуры или из
текстового файла. Ниже приведен пример программы, демонстрирующий применение
для этих целей методов parseint () и parseDouЫe (). В этой программе находится
среднее арифметическое ряда чисел, введенных пользователем с клавиатуры. Сначала
пользователю предлагается указать количество подлежащих обработке числовых значений,
а затем программа вводит числа с клавиатуры, используя метод readLine ( ) , а с помощью
метода parseint () преобразует символьную строку в целочисленное значение.
Далее осуществляется ввод числовых значений и последующее их преобразование в тип
douЫe с помощью метода parseDouЫe ().
/* Данная программа находит среднее арифметическое для
ряда чисел, введенных пользователем с клавиатуры. */
import java.io.*;
cla ss AvgNums {
puЫic static void ma in(String args[J)
throws IOException
// Создать объект типа BufferedReader,
// использующий поток ввода System.in
BufferedReader br = new
BufferedReader(new InputStrea mReader(Syste m.in));
String str;
int n;
douЫe sum = О.О;
douЫe avg, t;
System.out.print("Cкoлькo чисел вы введете: ");
str br.readLine();
try
n = Integer.parseint(str); -----------Преоброэованне строкн
catch(NumЬerFormatException ехс)
Syste m.out.println("Heвepный формат");
n = О;
в чнсnовое эначенне тнnа int
Глава 1 О. Ввод-вывод данных 387
System.out.println("Bвoд " + n + " значений");
for (int i=O; i < n ; i++) {
System.out.print(": ");
str br.readLine();
try {
t = DouЫe.parseDouЫe(str); 4--------Преоброэовонне сrрокн в чнсnовое
catch(NumЬerFormatException ехс)
System.out.println("Heвepный формат");
эноченне типа douЬle
t = О.О;
sum += t;
avg = sum / n;
System.out.println("Cpeднee значение: " + avg);
Выполнение этой программы может дать, например, следующий результат.
Сколько чисел вы введете: 5
Ввод 5 значений
1.1
2.2
3.3
4. 4
5.5
Среднее значение: 3.3
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Могут ли объектные оболочки простых типов выполнять другие функции,
помимо описанных в этом разделе?
ОТВЕТ. Классы оболочек простых типов предоставляют ряд методов, помогающих
интегрировать эти типы данных в иерархию объектов. Например, различные
механизмы хранения данных, предусмотренные в библиотеке Java,
включая отображения, списки и множества, взаимодействуют только с объектами.
Поэтому для сохранения целочисленного значения в списке его следует
сначала преобразовать в объект. Оболочки типов предоставляют также метод
compareTo () для сравнения текущего значения с заданным, метод equals ()
для проверки равенства двух объектов, а также методы, возвращающие значение
объекта в разных формах записи. К оболочкам типов мы еще вернемся в
главе 12, когда речь пойдет об автоупаковке.
388 Java 8: руководство для начинающих. 6-е издание
Упражнение 10.2 Соэдание справочной системы,
находящейся на диске
:__·_F__·_􀀌_ .. _i_·_􀀕·_н_·_􀀖_-_._i_·.􀀗--..· .. ·
.
􀁿.:_·.􀂀
.
·
.
·
.
􀂁--
.
􀂂
.
·
.
·
.
·
.
·
.
·.i. В упражнении 4.1 был создан класс Help, позволяющий отобра -
жать сведения об операторах Java. Справочная информация хра-
нилась в самом классе, а пользователь выбирал требуемые сведения из меню. И хотя
такая справочная система выполняет свои функции, подход к ее разработке был выбран
далеко не самый лучший. Так, если потребуется добавить или изменить какие-либо сведения,
вам придется внести изменения в исходный код программы, которая реализует
справочную систему. Кроме того, выбирать пункт меню по ero номеру не очень удобно,
а если количество пунктов велико, то такой способ оказывается вообще непригодным.
В этом проекте предстоит устранить недостатки, имеющиеся в справочной системе, разместив
справочную информацию на диске.
В новом варианте справочная информация должна храниться в файле. Это будет
обычный текстовый файл, который можно изменять, не затрагивая исходный код программы.
Для того чтобы получить справку по конкретному вопросу, следует ввести название
темы. Система будет искать соответствующий раздел в файле. Если поиск завершится
успешно, справочная информация будет выведена на экран. Поэтапное описание
процесса создания программы приведено ниже.
1. Создайте файл, в котором будет храниться справочная информация и который
будет использоваться в справочной системе. Это должен быть обычный текстовый
файл, организованный, как показано ниже.
#название темы 1
Информация по теме
#название темы 2
Информация по теме
#название темы N
Информация по теме
Название каждой темы располагается в отдельной строке и предваряется символом
#. Наличие специального символа в строке (в данном случае - #) позволяет
программе быстро найти начало раздела. Под названием темы может располагаться
любая справочная информация. После окончания одного раздела и перед началом
другого должна быть введена пустая строка. Кроме того, в конце строк не
должно быть лишних пробелов.
Ниже приведен пример простого файла со справочной информацией, который
можно использовать вместе с новой версией справочной системы. В нем хранятся
сведения об операторах Java.
#if
if(условие) оператор;
else оператор;
#switch
switсh(выражение)
case константа:
#for
последовательность операторов
break;
// . . .
Глава l О. Ввод-вывод данных 389
fоr(инициализация; условие; итерация) оператор;
!lwhile
while(ycлoвиe) оператор;
lldo
do {
оператор;
} while (условие);
llbreak
break; или break метка;
!lcontinue
continue; или continue метка;
Присвойте этому файлу имя helpfile. txt.
2. Создайте файл FileHelp. java.
3. Начните создание новой версии класса Help со следующих строк кода.
class Help {
String helpfile; // имя файла, содержащего
// справочную информацию
Help(String fnarne) {
helpfile = fnarne;
Имя файла со справочной информацией передается конструктору класса Help и
запоминается в переменной экземпляра helpfile. А поскольку каждый экземпляр
класса Help содержит отдельную копию переменной helpfile, то каждый
из них может взаимодействовать с отдельным файлом. Это дает возможность создавать
отельные наборы справочных файлов на разные темы.
4. Добавьте в класс Help метод helpon (), код которого приведен ниже. Этот метод
извлекает справочную информацию по заданной теме.
// Отобразить справочную информацию по указанной теме
boolean helpon(String what) {
int ch;
String topic, info;
// Открыть справочный файл
try (BufferedReader helpRdr
new BufferedReader(new FileReader(helpfile)))
do {
// Читать символы до тех пор, пока не встретится символ II
ch = helpRdr.read();
390 Java 8: руководство для начинающих. 6-е издание
// Проверить, совпадают ли темы
if{ch == '#') {
topic = helpRdr.readLine{);
if{what.compareTo(topic) == О) { // найти тему
do {
info = helpRdr.readLine();
if(info 1 = null) System.out.println{info);
while{(info != null) &&
{info.compareTo("") != О));
return true;
while{ch != -1);
catch(IOException ехс)
System.out.println("Oшибкa при попытке доступа к файлу справки");
return false;
return false; // тема не найдена
Прежде всего обратите внимание на то, что в методе helpon () обрабатываются
все исключения, связанные с вводом-выводом, поэтому в заголовке метода не
указано ключевое слово throws. Благодаря такому подходу упрощается разработка
методов, в которых используется метод helpon (). В вызывающем методе достаточно
обратиться к методу helpon (), не заключая его вызов в блок try / catch.
Для открытия файла со справочной информацией служит класс FileReader, оболочкой
которого является класс BufferedReader. В справочном файле содержится
текст, и поэтому справочную систему удобнее локализовать через символьные
потоки ввода-вывода.
Метод helpon () действует следующим образом. Символьная строка, содержащая
название темы, передается методу в качестве параметра. Сначала метод открывает
файл со справочной информацией. Затем в файле осуществляется поиск, т.е. проверяется
совпадение содержимого переменной what и названия темы. Напомним,
что в файле заголовок темы предваряется символом #, поэтому метод сначала
ищет данный символ. Если символ найден, производится сравнение следующего
за ним названия темы с содержимым переменной what. Если сравниваемые строки
совпадают, то отображается справочная информация по данной теме. И если
заголовок темы найден, то метод helpon () возвращает логическое значение true,
в противном случае - логическое значение false.
5. В классе Help содержится также метод getSelection (), который предлагает указать
тему и возвращает строку, введенную пользователем.
// Получить тему справки.
String getSelection () {
String topic = "";
BufferedReader br = new BufferedReader(
new InputStreamReader(System.in));
Глава 1 О. Ввод-вывод данных 391
System.out.print("Yкaжитe тему: ");
try {
topic = br.readLine();
catch(IOException ехс) {
System.out.println("Oшибкa nри чтении с консоли");
return topic;
В теле этоrо метода сначала создается объект типа BufferedReader, который
связывается с потоком вывода System. in. Затем в нем запрашивается название
темы, которое принимается и далее возвращается вызывающей части проrраммы.
6. Ниже приведен весь исходный код проrраммы, реализующей справочную систему,
находящуюся на диске.
/*
*/
Упражнение 10.2
Справочная система, использующая дисковый файл
для хранения информации
irnport java.io.*;
/* В классе Help открывается файл со справочной информацией,
производится поиск указанной темы, а затем отображается
справочная информация. Обратите внимание на то, что данный
класс обрабатывает все исключения, освобождая от этого
вызывающий код. */
class Help {
String helpfile; // имя справочного файла
Help(String fnarne) {
helpfile = fnarne;
// Отобразить справочную информацию по указанной теме
boolean helpon(String what) {
int ch;
String topic, info;
// Открыть справочный файл
try (BufferedReader helpRdr
new BufferedReader(new FileReader(helpfile)))
do {
// Читать символы до тех пор, пока не встретится символ#
ch = helpRdr.read();
// Проверить, совпадают ли темы
i f( c h == #' ' ) {
topic = helpRdr.readLine();
if(what.cornpareTo(topic) О) { // найти тему
do {
392 Java 8: руководство для начинающих. 6-е издание
info = helpRdr.readLine();
if(info != null) System.out.println(info);
while((info != null) &&
(info.compareTo("") != 0));
return true;
while(ch != -1);
catch(IOException ехс)
System.out.println("Oшибкa при попытке доступа
к файлу справки");
return false;
return false; // тема не найдена
// Получить тему справки
String getSelection () {
String topic = "";
BufferedReader br = new BufferedReader(
new InputStreamReader(System.in));
System.out.print("Yкaжитe тему: ");
try {
topic = br.readLine();
catch(IOException ехс) {
System.out.println{"Oшибкa при чтении с консоли");
return topic;
// Демонстрация работы справочной системы на основе файла
class FileHelp {
puЫic static void main(String args[J) {
Help hlpobj = new Help("helpfile.txt");
String topic;
System.out.println("Bocпoльэyйтecь справочной системой.\n" +
"Для выхода из системы введите 'stop'.");
do {
topic = hlpobj.getSelection();
if(!hlpobj.helpon(topic))
System.out.println("Teмa не найдена.\n");
while(topic.compareTo("stop") != О);
СПРОСИМ У ЭКСПЕРТА
Глава l О. Ввод-вывод данных 393
ВОПРОС. Имеется ли, помимо методов синтаксического анализа, определяемых
в оболочках простых типов, другой простой способ преобразования числовой
строки, вводимой с клавиатуры, в эквивалентную ей двоичную форму?
ОТВЕТ. Да, имеется. Другой способ преобразования числовой строки в ее внутреннее
представление в двоичной форме состоит в использовании одного из методов,
определенных в классе Scanner из пакета java. util. Этот класс, реализованный
в версии JDK 5, читает данные, вводимые в удобном для чтения виде,
преобразуя их в двоичную форму. Средствами класса Scanner можно организовать
чтение данных, вводимых из самых разных источников, в том числе с консоли
и из файлов. Следовательно, его можно использовать для чтения числовой
строки, введенной с клавиатуры, присвоив полученное значение переменной.
И хотя в классе Scanner содержится слишком много средств, чтобы описать их
подробно, ниже демонстрируются основные примеры его применения.
Для организации ввода с клавиатуры средствами класса Scanner необходимо
сначала создать объект этого класса, связанный с потоком ввода с консоли. Для
этой цели служит следующий конструктор:
Scanner(InputStream from)
Этот конструктор создает объект типа Scanner, который использует поток ввода,
определяемый параметром from, в качестве источника ввода данных. С помощью
этого конструктора можно создать объект типа Scanner, связанный с
потоком ввода с консоли, как показано ниже.
Scanner conin = new Scanner(System.in);
Это оказывается возможным благодаря тому, что поток System. in является
объектом типа InputStream. После выполнения этой строки кода переменную
conin ссьшки на объект типа Scanner можно использовать для чтения данных,
вводимых с клавиатуры.
Как только будет создан объект типа Scanner, им нетрудно воспользоваться для
чтения числовой строки, вводимой с клавиатуры. Ниже приведен общий порядок
выполняемых для этого действий.
Определить, имеются ли вводимые данные конкретного типа, вызвав один из
методов hasNextX класса Scanner, где х - нужный тип вводимых данных.
Если вводимые данные имеются, прочитать их. вызвав один из методов nextX
класса Scanner.
Как следует из приведенного выше порядка действий, в классе Scanner определены
две группы методов, предназначенных для чтения вводимых данных.
К первой из них относятся методы hasNextX, в том числе hasNextint () и
hasNextDouЫe (). Каждый из методов hasNextX возвращает логическое значение
true, если очередной элемент данных, имеющийся в потоке ввода, относится
к нужному типу данных, а иначе - логическое значение false. Так, логическое
значение true возвращается при вызове метода hasNextint () лишь
в том случае, если очередной элемент данных в потоке ввода является цело-
394 Java 8: руководство для начинающих, 6-е издание
численным значением, представленным в удобном для чтения виде. Если данные
нужного типа присутствуют в потоке ввода, их можно прочитать, вызвав
один из методов класса Scanner, относящихся к группе next, например метод
nextlnt () или nextDouЫe (). Эти методы преобразуют данные соответствующего
типа из удобной для чтения формы во внутреннее их представление в двоичном
виде, возвращая полученный результат. Так, для чтения целочисленного
значения, введенного с клавиатуры, следует вызвать метод nextlnt ().
В приведенном ниже фрагменте кода показано, каким образом организуется
чтение целочисленного значения с клавиатуры.
Scanner conin = new Scanner(System.in);
int i;
if (conin.hasNextint()) i = conin.nextint();
Если ввести с клавиатуры целое число 123, то в результате выполнения приведенного
выше фрагмента кода переменная i будет содержать целочисленное
значение 123.
Формально методы из группы next можно вызывать без предварительного вызова
методов из группы hasNext, но делать этого все же не рекомендуется. Ведь
если методу из группы next не удастся обнаружить данные искомого типа, то
он сгенерирует исключение InputMismatchException. Поэтому лучше сначала
убедиться, что данные нужного типа присутствуют в потоке ввода, вызвав подходящий
метод hasNext, и только после этого вызывать соответствующий метод
next.
ili
·' Bonpoc1,1 и упражнения ДIIЯ самопроверки
1. Для чего в Java определены как байтовые, так и символьные потоки?
2. Как известно, консольные операции ввода-вывода осуществляются в текстовом
виде. Почему же в Java для этой цели используются байтовые потоки?
З. Как открыть файл для чтения байтов?
4. Как открыть файл для чтения символов?
5. Как открыть файл для выполнения операций ввода-вывода с произвольным доступом?
6. Как преобразовать числовую строку "123. 23" в ее двоичный эквивалент?
7. Напишите программу для копирования текстовых файлов. Видоизмените ее таким
образом, чтобы все пробелы заменялись дефисами. Используйте при написании
программы классы, представляющие байтовые потоки, а также традиционный
способ закрытия файла явным вызовом метода close () .
8. Перепишите программу, созданную в предыдущем пункте, таким образом, чтобы
в ней использовались классы, представляющие символьные потоки. На этот раз
воспользуйтесь оператором try с ресурсами для автоматического закрытия файла.
Глава l О. Ввод-вывод данных 395
9. К какому типу относится поток System. in?
10. Какое значение возвращает метод read () класса InputStrea m по достижении
конца потока?
11. Поток какого типа используется для чтения двоичных данных?
12. Классы Reader и Wri ter находятся на вершине иерархии классов ____ _
13. Оператор try с ресурсами служит для----- -------
14. Справедливо ли следующее утверждение: "Если для закрытия файла используется
традиционный способ, то это лучше всего делать в блоке finally"?

Глава 11
Многопоточное
программирование
398 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
,; Общее предстамение о мноrопоточной обработке
rr. Класс Thread и интерфейс RunnaЬle
;щ. Создание потока
􀂱 Создание нескольких потоков
$ Определение момента завершения потока
􀂲 Приоритеты потоков
..,, Синхронизация потоков
􀂳 Использование синхронизированных методов
􀂴· Использование синхронизированных блоков
􀂵 Взаимодействие потоков
􀂶 Приостановка, возобномение и остановка потоков
о дной из наиболее впечатляющих новых возможностей Java можно по праву считать
встроенную поддержку многопоточного программирования. Мноrопоточная
программа состоит из двух или более частей, выполняемых параллельно. КаЖдая часть
такой программы называется потоком и определяет отдельный путь выполнения команд.
Таким образом , мноrопоточная обработка является особой формой многозадачности.
Общее представление
о многопоточной обработке
Различают две разновидности многозадачности: на основе процессов и на основе потоков.
В связи с этим важно понимать различия меЖду ними. По сути, процесс представляет
собой исполняемую программу. Поэтому многозадачность на основе процессов - это
средство, обеспечивающее возможность выполнения на компьютере одновременно нескольких
программ. Например, именно этот тип многозадачности позволяет вам запускать
компилятор Java и в то же время работать с текстовым процессором, электронной
таблицей или просматривать содержимое в Интернете. При организации многозадачности
на основе процессов программа является наименьшей единицей кода, выполнение
которой может координировать планировщик задач.
При организации многозадачности на основе потоков наименьшей единицей диспетчеризуемоrо
кода является поток. Это означает, что в рамках одной программы могут
выполняться одновременно несколько задач. Например, текстовый процессор может
форматировать текст одновременно с его выводом на печать, при условии, что оба эти
действия выполняются в двух отдельных потоках. Несмотря на то что программы на Java
выполняются в среде, поддерживающей многозадачность на основе процессов, в самих
программах управлять процессами нельзя. Доступной остается только многозадачность
на основе потоков.
Глава 11 . Многопоточное программирование 399
Главное преимущество мноrопоточной обработки заключается в том, что она позволяет
писать программы, которые работают очень эффективно благодаря использованию
холостых периодов процессора, неизбежно возникающих в ходе выполнения большинства
программ. Как известно, большинство устройств ввода-вывода, будь то устройства,
подключенные к сетевым портам, дисковые накопители или клавиатура, работают много
медленнее, чем центральный процессор (ЦП). Поэтому большую часть своего времени
программе приходится ожидать отправки данных на устройство ввода-вывода или
получения информации от него. Благодаря мноrопоточной обработке программа может
решать какую-нибудь другую задачу во время вынужденного простоя процессора. Например,
в то время как одна часть программы отправляет файл через соединение с Интернетом,
другая ее часть может выполнять чтение текстовой информации, вводимой
с клавиатуры, а третья - осуществлять буферизацию очередного блока отправляемых
данных.
Как вам, вероятно, известно, за последние несколько лет широкое распространение
получили многопроцессорные или многоядерные вычислительные системы, хотя
по-прежнему повсеместно используются и однопроцессорные системы. В этой связи
следует иметь в виду, что языковые средства организации мноrопоточной обработки
в Java пригодны для обеих разновидностей вычислительных систем. В одноядерной
системе параллельно выполняющиеся потоки разделяют ресурсы одного ЦП, получая
по очереди квант его времени. Поэтому в одноядерной системе два или более
потока на самом деле не выполняются одновременно, а лишь используют время простоя
ЦП. С другой стороны, в многопроцессорных или многоядерных системах несколько
потоков могут выполняться действительно одновременно. Это, как правило,
позволяет повысить производительность программ и скорость выполнения отдельных
операций.
Поток может находиться в одном из нескольких состояний. В целом поток может
быть выполняющимся; готовым к выполнению, как только он получит время и ресурсы
ЦП; приостановленным, т.е. временно не выполняющимся; возобновленным в дальнейшем;
заблокированным в ожидании ресурсов для своего выполнения; а также завершенным,
когда его выполнение закончено и не может быть возобновлено.
В связи с организацией многозадачности на основе потоков возникает потребность
в особого рода режиме, который называется синхронизацией и позволяет координировать
выполнение потоков строго определенным образом. Для такой синхронизации в
Java предусмотрена отдельная подсистема, основные средства которой рассматриваются
в этой главе.
Если вы пишете программы для таких операционных систем, как Windows, то принципы
мноrопоточноrо программирования вам должны быть уже знакомы. Но то обстоятельство,
что в Java возможности управления потоками включены в сам язык, упрощает
организацию мноrопоточной обработки, поскольку избавляет от необходимости реализовывать
ее во всех деталях.
Класс Тhread и интерфейс RunnaЫe
В основу системы мноrопоточной обработки в Java положены класс Thread и интерфейс
RunnaЫe, входящие в пакет j ava. lang. Класс Thread инкапсулирует поток исполнения.
Для того чтобы образовать новый поток, нужно создать класс, являющийся
подклассом Thread или реализующий интерфейс RunnaЫe.
400 Java 8: руководство для начинающих. 6-е издание
В классе Thread определен ряд методов, позволяющих управлять потоками. Некоторые
из этих наиболее употребительных методов описаны ниже. По мере их представления
в последующих примерах программ вы ознакомитесь с ними поближе.
Метод
final String getNarne ()
final int getPriority ()
final boolean isAlive()
final void join ()
void run ()
static void sleep (long
миллисекунд)
void start ()
Описание
Получает имя потока
Получает приоритет потока
Определяет, выполняется ли поток
Ожидает завершения потока
Определяет точку входа в поток
Приостанавливает исполнение потока на указанное число миллисекунд
Запускает поток, вызывая его метод run ()
В каждом процессе имеется как минимум один поток исполнения, который называется
основным потоком. Он получает управление уже при запуске программы. Следовательно,
во всех рассмотренных до сих пор примерах использовался основной поток. От
основного потока могут быть порождены другие, подчиненные потоки.
Создание потока
Для того чтобы создать поток, нужно построить объект типа Thread. Класс Thread
инкапсулирует объект, который может стать исполняемым. Как уже отмечалось, в Java
пригодные для исполнения объекты можно создавать двумя способами:
􀂚 реализуя интерфейс RunnaЫe;
.r,. создавая подкласс класса Thread.
В большинстве примеров, представленных в этой главе, будет применяться первый
способ. Тем не менее в упражнении 11.1 будет продемонстрировано, каким образом
можно реализовать поток путем расширения класса Thread. В любом случае создание
экземпляра потока, организация доступа к нему и управление потоком осуществляются
средствами класса Thread. Единственное отличие обоих способов состоит в том, как
создается класс, активизирующий поток.
Интерфейс RunnaЫe дает абстрактное описание единицы исполняемого кода. Для
формирования потока подходит любой объект, реализующий этот интерфейс. В интерфейсе
RunnaЫe объявлен только один метод - run ():
puЫic void run()
В теле метода run () определяется код, соответствующий новому потоку. Из этого
метода можно вызывать другие методы, использовать в нем различные классы и объявлять
переменные точно так же, как это делается в основном потоке. Единственное
отличие состоит в том, что метод run ( ) создает точку входа в поток, выполняемый в
программе параллельно с основным. Этот поток выполняется до тех пор, пока не произойдет
возврат из метода run ( ) .
Глава 11. Многопоточное программирование 401
После создания класса, реализующего интерфейс RunnaЫe, следует создать экземпляр
объекта типа Thread на основе объекта данного класса. В классе Thread определен
ряд конструкторов. В дальнейшем будет использоваться следующий конструктор:
Thread(RunnaЫe threadOb)
В качестве параметра threadOb этому конструктору передается экземпляр класса,
реализующего интерфейс RunnaЫe. Это позволяет определить, откуда начнется выполнение
потока.
Созданный поток не запустится до тех пор, пока не будет вызван метод start (),
объявленный в классе Thread. В сущности, единственным назначением метода start ()
является вызов метода run (). Метод start () объявляется следующим образом:
void start ()
Ниже приведен пример программы, в которой создается и запускается на исполнение
новый поток.
// Создание потока путем реализации интерфейса RunnaЫe
class MyThread irnplernents RunnaЫe {
String thrdNarne;
-----Объе1СJы типа MyТhread
MyThread(String narne)
thrdNarne = narne;
моrут ВЫПОIIНАТЬСА в отдеnьных
потоках, ток кок кnосс MyThread
реоnнзует интерфейс RunnaЫe
)
// Точка входа в поток.
puЫic void run () { Отсюда начинают выпоnняться потоки
Systern.out.println(thrdNarne + " - запуск");
try {
for(int count=O; count < 10; count++) {
Thread.sleep(400);
Systern.out.println("B " + thrdNarne +
", счетчик: " + count);
catch(InterruptedException ехс)
Systern.out.println(thrdNarne + " - прерван");
Systern.out.println(thrdNarne + " - завершение");
class UseThreads {
puЫic static void rnain(String args[])
Systern.out.println("Зaпycк основного потока");
// Сначала создать объект типа MyThread.
MyThread rnt = new MyThread("Child #1"); ------Создонне нспоnняемогообьекто
// Затем сформировать поток на основе этого объекта.
Thread newThrd = new Thread (rnt) ; Формирование по тока дnя этого объекта
402 Java 8: руководство для начинающих. 6-е издание
// Наконец, начать выполнение потока
newThrd. start () ; Запуск потока но вwпопнение
for(int i=O; i<SO; i++) {
System.out.print(".");
try {
Thread.sleep(lOO);
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
System.out.println("Зaвepmeниe основного потока");
Рассмотрим эту программу более подробно. Как видите, класс MyThread реализует
интерфейс RunnaЫe. Это означает, что объект типа MyThread подходит для использования
в качестве потока, а следовательно, его можно передать конструктору класса Thread.
В теле метода run () присутствует цикл, счетчик которого принимает значения от О
до 9. Обратите внимание на вызов метода sleep () . Этот метод приостанавливает поток,
из которого он был вызван, на указанное число миллисекунд. Ниже приведена общая
форма объявления данного метода:
static void sleep(long миллисекунд) throws InterruptedException
Единственный параметр метода sleep () задает время задержки, определяемое числом
миллисекунд. Как следует из объявления этого метода, в нем может быть сгенерировано
исключение InterruptedException. Следовательно, его нужно вызывать в
блоке try. Имеется и другой вариант метода sleep (), позволяющий точнее указывать
время задержки в миллисекундах и дополнительно в наносекундах. Когда метод sleep ()
вызывается в методе run ( ) , исполнение потока приостанавливается на 400 миллисекунд
на каждом шаге цикла. Благодаря этому поток исполняется достаточно медленно, чтобы
за ним можно было проследить.
В методе main () создается новый объект типа Thread. Для этой цели служит приведенная
ниже последовательность операторов.
// Сначала создать объект типа MyThread
MyThread mt = new MyThread("Child #1");
// Затем сформировать поток на основе этого объекта
Thread newThrd = new Thread(mt);
// И наконец, начать выполнение потока
newThrd.start();
Как следует из комментариев к программе, сначала создается объект типа MyThread,
который затем используется для создания объекта типа Thread. Его можно передать
конструктору класса Thread в качестве параметра, поскольку класс MyThread реализует
интерфейс RunnaЫe. Наконец, для запуска нового потока вызывается метод start (),
что приводит к вызову метода run () из порожденного потока. После вызова метода
start () управление возвращается в метод main (), где начинается выполнение цикла
Глава 11 . Многопоточное программирование 403
for. Этот цикл повторяется 50 раз, приостанавливая на 100 миллисекунд выполнение
потока на каждом своем шаге. Оба потока продолжают выполняться, разделяя ресурсы
ЦП в однопроцессорной системе до тех пор, пока циклы в них не завершатся. Ниже
приведен результат выполнения данной программы. Вследствие отличий в вычислительных
средах у вас может получиться несколько иной результат.
Запуск основного потока
.Child #1 - запуск
... В Child #1, счетчик: О
.... В Child #1, счетчик: 1
.... В Child #1, счетчик: 2
... В Child #1, счетчик: 3
.... В Child #1, счетчик: 4
.... В Child #1, счетчик: 5
.... В Child #1, счетчик: 6
... В Child #1, счетчик: 7
.... В Child #1, счетчик: 8
.... В Child #1, счетчик: 9
Child #1 - завершение
............ Завершение основного потока
В рассматриваемом здесь первом примере организации мноrопоточной обработки
заслуживает интереса следующее обстоятельство: для демонстрации того факта, что
основной и порожденный потоки выполняются одновременно, необходимо задержать
завершение метода main () до тех пор, пока не закончится выполнение порожденного
потока mt. В данном примере это достигается за счет использования отличий во временных
характеристиках обоих потоков. Вызовы метода sleep () из цикла for в методе
main () приводят к суммарной задержке в 5 секунд (50 шагов циклах 100 миллисекунд),
тогда как суммарная задержка с помощью того же самого метода в аналогичном цикле в
методе run () составляет лишь 4 секунды (10 шагов циклах 400 митшсекунд). Поэтому
метод run () завершится приблизительно на секунду раньше, чем метод main (). В итоге
основной и порожденный потоки будут выполняться параллельно до тех пор, пока не
завершится дочерний поток mt. После этого, приблизительно через одну секунду, завершится
и основной поток в методе main () .
Различий во временных характеристиках обоих потоков в данном и ряде последующих
простых примеров хватает для того, чтобы основной поток в методе main () завершился
последним, но на практике этого, как правило, оказывается недостаточно. В Java
предоставляются более совершенные способы, позволяющие организовать ожидание
завершения потока. Далее будет продемонстрирован более совершенный способ организации
ожидания одним потоком завершения другого.
И последнее замечание: обычно мноrопоточная программа разрабатывается с таким
расчетом, чтобы последним завершал свою работу основной поток. Как правило,
выполнение программы продолжается до тех пор, пока все потоки не завершат работу.
Поэтому завершение основного потока является не требованием, а рекомендуемой для
наследования нормой, особенно для тех, кто лишь начинает осваивать мноrопоточное
программирование.
Несложные усовершенствования мноrопоточной программы
Рассмотренная выше мноrопоточная программа вполне работоспособна, тем не менее
ей не помешает небольшая доработка, повышающая ее эффективность. Во-первых,
404 Java 8: руководство для начинающих. 6-е издание
можно сделать так, чтобы поток начинал выполняться сразу же после того, как он создается.
Это достигается за счет создания экземпляра объекта типа Thread в конструкторе
класса MyThread. И во-вторых, нет никакой нужды хранить в объекте типа MyThread
имя потока - оно может быть присвоено потоку при его создании. Эту задачу позволяет
решить следующая версия конструктора Thread:
Thread(RunnaЫe threadOb, String имя)
где имя обозначает конкретное имя потока.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Почему основной поток рекомендуется завершать последним?
ОТВЕТ. В основном потоке удобно выполнять действия по подготовке к завершению
программы, например закрывать файлы. Именно поэтому основной поток
желательно завершать последним. К счастью, организовать ожидание в основном
потоке завершения порожденных потоков совсем не сложно.
Получить имя потока можно, используя метод getName (), определенный в классе
Thread. Вот объявление этого метода:
final String getName()
В приведенной ниже программе имя присваивается потоку после его создания с помощью
метода setName () . И хотя в этом нет особой необходимости, такое решение выбрано
лишь для того, чтобы продемонстрировать возможности класса Thread. Объявление
метода setName () имеет следующий вид:
final void setName(String имя
_
потока)
где имя
_
потока обозначает имя, которое присваивается потоку.
Ниже приведена видоизмененная версия предьщущей программы.
// Усовершенствованная версия класса MyThread
class MyThread implements RunnaЬle {
Thread thrd; В этой переменной хроннтся ссыnко на nоток
// Создать новый поток.
MyThread(String name) {
thrd = new Thread(this, name);
thrd.start(); запустить поток
----- Имя nрнсванвается потоку nрн ero соэданнн
-----Начоnо выnоnнення потока
// Начать выполнение нового потока.
puЫic void run() {
System.out.println(thrd.getName() + " - запуск");
try {
for(int count=O; count<lO; count++) {
Thread.sleep(400);
Глава 11 . Многопоточное программирование 405
Systern.out.println("B " + thrd.getNarne() +
счетчик: " + count);
catch(InterruptedException ехс) {
System.out.println(thrd.getName() + " - прерван");
System.out.println(thrd.getNarne() + " завершение");
class UseThreadsimproved {
puЫic static void main(String args[])
System.out.println("Зaпycк основного потока");
MyThread mt = new MyThread("Child #1");
for(int i=O; i < 50; i++)
System.out.print(".");
try {
Thread.sleep(lOO);
LТеперь поток зопускоется nрн ero создоннн
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
System.out.println("Зaвepшeниe основного потока");
Эта версия программы дает тот же результат, что и предыдущая. Обратите внимание
на то, что ссьшка на поток хранится в переменной thrd экземпляра класса MyThread.
Упражнение 11.1 Расширение класса Тhread
:.·
.·
E
··
·
􀀫·
t
·
··
·-􀀬.·􀀭.·.d·.·т_
.
h_·.􀀮--.􀀯.·.􀀰.d
·
·-·..:· .;..􀀱. · ...􀀲· .􀀳..· .· ..:. Реализация интерфейса RunnaЫe - это лишь ОДИН ИЗ спосо-
бов получения экземпляров потоковых объектов. Другой спо-
соб состоит в создании подкласса, производного от класса Thread. В этом проекте будет
продемонстрировано, каким образом расширение класса Thread позволяет реализовать
такие же функциональные возможности, как и рассмотренная перед этим программа
UseThreadsimproved.
Подкласс, производный от класса Thread, должен переопределить метод run () , который
является точкой входа в новый поток. Для того чтобы начать исполнение нового
потока, следует вызвать метод start (). Можно также переопределить и друтие методы
из класса Thread, но делать это не обязательно. Поэтапное описание процесса создания
программы приведено ниже.
1. Создайте файл ExtendThread. j ava. Скопируйте в этот файл исходный код второго
из рассмотренных выше примеров программы (файл UseThreadsimproved.
java).
2. Измените объявление класса MyThread. Теперь он должен наследовать класс
Thread:
class MyThread extends Thread {
406 Java 8: руководство для начинающих. 6-е издание
3. Удалите следующую строку кода:
Thread thrd;
Переменная thrd больше не нужна, поскольку класс MyThread включает в себя
экземпляр класса Thread и может ссьmаться на самого себя.
4. Внесите в конструктор класса Thread следующие изменения.
// Создать новый поток
MyThread(String name) {
super{name}; // присвоить имя потоку
start{); // запустить поток
Как видите, в данном конструкторе присутствует ключевое слово super, которое
используется для вызова следующего варианта конструктора Thread:
Thread { String имя) ;
где имя обозначает конкретное имя, присваиваемое потоку.
5. Внесите приведенные ниже изменения в метод run () , чтобы он вызывал метод
getName () непосредственно, без уточнения его имени с помощью переменной
thrd.
// Начать выполнение нового метода
puЬlic void run{) {
System.out.println(getName{} + " - запуск"};
try {
}
1
for{int count=O; count < 10; count++)
Thread.sleep{400);
System.out.println("B " + getName() +
", счетчик: " + count};
catch(InterruptedException ехс) {
System.out.println{getName{) + " - прерван");
System.out.println{getName{) + " - завершение"};
6. Ниже приведен полный исходный код программы, в которой вместо реализации
интерфейса RunnaЫe используется подкласс, производный от класса Thread. Выполнение
этой программы дает тот же результат, что и предьщущие ее версии.
/*
Упражнение 11 . 1
Расширение класса Thread
*/
class MyThread extends Thread
// Создать новый поток
MyThread(String name} {
super{name); // присвоить имя потоку
start(); // запустить поток
Глава 11. Многопоточное программирование 407
// Начать выполнение нового потока
puЫic void run() {
System.out.println(getName() + " - запуск");
try {
for(int count=O; count < 10; count++)
Thread.sleep(400);
System.out.println("B " + getName() +
счетчик: " + count) ;
catch(InterruptedException ехс) {
System.out.println(getName() + " прерван");
System.out.println(getName() + " завершение");
class ExtendThread {
puЫic static void main(String args[])
System.out.println("Зaпycк основного потока");
MyThread mt = new MyThread("Child #1");
for(int i=O; i < 50; i++)
System.out.print(".");
try {
Thread.sleep(lOO);
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
System.out.println("Зaвepшeниe основного потока");
Создание нескольких потоков
В предыдущем примере был создан только один порожденный поток. Но в программе
можно породить столько потоков, сколько требуется. Например, в приведенной
ниже программе формируются три порожденных потока.
// Создание нескольких потоков
class MyThread implements RunnaЫe
Thread thrd;
// Создать новый поток
MyThread(String name) {
thrd = new Thread(this, name);
408 Java 8: руководство для начинающих. 6-е издание
thrd.start(); // начать поток
// Начать выполнение нового потока
puЫic void run() {
System.out.println{thrd.getName{) + " - запуск");
try {
for(int count=O; count < 10; count++)
Thread.sleep{400);
System.out.println{"B " + thrd.getName{) +
", счетчик: " + count);
catch(InterruptedException ехс) {
System.out.println{thrd.getName{) + " - прерван");
System.out.println{thrd.getName{) + " - завершение");
class MoreThreads {
puЬlic static void main{String args[])
System.out.println{"Зaпycк основного потока");
MyThread mtl
MyThread mt2
MyThread mt3
new MyThread { "Child # 1") ;
new MyThread { "Child #2");
new MyThread{"Child #3");
for{int i=O; i < 50; i++)
System.out.print{".");
try {
Thread.sleep{lOO);
4-----Создонне н запуск но
вwnоnненне трех потоков
catch(InterruptedException ехс) {
System.out.println{"Пpepывaниe основного потока");
System.out.println{"Зaвepmeниe основного потока");
Ниже приведен результат выполнения данной программы.
Запуск основного потока
Child #1 - запуск
.Child #2 - запуск
Child #3 - запуск
... В Child #3, счетчик: О
В Child #2, счетчик: О
В Child #1, счетчик: О
.... В Child #1, счетчик: 1
В Child #2, счетчик: 1
В Child #3, счетчик: 1
Глава 11. Многопоточное программирование 409
.... В Child #2, счетчик: 2
В Child #3, счетчик: 2
В Child #1, счетчик: 2
... В Child #1, счетчик: 3
В Child #2, счетчик: 3
В Child #3, счетчик: 3
.... В Child #1, счетчик: 4
В Child #3, счетчик: 4
В Child #2, счетчик: 4
.... В Child #1, счетчик: 5
В Child #3, счетчик: 5
В Child #2, счетчик: 5
... В Child #3, счетчик: 6
.В Child #2, счетчик: 6
В Child #1, счетчик: 6
... В Child #3, счетчик: 7
В Child #1, счетчик: 7
В Child #2, счетчик: 7
.... В Child #2, счетчик: 8
В Child #1, счетчик: 8
В Child #3, счетчик: 8
.... В Child #1, счетчик: 9
Child #1 - завершение
В Child #2, счетчик: 9
Child #2 - завершение
В Child #3, счетчик: 9
Child #3 - завершение
............ Завершение основного потока
Как видите, после запуска на выполнение все три потока совместно используют
ресурсы ЦП. Следует иметь в виду, что потоки в данном примере запускаются на выполнение
в том порядке, в каком они были созданы. Но так происходит не всегда. Исполняющая
система Java сама планирует выполнение потоков. Вследствие отличий в
вычислительных средах у вас может получиться несколько иной результат.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Зачем нужны два способа создания порожденных потоков (расширение
класса Thread и реализация интерфейса RunnaЫe)? Какой из этих способов
предпочтительнее?
ОТВЕТ. В классе Thread имеется несколько методов, которые можно переопределить
в порожденном классе. Из них обязательному переопределению подлежит
только метод run () . Этот же метод, безусловно, должен быть определен и при
реализации интерфейса RunnaЫe. Некоторые программисты считают, что создавать
подкласс, порожденный от класса Thread, следует только в том случае, если
требуется дополнить его новыми функциями. Так, если переопределять любые
другие методы из класса Thread не нужно, то можно ограничиться только реализацией
интерфейса RunnaЫe. Кроме того, реализация интерфейса RunnaЫe
позволяет создаваемому потоку наследовать класс, отличающийся от Thread.
41 О Java 8: руководство для начинающих. 6-е издание
Определение момента завершения потока
Нередко требуется знать, когда завершится поток. Так, в приведенных выше примерах
ради большей наглядности нужно бьuю поддерживать основной поток действующим
до тех пор, пока не завершатся остальные потоки. Для этой цели основной поток переводился
в состояние ожидания на более продолжительное время, чем порожденные им
потоки. Но такое решение вряд ли можно считать удовлетворительным или общеупотребительным.
Правда, в классе Thread предусмотрены два средства, позволяющие определить, завершился
ли поток. Первым из них является метод isAli ve () , объявление которого
приведено ниже.
final boolean isAlive()
Этот метод возвращает значение true, если поток, для которого он вызывается, все
еще выполняется. В противном случае он возвращает значение false. Для того чтобы
опробовать метод isAlive () на практике, замените в предыдущей программе класс
MoreThreads новой версией, исходный код которой приведен ниже.
11 Использование метода isAlive().
class MoreThreads {
puЫic static void main(String args[])
System.out.println("Зaпycк основного потока");
MyThread mtl
MyThread mt2
MyThread mtЗ
new MyThread("Child #1");
new MyThread ( "Child #2") ;
new MyThread("Child #3");
do {
System.out.print(".");
try {
Thread.sleep(lOO);
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
while (mtl.thrd.isAlive() 11
mt2.thrd.isAlive() 11 -4-----Ожнданне эаверwенна асех nотокоа
mtЗ.thrd.isAlive());
System.out.println("Зaвepшeниe основного потока");
Эта версия дает тот же результат, что и предьщущая. Единственное отличие состоит
в том, что в данном случае ожидание завершения порожденного потока организовано с
помощью метода isAlive (). Вторым средством, позволяющим определить, завершился
ли поток, является метод join (), объявление которого приведено ниже:
final void join() throws InterruptedException
Этот метод ожидает завершения потока, мя которого он был вызван. Выбор его имени
был обусловлен тем, что вызывающий поток ожидает, когда указанный поток присоединится
(англ. "join") к нему. Имеется и другой вариант метода join (), позволяющий
указать максимальное время ожидания момента завершения потока.
Глава 11. Многопоточное программирование 411
В приведенном ниже примере программы наличие метода join () гарантирует, что
основной поток завершит работу последним.
// Использование метода join()
class MyThread implements RunnaЬle
Thread thrd;
// Создать новый поток
MyThread(String name) {
thrd = new Thread(this, name);
thrd.start(); // запустить поток
// Начать выполнение нового потока
puЫic void run() {
System.out.println(thrd.getName() + " - запуск");
try {
for(int count=O; count < 10; count++)
Thread.sleep(400);
System.out.println("B " + thrd.getName() +
", счетчик: " + count);
catch(InterruptedException ехс) {
System.out.println(thrd.getName() + " - прерван");
System.out.println(thrd.getName() + " - завершение");
class JoinThreads {
puЬlic static void main(String args[J)
System.out.println("Зaпycк основного потока");
MyThread mtl
MyThread mt2
MyThread mt3
new MyThread("Child #1");
new MyThread("Child #2");
new MyThread("Child #3");
try {
mtl.thrd.join();
System.out.println("Child #1 - присоединен"); Ожидание до тех пор, пока
mt2.thrd.join(); -----------------<>---указанный метод не эа11ерwнтс11
Systern.out.println("Child #2 - присоединен");
mt3.thrd.join();
System.out.println("Child #3 - присоединен");
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
System.out.println("Зaвepшeниe основного потока");
412 Java 8: руководство для начинающих, 6-е издание
Результат выполнения данной программы приведен ниже. Вследствие отличий в вычислительных
средах он может получиться у вас несколько иным.
Запуск основного потока
Child #1 - запуск
Child #2 - запуск
Child #3 - запуск
В Child #2, счетчик: о
в Child #1, счетчик: о
в Child #3, счетчик: о
в Child #2, счетчик: 1
в Child #3, счетчик: 1
в Child #1, счетчик: 1
в Child # 2, счетчик: 2
в Child #1, счетчик: 2
в Child #3, счетчик: 2
в Child #2, счетчик: 3
в Child #3, счетчик: 3
в Child #1, счетчик: 3
в Child #3, счетчик: 4
в Child #2, счетчик: 4
в Child #1, счетчик: 4
в Child #3, счетчик: 5
в Child #1, счетчик: 5
в Child #2, счетчик: 5
в Child #3, счетчик: 6
в Child #2, счетчик: 6
в Child #1, счетчик: 6
в Child #3, счетчик: 7
в Child #1, счетчик: 7
в Child #2, счетчик: 7
в Child #3, счетчик: 8
в Child #2, счетчик: 8
в Child #1, счетчик: 8
в Child #3, счетчик: 9
Child #3 - завершение
В Child #2, счетчик: 9
Child #2 - завершение
В Child #1, счетчик: 9
Child #1 - завершение
Child #1 - присоединен
Child #2 - присоединен
Child #3 - присоединен
Завершение основного потока
Как видите, после того как вызываемый метод join () возвращает управление, выполнение
потока прекращается.
Приоритеты потоков
С каждым потоком ассоциируется определенный приоритет. В частности, от приоритета
потока зависит относительная доля процессорного времени, предоставляемого
данному потоку, по сравнению с остальными активными потоками. Вообще говоря, в
Глава 11. Многопоточное программирование 41 З
течение некоторого определенного промежуrка времени низкоприоритетные потоки будут
получать меньше времени центрального процессора (ЦП), а высокоприоритетные
потоки - больше. Как и можно было ожидать, время ЦП, получаемое потоком, оказывает
определяющее влияние на характеристики его выполнения и взаимодействия с
другими потоками, выполняющимися в настояший момент в системе.
Следует иметь в виду, что, помимо приоритета, на частоту доступа потока к ЦП оказывают
влияние и другие факторы. Так, если высокоприоритетный поток ожидает доступа
к некоторому ресурсу, например, для ввода с клавиатуры, он блокируется, и вместо
него исполняется низкоприоритетный поток. Но когда высокоприоритетный поток
получит доступ к ресурсам, он прервет низкоприоритетный поток и возобновит свое
выполнение. На планирование работы потоков также влияет то, каким именно образом
в операционной системе поддерживается многозадачность (см. врезку "Спросим у эксперта"
в конце раздела). Следовательно, если один поток имеет более высокий приоритет,
чем друтой, это еще не означает, что первый поток будет исполняться быстрее второго.
Высокий приоритет потока лишь означает, что потенциально он может получить
больше времени ЦП.
При запуске порожденного потока его приоритет устанавливается равным приоритету
родительского потока. Изменить приоритет можно, вызвав метод setPriority ()
класса Thread. Ниже приведено объявление этого метода:
final void setPriority(int уровень)
С помощью параметра уровень данному методу передается новый приоритет потока.
Значение параметра уровень должно находиться в пределах от MIN PRIORITY до
МAX_PRIORITY. В настоящее время этим константам соответствуют числовые значения
от 1 до 10. Для того чтобы восстановить приоритет потока, заданный по умолчанию,
следует указать значение 5, которому соответствует константа NORМ PRIORITY. Константы,
определяющие приоритеты потоков, определены как static final в классе Thread.
Получить текуший приоритет можно с помощью метода getPriority () класса
Thread, объявляемого следующим образом:
final int getPriority()
Ниже приведен пример программы, демонстрирующий использование двух потоков,
выполняющихся соответственно с высоким (High Priori ty) и низким (Low Priori ty)
приоритетами. Потоки создаются как экземпляры класса Priori ty. В методе run () содержится
цикл, отсчитывающий число своих шагов. Этот цикл завершает работу, когда
значение счетчика достигает 10000000 или же когда статическая переменная stop принимает
значение true. Первоначально переменной stop присваивается значение false,
но первый же поток, заканчивающий отсчет, устанавливает в ней значение true. В результате
второй поток завершится, как только ему будет выделен квант времени. В цикле
производится проверка символьной строки в переменной currentName на совпадение с
именем исполняемого потока. Если они не совпадают, то это означает, что произошло
переключение задач. При этом отображается имя нового потока, которое присваивается
переменной currentName. Это дает возможность следить за тем, насколько часто каждый
поток получает время ЦП. После остановки обоих потоков выводится число шагов,
выполненных в каждом цикле.
// Демонстрация потоков с разными приоритетами
class Priority implements RunnaЫe {
414 Java 8: руководство для начинающих. 6-е издание
int count;
Thread thrd;
static boolean stop = false;
static String currentName;
/* Создание нового потока. Обратите внимание на то,
что конструктор не запускает поток на выполнение. */
Priority(String name) {
thrd = new Thread(this, name);
count = О;
currentName = пате:
// Начать выполнение нового потока
puЫic void run() {
System.out.println(thrd.getName() + " - запуск"):
do {
count++;
if(currentName.compareTo(thrd.getName()) != О) {
currentName = thrd.getName();
System.out.println("B " + currentName);
while(stop == false && count < 10000000);
stop = true;
4---- Первwй жв поток, в котором
достиntуто зночение 10000000,
зоверwоет остоnьнwе потоки
System.out.println("\n" + thrd.getName() +
" - завершение");
class PriorityDemo {
puЫic static void main(String args[]) {
Priority mtl new Priority("High Priority");
Priority mt2 = new Priority("Low Priority");
// Задать приоритеты
mtl.thrd.setPriority(Thread.NORМ_PRIORITY+2);
mt2.thrd.setPriority(Thread.NORМ_PRIORITY-2);
// Запустить потоки на выполнение
mtl.thrd.start();
mt2.thrd.start();
try {
mtl.thrd.join();
mt2.thrd.join();
4---- Поток mtl nоnучоет более
вwсокий приоритет, чем
noтoкmt2
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока"):
System.out.println("\nCчeтчик потока High Priority: " +
mtl.count);
Глава 11 . Многопоточное программирование 415
System.out.println("Cчeтчик потока Low Priority: " +
mt2. count) ;
Результат выполнения данной программы выглядит следующим образом.
High Priority - запуск
В High Priority
Low Priority - запуск
В Low Priority
В High Priority
High Priority - завершение
Low Priority - завершение
Счетчик потока High Priority: 10000000
Счетчик потока Low priority: 8183
В данном примере большую часть времени ЦП получает высокоприоритетный поток
(High Priority). Очевидно, что результат выполнения программы существенно зависит
от быстродействия ЦП и их количества, типа операционной системы и наличия
прочих задач, выполняющихся в системе.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Оказывает ли влияние конкретная реализация многозадачности на то,
какую долю времени ЦП получает поток?
ОТВЕТ. Если не учитывать приоритет потока, то наиболее важным фактором, оказывающим
влияние на выполнение потока, является способ реализации многозадачности
и планирования заданий в операционной системе. В одних операционных
системах применяется вытесняющая многозадачность, т.е. каждый
поток получает квант времени. В других же системах планирование задач осуществляется
по-друтому. В частности, второй поток иногда получает управление
только после завершения первого. В системах с невытесняющей многозадачностью
один поток будет господствовать над остальными, препятствуя их
выполнению.
Синхронизация
При использовании нескольких потоков иногда возникает необходимость в координации
их выполнения. Процесс, посредством которого это достигается, называют
синхронизацией. Чаще всего синхронизацию используют в тех случаях, когда несколько
потоков должны разделять ресурс, который может быть одновременно доступен только
одному потоку. Например, когда в одном потоке выполняется запись информации в
416 Java 8: руководство для начинающих. 6-е издание
файл, второму потоку должно быть запрещено делать это в тот же самый момент времени.
Синхронизация требуется и тогда, когда один поток ожидает событие, вызываемое
другим потоком. В подобных ситуациях требуются средства, позволяющие приостановить
один из потоков до тех пор, пока не произойдет определенное событие в другом
потоке. После этого ожидающий поток может возобновить свое выполнение.
Главным для синхронизации в Java является понятие монитора, контролирующего
доступ к объекту. Монитор реализует принцип блокировки. Если объект заблокирован
одним потоком, то он оказывается недоступным для других потоков. В какой-то момент
объект разблокируется, благодаря чему другие потоки смогут получить к нему доступ.
У каждого объекта в Java имеется свой монитор. Этот механизм встроен в сам язык.
Следовательно, синхронизировать можно любой объект. Для поддержки синхронизации
в Java предусмотрено ключевое слово synchronized и ряд вполне определенных методов,
имеющихся у каждого объекта. А поскольку средства синхронизации встроены в
язык, то пользоваться ими на практике очень просто - гораздо проще, чем может показаться
на первый взгляд. Для многих программ средства синхронизации объектов по
сути прозрачны.
Синхронизировать код можно двумя способами. Оба способа рассматриваются ниже,
и в обоих используется ключевое слово synchronized.
Использование синхронизированных методов
Для того чтобы синхронизировать метод, в его объявлении следует указать ключевое
слово synchronized. Когда такой метод получает управление, вызывающий поток активизирует
монитор, что приводит к блокированию объекта. Если объект блокирован, он
недоступен из другого потока, а кроме того, его нельзя вызвать из других синхронизированных
методов, определенных в классе данного объекта. Когда выполнение синхронизированного
метода завершается, монитор разблокирует объект, что позволяет другому
потоку использовать этот метод. Таким образом, для достижения синхронизации программисту
не приходится прилагать каких-то особых усилий.
Ниже приведен пример программы, демонстрирующий контролируемый доступ к
методу sumArray (). Этот метод суммирует элементы целочисленного массива.
// Использование ключевого слова synchronized для управления доступом
class SumArray {
private int sum;
synchronized int sumArray(int nums[]) {
sum = О; // обнулить сумму
for(int i=O; i<nums.length; i++) {
sum += nums[i];
----- Метод sumArray () синхрониэироаан
System.out.println("Teкyщee значение суммы для " +
Thread.currentThread() .getName() +
": " + sum);
try {
Thread.sleep(lO); // разрешить переключение задач
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
Глава 11. Многопоточное программирование 417
return sum;
class MyThread implements RunnaЫe {
Thread thrd;
static SumArray sa = new SumArray();
int а[];
int answer;
// Создать новый поток.
MyThread(String name, int nums[])
thrd = new Thread(this, name);
а = nums;
thrd.start(); // запустить поток
// Начать выполнение нового потока
puЫic void run() {
int sum;
System.out.println(thrd.getName() + " - запуск");
answer = sa.sumArray(a);
System.out.println("CYММA для " + thrd.getName() +
": " + answer);
System.out.println(thrd.getName() + " - завершение");
class Sync {
puЫic static void main(String args[]) {
int а[] = {l, 2, З, 4, 5};
MyThread mtl
MyThread mt2
new MyThread("Child #1", а);
new MyThread("Child #2", а);
Выполнение этой программы дает следующий результат.
Child #1 - запуск
Текущее значение суммы для Child #1: 1
Child #2 - запуск
Текущее значение суммы для Child #1: 3
Текущее значение суммы для Child #1: 6
Текущее значение суммы для Child #1: 10
Текущее значение суммы для Child #1: 15
СУММА для Child #1: 15
Child #1 - завершение
Текущее значение суммы для Child #2: 1
418 Java 8: руководство для начинающих. 6-е издание
Текущее значение суммы для Child #2: 3
Текущее значение суммы для Child #2: 6
Текущее значение суммы для Child #2: 10
Текущее значение суммы для Child #2: 15
СУММА для Child #2: 15
Child #2 - завершение
Рассмотрим подробнее эту программу. В ней определены три класса. Имя первого -
SurnArray. В нем содержится метод sumArray () , вычисляющий сумму элементов целочисленного
массива. Во втором классе MyThread используется статический объект sa
типа SurnArray для получения суммы элементов массива. А поскольку он статический,
то все экземпляры класса MyThread используют одну его копию. И наконец, в классе
Sync создаются два потока, в каждом из которых должна вычисляться сумма элементов
массива.
В методе sumArray () вызывается метод sleep (). Он нужен лишь для того, чтобы
обеспечить переключение задач. Метод surnArray () синхронизирован, и поэтому в каждый
момент времени он может использоваться только одним потоком. Следовательно,
когда второй порожденный поток начинает свое исполнение, он не может вызвать метод
sumArray () до тех пор, пока этот метод не завершится в первом потоке. Благодаря
этому обеспечивается правильность получаемого результата.
Чтобы лучше понять роль эффектов синхронизации, удалите ключевое слово
Synchronized из объявления метода surnArray (). В итоге метод surnArray () потеряет
синхронизацию и может быть использован в нескольких потоках одновременно. Связанная
с этим проблема заключается в том, что результат расчета суммы сохраняется в
переменной sum, значение которой изменяется при каждом вызове метода surnArray ()
для статического объекта sa. Например, если в двух потоках одновременно сделать вызов
sa. sumArray (), расчет суммы окажется неверным, поскольку в переменной sum
накапливаются результаты суммирования, выполняемого одновременно в двух потоках.
Ниже приведен результат выполнения той же программы, но с удаленным ключевым
словом synchronized в объявлении метода surnArray (). (Результат, полученный вами
на своем компьютере, может несколько отличаться.)
Child #1 - запуск
Текущее значение суммы для Child #1: 1
Child #2 - запуск
Текущее значение суммы ДЛЯ Child #2: 1
Текущее значение суммы для Child #1: 3
Текущее значение суммы для Child #2: 5
Текущее значение суммы для Child #2: 8
Текущее значение суммы для Child #1: 11
Текущее значение суммы для Child #2: 15
Текущее значение суммы для Child #1: 19
Текущее значение суммы для Child #2: 24
СУММА для Child #2: 24
Child #2 - завершение
Текущее значение суммы для Child #1: 29
СУММА для Child #1: 29
Child #1 - завершение
Нетрудно заметить, что одновременные вызовы метода sa. surnArray () из разных
потоков искажают результат.
Глава 11. Многопоточное программирование 4] 9
Прежде чем переходить к рассмотрению следующей темы, перечислим основные
свойства синхронизированных методов.
􀂁 Синхронизированный метод создается путем указания ключевого слова
synchronized в его объявлении.
lt! Как только синхронизированный метод любого объекта получает управление,
объект блокируется, и ни один синхронизированный метод этого объекта не может
быть вызван другим потоком.
􀂂 Потоки, которым требуется синхронизированный метод, используемый другим
потоком, ожидают до тех пор, пока не будет разблокирован объект, для которого
он вызывается.
щ; Когда синхронизированный метод завершается, объект, для которого он вызывался,
разблокировался.
Синхронизированные блоки
Несмотря на то что создание синхронизированных методов в классах - простой и
эффективный способ управления потоками, такой способ оказывается пригодным далеко
не всегда. Иногда возникает потребность синхронизировать доступ к методам, в
объявлении которых отсутствует ключевое слово synchronized. Подобная ситуация часто
возникает при использовании классов, которые были созданы независимыми разработчиками
и исходный код которых недоступен. В таком случае ввести в объявление
нужного метода ключевое слово synchronized вряд ли удастся. Как же тогда синхронизировать
объект класса, содержащего этот метод? К счастью, данное затруднение разрешается
очень просто. Достаточно ввести вызов метода в блок кода, объявленный как
synchronized (синхронизированный блок).
Синхронизированный блок определяется следующим образом.
synchronized (ссылка_ на_ объект)
// синхронизируемые операторы
Здесь ссылка_ на_ объект обозначает ссылку на конкретный объект, подлежащий
синхронизации. Как только содержимое синхронизированного блока получит управление,
ни один другой поток не сможет вызвать метод для объекта, на который указывает
ссылка_ на_ объект, до тех пор, пока этот блок не завершится.
Следовательно, обращение к методу surnArray () можно синхронизировать, вызвав
его из синхронизированного блока. Такой способ демонстрируется в приведенной ниже
переработанной версии предыдущей программы.
// Использование синхронизированного блока
// для управления доступом к методу surnArray()
class SurnArray {
private int sum;
int surnArray(int nums[]) {
sum = О; // обнулить сумму
4----- Здесь метод sumArray () не сннхроннзнроаон
420 Java 8: руководство для начинающих. 6-е издание
for(int i=O; i<nums.length; i++) {
sum += nums[i];
System.out.println("Teкyщee значение суммы для " +
Thread.currentThread() .getName() +
": •• + swn);
try {
Thread.sleep(lO); // разрешить переключение задач
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
return sum;
class MyThread implements RunnaЫe {
Thread thrd;
static SumArray sa = new SumArray();
int а[];
int answer;
!! Создать новый поток
MyThread(String name, int nums[])
thrd = new Thread(this, name);
а = nums;
thrd.start(); // запустить поток
// Начать выполнение нового потока
puЫic void run() {
int sum;
System.out.println(thrd.getName() + " - запуск");
synchronized( sa) { .....1-- --Здес􀀞 вwзовw метода stпnArray () дnя 061.екта sa синхроннэнрованw
answer = sa.sumArray(a);
System.out.println("CYММA для " + thrd.getName() +
": " + answer);
System.out.println(thrd.getName() + " - завершение");
class Sync {
puЫic static void main ( String args [ J) {
int а[]= {1, 2, 3, 4, 5};
MyThread mtl
MyThread mt2
try {
new MyThread("Child #1", а);
new MyThread("Child #2", а);
mtl.thrd.join();
mt2.thrd.join();
Глава 11. Многопоточное программирование 421
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe основного потока");
Выполнение этой версии программы дает такой же правильный результат, как и предыдущая
ее версии, в которой использовался синхронизированный метод.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Говорят, что существуют так называемые "утилиты параллелизма". Что
это такое? И что такое Fork/Join Framework?
ОТВЕТ. Утилиты параллелизма, входящие в пакет j ava. util. concurrent (и подчиненные
ему пакеты), предназначены для поддержки параллельного программирования.
Среди прочего они предоставляют синхронизаторы, пулы потоков,
диспетчеры исполнения и блокировки, которые расширяют возможности контроля
над выполнением потока. К числу наиболее привлекательных средств
прикладного интерфейса параллельного программирования относится среда
Fork/Join Framework, включенная в состав JDK 7.
В Fork/Join Framework поддерживается так называемое параллельное программирование.
Этим термином обычно обозначаются приемы программирования, использующие
преимущества компьютеров с двумя и более процессорами, включая
и многоядерные системы, которые позволяют разделять задачи на более
мелкие подзадачи, каждая из которых выполняется на собственном процессоре.
Нетрудно себе представить, что такой подход позволяет сушественно повысить
производительность и пропускную способность. Главное преимущество среды
Fork/Join Framework заключается в простоте ее использования. Она упрощает
создание многопоточных программ с автоматическим масштабированием для
использования нескольких процессоров в системе. Следовательно, она облегчает
разработку параллельных решений таких распространенных задач, как выполнение
операций над элементами массива. Утилиты параллелизма вообще и
Fork/Join Framework в частности относятся к тем средствам, которые вам стоит
освоить после того, как вы приобретете определенный опыт многопоточного
программирования.
Организация взаимодействия потоков с помощью
методов notify () , wai t () и notifyAll ()
В качестве примера рассмотрим следующую ситуацию. Поток т, который выполняется
в синхронизированном методе, нуждается в доступе к ресурсу R, который временно
недоступен. Что делать потоку т? Начать выполнение цикла опросов в ожидании того
422 Java 8: руководство для начинающих, 6-е издание
момента, когда освободится ресурс R? Но тогда поток т будет связывать объект, препятствуя
доступу к нему других потоков. Такое решение малопригодно, поскольку оно сводит
на нет все преимуrnества программирования в мноrопоточной среде. Будет гораздо
лучше, если поток т временно разблокирует объект и позволит другим потокам воспользоваться
ero методами. Когда ресурс R станет доступным, поток т получит об этом уведомление
и возобновит свое исполнение. Но для того чтобы такое решение можно было
реализовать, необходимы средства взаимодействия потоков, с помощью которых один
поток моr бы сообщить другому потоку о том, что он приостановил свое исполнение, а
также получить уведомление о том, что ero исполнение может быть возобновлено. Для
организации подобного взаимодействия потоков в Java предусмотрены методы wai t (),
notify () и notifyAll ().
Эти методы реализованы в классе Object, поэтому они доступны для любого объекта.
Но обратиться к ним можно только из синхронизированного контекста. А применяются
они следующим образом. Когда поток временно приостанавливает свое исполнение,
он вызывает метод wai t () . При этом поток переходит в состояние ожидания и
монитор данного объекта освобождается, позволяя другим потокам использовать объект.
Впоследствии ожидающий поток возобновит свое выполнение, когда другой поток войдет
в тот же самый монитор и вызовет метод notify () или notifyAll ().
В классе Obj ect определены следующие формы объявления метода wai t () .
final void wait() throws InterruptedException
final void wait(long миллисекунд) throws InterruptedException
final void wait(long миллисекунд, int наносекунд) throws
InterruptedException
В первой своей форме метод wait () переводит поток в режим ожидания до поступления
уведомления. Во второй форме метода ожидание длится либо до получения
уведомления, либо до тех пор, пока не истечет указанный промежуток времени. Третья
форма позволяет точнее задавать период времени в наносекундах.
Ниже приведены общие формы объявления методов notify () и notifyAll ().
final void notify()
final void notifyAll()
При вызове метода notify () возобновляется выполнение одного ожидающего потока.
Метод notifyAll () уведомляет все потоки об освобождении объекта, и тот поток,
который имеет наивысший приоритет, получает доступ к объекту.
Прежде чем перейти к рассмотрению конкретного примера, демонстрирующего применение
метода wai t () , необходимо сделать важное замечание. Несмотря на то что метод
wait () должен переводить поток в состояние ожидания до тех пор, пока не будет
вызван метод notify () или notifyAll (), иногда поток выводится из состояния ожидания
вследствие так называемой ложной активизации. Условия для ложной активизации
слишком сложны, чтобы их можно было рассмотреть в данной книге. Достаточно лишь
сказать, что компания Oracle рекомендует учитывать вероятность проявления ложной
активизации и помещать вызов метода wait () в цикл. В этом цикле должно проверяться
условие, по которому поток переводится в состояние ожидания. Именно такой подход
и применяется в приведенном ниже примере.
Глава 11 . Многопоточное программирование 423
Пример применения методов wai t () и notify ()
Для того чтобы вам стала понятнее потребность в применении методов wai t () и
notify () в мноrопоточном программировании, рассмотрим пример программы, имитирующей
работу часов и выводящей на экран слова "Tick" (Тик) и "Tock" (Так). Для
этой цели создадим класс TickTock, который будет содержать два метода: tick () и
tock (). Метод tick () выводит слово "Tick", а метод tock () - слово "Tock". При запуске
программы, имитирующей часы, создаются два потока: в одном из них вызывается
метод tick (), а в другом - метод tock (). В результате взаимодействия двух потоков
на экран будет выводиться набор повторяющихся сообщений "Tick Tock", т.е. после
слова "Tick", обозначающего один такт, должно следовать слово "Tock", обозначающее
другой такт часов.
// Использование методов wait() и notify() для имитации часов
class TickTock {
String state; // содержит сведения о состоянии часов
synchronized void tick(boolean running)
if(!running) { // остановить часы
state = "ticked";
notify(); // уведомить ожидающие потоки
return;
System.out.print("Tick ");
state = "ticked"; // установить текущее состояние
// после такта "тик"
notify(); позволить выполняться методу tock()
try {
while(!state.equals("tocked"))
-----Метод tick () nocwnaeт
уведомnенне методу tock ()
wai t () ; / / ожидать до завершения метода tock () .----Метод tick () ожидает
заверwенИА метода tock ()
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe потока");
synchronized void tock(boolean running)
if(!running) { // остановить часы
state = "tocked";
notify(); // уведомить ожидающие потоки
return;
System.out.println("Tock");
state = "tocked"; // установить текущее состояние
// после такта "так"
notify (); // позволить выполняться методу tick () .+-----Метод tock() nocwnaeт
try { уведомnенне методу tick ()
424 Java 8: руководство для начинающих. 6-е издание
while(!state.equals("ticked"))
wai t () ; / / ожидать до завершения метода tick () ----Метод tock ()
ожидает эоверwени•
catch(InterruptedException ехс) {
Systern.out.println("Пpepывaниe потока");
class MyThread irnplernents RunnaЫe {
Thread thrd;
TickTock ttOb;
!/ Создать новый поток.
MyThread(String narne, TickTock tt)
thrd = new Thread(this, narne);
ttOb = tt;
thrd.start(); // запустить поток
// Начать выполнение нового потока
puЫic void run() {
if(thrd.getNarne() .cornpareTo("Tick") == О)
for(int i=O; i<5; i++) ttOb.tick(true);
ttOb.tick(falseJ;
else {
for(int i=O; i<5; i++) ttOb.tock(true);
ttOb.tock(false);
class ThreadCorn
puЬlic static void rnain(String args[]) {
TickTock tt = new TickTock();
MyThread rntl new MyThread("Tick", tt);
MyThread rnt2 = new MyThread("Tock", tt);
try {
rntl.thrd.join();
rnt2.thrd.join();
catch(InterruptedException ехс) {
Systern.out.println("Пpepывaниe основного потока");
метода tick ()
В результате выполнения этой программы на экране появляются следующие сообщения.
Tick Tock
Tick Tock
Tick Tock
Tick Tock
Tick Tock
Глава 11. Многопоточное программирование 425
Рассмотрим более подробно исходный код программы, имитирующей работу часов.
В ее основу положен класс TickTock. В нем содержатся два взаимодействующих метода:
tick () и tock (). Это взаимодействие организовано таким образом, чтобы за словом
"Tick" всегда следовало слово "Tock", затем вновь слово "Tick" и т.д. Обратите внимание
на переменную state. В процессе работы имитатора часов в данной переменной
хранится строка "ticked" или "tocked", определяющая текущее состояние часов
после такта "тик" или "так" соответственно. В методе main () создается объект t t типа
TickTock, используемый для запуска двух потоков на исполнение.
Потоки строятся на основе объектов типа MyТhread. Конструктору MyТhread () передаются
два параметра. Первый из них задает имя потока (в данном случае - "Tick" или
"Tock"), а второй - ссылку на объект типа TickTock (в данном случае - объект tt).
В методе run () из класса MyThread вызывается метод tick () , если поток называется
"Tick", или же метод tock (), если поток называется "Tock". КаЖдый из этих методов
вызывается пять раз с параметром, принимающим логическое значение true. Работа
имитатора часов продолжается до тех пор, пока методу передается параметр с логическим
значением true. Последний вызов каЖдого из методов с параметром, принимающим
логическое значение false, останавливает имитатор работы часов.
Самая важная часть программы находится в теле методов tick () и tock () из класса
TickTock. Начнем с метода tick (). Для удобства анализа ниже представлен исходный
код этого метода.
synchronized void tick(boolean running)
if(!running) { // остановить часы
state = "ticked";
notify(); // уведомить ожидающие потоки
return;
System.out.print("Tick ");
state = "ticked"; // установить текущее состояние
// после такта "тик"
notify(); // позволить выполняться методу tock()
try {
while(!state.equals("tocked"))
wait(); // ожидать завершения метода tock()
catch(InterruptedException ехс) {
System.out.println("Пpepывaниe потока");
ПреЖде всего обратите внимание на то, что в объявлении метода tick () присутствует
ключевое слово synchronized, указываемое в качестве модификатора доступа. Как
пояснялось ранее, действие методов wait () и notify() распространяется только на
синхронизированные методы. В начале метода tick () проверяется значение параметра
running. Этот параметр служит для корректного завершения программы, имитирующей
работу часов. Если он принимает значение false, имитатор работы часов должен
426 Java 8: руководство для начинающих. 6-е издание
быть остановлен. Если же параметр running принимает значение true, а переменная
state - значение "ticked", вызывается метод notify (), разрешающий ожидающему
потоку возобновить свое исполнение. Мы еще вернемся к этому вопросу несколько
позже.
По ходу работы имитируемых часов в методе tick () выводится слово "Tick", переменная
state принимает значение "ticked", а затем вызывается метод notify (). Вызов
метода notify () возобновляет исполнение ожидающего потока. Далее в цикле while
вызывается метод wai t (). В итоге выполнение метода tick () будет приостановлено до
тех пор, пока другой поток не вызовет метод notify (). Таким образом, очередной шаг
цикла не будет выполнен до тех пор, пока другой поток не вызовет метод notify () для
того же самого объекта. Поэтому, когда вызывается метод tick (), на экран выводится
слово "Tick" и другой поток получает возможность продолжить свое исполнение, а затем
выполнение этого метода приостанавливается.
В том цикле while, в котором вызывается метод wait (), проверяется значение переменной
state. Значение "tocked", означающее завершение цикла, будет установлено
только после выполнения метода tock (). Этот цикл предотвращает продолжение исполнения
потока в результате ложной активизации. Если по окончании ожидания в переменной
state не будет присутствовать значение "tocked", значит, имела место ложная
активизация, и метод wai t () будет вызван снова.
Метод tock () является почти точной копией метода tick (). Его отличие состоит
лишь в том, что он выводит на экран слово "Tock" и присваивает переменной state
значение "tocked". Следовательно, когда метод tock () вызывается, он выводит на
экран слово "Tock", вызывает метод notify (), а затем переходит в состояние ожидания.
Если проанализировать работу сразу двух потоков, то станет ясно, что за вызовом
метода tick () тотчас следует вызов метода tock (), после чего снова вызывается метод
tick (), и т.д. В итоге оба метода синхронизируют друг друга.
При остановке имитатора работы часов вызывается метод notify (). Это нужно для
того, чтобы возобновить выполнение ожидающего потока. Как упоминалось выше, в
обоих методах, tick () и tock (), после вывода сообщения на экран вызывается метод
wait (). В результате при остановке имитатора работы часов один из потоков обязательно
будет находиться в состоянии ожидания. Следовательно, последний вызов метода
notify () необходим. В качестве эксперимента попробуйте удалить вызов метода
notify () и посмотрите, что при этом произойЛет. Вы увидите, что программа зависнет,
и вам придется завершить ее нажатием комбинации клавиш <Ctrl+C>. Дело в том, что
когда метод tock () в последний раз получает управление, он вызывает метод wai t (),
после чего не происходит вызов метода notify () , позволяющего завершиться методу
tock (). В итоге метод tock () остается в состоянии бесконечного ожидания.
Если у вас еще остаются сомнения по поводу того, что методы wai t () и notify ()
необходимы для организации нормального выполнения программы, имитирующей работу
часов, замените в ее исходном коде класс TickTock приведенным ниже его вариантом.
Он отличается тем, что в нем удалены вызовы методов wait () и notify ().
// В этой версии вызовы методов wait() и notify() отсутствуют
class TickTock {
String state; // содержит сведения о состоянии часов
synchronized void tick(boolean running)
if ( 1 running) { / / остановить часы
state = "ticked";
return;
Глава 11. Многопоточное программирование 427
System.out.print("Tick ");
state = "ticked"; // установить текущее состояние
// после такта "тик"
synchronized void tock(boolean running)
if(!running) { // остановить часы
state = "tocked";
return;
System.out.println("Tock");
state = "tocked"; // установить текущее состояние
// после такта "так"
Теперь программа выводит на экран следующие сообщения.
Tick Tick Tick Tick Tick Tock
Tock
Tock
Tock
Tock
Это происходит потому, что методы tick () и tock () не взаимодействуют друг с
другом.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Мне приходилось слышать, как при обсуждении многопоточных программ,
ведущих себя не так, как ожидалось, использовался термин взаимоблокировка.
Что это такое и как этого избежать? Кроме того, что такое состояние
гонки и как с этим бороться?
ОТВЕТ. Взаимоблокировка возникает в тех случаях, когда один поток ожидает завершения
некоторых действий другим потоком, а другой - того же самого от
первого. В итоге оба потока оказываются в состоянии ожидания, и их выполнение
не может возобновиться. Это можно сравнить с поведением двух джентльменов,
каждый из которых ни за что не соглашается пройти в дверь раньше
другого.
На первый взгляд, предотвратить взаимоблокировку нетрудно, но на самом деле
это совсем не так. Например, взаимоблокировка может возникнуть косвенным
образом. Причины ее не всегда понятны, поскольку между потоками нередко
428 Java 8: руководство для начинающих. 6-е издание
вратить взаимоблокировку - тщательно проектировать и тестировать создаваемый
исходный код. Если многопоточная программа время от времени зависает,
то, скорее всего, имеет место взаимоблокировка.
Состояние гонки возникает в тех случаях, когда несколько потоков пытаются
одновременно получить доступ к общему ресурсу без должной синхронизации.
Так, в одном потоке может сохраняться значение в переменной, а в другом -
инкрементироваться текущее значение этой же переменной. В отсутствие синхронизации
конечный результат будет зависеть от того, в каком именно порядке
выполняются потоки: инкрементируется ли значение переменной во втором
потоке или же оно сохраняется в первом. В подобных ситуациях конечный результат
зависит от того, какой из потоков завершится первым. Возникающее
состояние гонки, как и взаимоблокировку, непросто обнаружить. Поэтому его
лучше предотвратить, синхронизируя должным образом доступ к общим ресурсам
на стадии программирования.
Приостановка, возобновление
и остановка потоков
Иногда бывает полезно приостановить или даже полностью прекратить выполнение
потока. Допустим, отдельный поток используется для отображения времени. Если пользователю
не нужны часы на экране, то отображающий их поток можно приостановить.
Независимо от причин, по которым требуется временная остановка потока, сделать это
нетрудно, как, впрочем, и возобновить исполнение потока.
Механизмы приостановки, возобновления и остановки потоков менялись в разных
версиях Java. До появления версии Java 2 для этих целей использовались методы
suspend () , resurne () и stop () , определенные в классе Thread. Ниже приведены общие
формы их объявления.
final void resurne()
final void suspend()
final void stop()
На первый взгляд кажется, что упомянутые выше методы удобны для управления потоками,
но пользоваться ими все же не рекомендуется по следующим причинам. При
выполнении метода suspend () иногда возникают серьезные осложнения, приводящие
к взаимоблокировке. Метод resurne () сам по себе безопасен, но применяется только в
сочетании с методом suspend (). Что же касается метода stop () из класса Thread, то и
он не рекомендуется к применению, начиная с версии Java 2, поскольку может вызывать
порой серьезные осложнения в работе многопоточных программ.
Если методы suspend () , resurne () и stop () нельзя использовать для управления потоками,
то может показаться, что приостановить, возобновить и остановить поток вообще
нельзя. Но это, к счастью, не так. Поток следует разрабатывать таким образом,
чтобы в методе run () периодически осуществлялась проверка того, следует ли приостановить,
возобновить или остановить поток. Обычно для этой цели используются две
флаговые переменные: одна - для приостановки и возобновления потока, другая - для
Глава 11. Многопоточное программирование 429
остановки потока. Если флаговая переменная, управляющая приостановкой потока,
установлена в состояние исполнения, то метод run () должен обеспечить продолжение
выполнения потока. Если же эта флаговая переменная находится в состоянии приостановки,
в работе потока должна произойти пауза. А если переменная, управляющая
остановкой потока, находится в состоянии остановки, то выполнение потока должно
прекратиться.
Следующий пример программы демонстрирует один из способов реализации собственных
версий методов suspend () , resume () и stop () .
// Приостановка, возобновление и остановка потока
class MyThread implements RunnaЫe {
Thread thrd;
volatile boolean suspended;
volatile boolean stopped;
MyThread{String name) {
4---- Приостанавливает поток при значении true
----- Останавпивает поток при значении true
thrd = new Thread{this, name);
suspended = false;
stopped = false;
thrd.start{);
// Точка входа в поток.
puЫic void run() {
System.out.println{thrd.getName() + " - запуск");
try {
for(int i = 1; i < 1000; i++)
System.out.print(i + "
if( (i%10)==0) {
System.out.println();
Thread.sleep(250);
") i
synchronized(this)
while(suspended)
wait ();
4---- Этот синхронизированный бnок исnоnьзуется дnя
тестирования переменных suspended и stopped
if(stopped) break;
catch (InterruptedException ехс) {
System.out.println(thrd.getName() + " - прерван");
System.out.println(thrd.getName() + " - выход");
// Остановить поток
synchronized void mystop()
stopped = true;
// Следующие операторы обеспечивают полную
// остановку приостановленного потока
suspended = false;
430 Java 8: руководство для начинающих. 6-е издание
notify();
// Приостановить поток
synchronized void mysuspend()
suspended = true;
// Возобновить поток
synchronized void myresume()
suspended = false;
notify ();
class Suspend {
puЫic static void main(String args[]) {
MyThread оЫ = new MyThread("My Thread");
try (
Thread.sleep(lOOO); // позволить потоку оЫ начать выполнение
oЫ.mysuspend();
System.out.println("Пpиocтaнoвкa потока");
Thread.sleep(lOOO);
oЫ.myresume();
System.out.println("Boзoбнoвлeниe потока");
Thread.sleep(lOOO);
oЫ.mysuspend();
System.out.println("Пpиocтaнoвкa потока");
Thread.sleep(lOOO);
оЫ .myresume ();
System.out.println("Boзoбнoвлeниe потока");
Thread.sleep(lOOO);
oЫ.mysuspend();
System.out.println("Ocтaнoвкa потока");
oЫ.mystop();
catch (InterruptedException е)
System.out.println("Пpepывaниe основного потока");
// Ожидать завершения потока
try (
oЫ.thrd.join();
catch (InterruptedException е)
System.out.println("Пpepывaниe основного потока");
System.out.println("Bыxoд из основного потока");
Глава 11 . Многопоточное программирование 431
Ниже приведен результат выполнения данной программы.
Му Thread - запуск
1 2 3 4 5 6 7 8 9 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
Приостановка потока
Возобновление потока
41 42 43 44 45 46 47 48 49 50
51 52 53 54 55 56 57 58 59 60
61 62 63 64 65 66 67 68 69 70
71 72 73 74 75 76 77 78 79 80
Приостановка потока
Возобновление потока
81 82 83 84 85 86 87 88 89 90
91 92 93 94 95 96 97 98 99 100
101 102 103 104 105 106 107 108 109 110
111 112 113 114 115 116 117 118 119 120
Остановка потока
Му Thread - выход
Выход из основного потока
Эта программа работает следующим образом. В классе потока MyThread определены
две логические переменные, suspended и stopped, управляющие временной и полной
остановкой потока. В конструкторе этого класса обеим переменным присваивается значение
false. Метод run () содержит синхронизированный блок, в котором проверяется
состояние переменной suspended. Если эта переменная принимает значение true,
вызывается метод wai t (), приостанавливающий выполнение потока. Значение true
присваивается переменной suspended в методе mysuspend () , и поэтому данный метод
следует вызвать для приостановки потока. Для возобновления потока служит метод
myresume (), в котором переменной suspended присваивается значение false и вызывается
метод notify ().
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Многопоточное программирование, по-видимому, является эффективным
средством повышения производительности программ. Какие рекомендации
можно дать по его эффективному применению?
ОТВЕТ. Самое главное для эффективного многопоточного программирования -
мыслить категориями параллельного, а не последовательного выполнения
кода. Так, если в одной программе имеются две подсистемы, которые могут работать
параллельно, их следует организовать в отдельные потоки. Но делать это
следует очень внимательно и тщательно, поскольку слишком большое количество
потоков приводит не к повышению, а к снижению производительности.
Следует также иметь в виду дополнительные издержки, связанные с переключением
контекста. Так, если создать слишком много потоков, то на смену контекста
уЙдет больше времени ЦП, чем на выполнение самой программы!
432 Java 8: руководство для начинающих. 6-е издание
Для остановки потока следует вызвать метод mys top (), в котором переменной
stopped присваивается значение tr ue. Кроме того, в методе mystop () переменной
suspended присваивается значение false и вызывается метод notify (). Это необходимо
для прекращения работы потока, исполнение которого ранее было приостановлено.
Упражнение 11.2 Применение основноrо потока
: .................................... = \ UseMain. j ava \ В каждой программе на Java присутствует хотя бы один поток, на,
.................................... , зываемый основным. Этот поток автоматически получает управле-
ние при запуске программы на выполнение. В этом проекте будет продемонстрировано,
что основным потоком можно управлять точно так же, как и любым другим. Поэтапное
описание процесса создания программы приведено ниже.
1. Создайте файл UseMain. j ava.
2. Для доступа к основному потоку нужно получить ссылающийся на него объект
типа Thread. Для этого следует вызвать метод currentThread (), являющийся
статическим членом класса Thread. Ниже приведено объявление этого метода.
static Thread currentThread()
Метод currentThread () возвращает ссьmку на тот поток, из которого он вызывается.
Так, если вызвать метод currentThread () из основного потока, можно
получить ссылку на этот поток. А имея ссылку на основной поток, можно управлять
им.
3. Введите в файл UseMain. j ava приведенный ниже исходный код программы.
В процессе ее выполнения сначала извлекается ссылка на основной поток, а затем
определяется и устанавливается имя и приоритет потока.
/*
Упражнение 11.2
Управление основным потоком
*/
class UseMain {
puЫic static void rnain (String args []) {
Thread thrd;
// Получить основной поток
thrd = Thread.currentThread();
// Отобразить имя основного потока
Systern.out.println("Имя основного потока: " +
thrd.getNarne());
// Отобразить приоритет основного потока
Systern.out.println("Пpиopитeт: " +
thrd.getPriority());
Systern.out.println();
Глава 11. Многопоточное программирование 433
// Установить имя и приоритет основного потока
System.out.println("Ycтaнoвкa имени и приоритета\n");
thrd.setName("Thread #1");
thrd.setPriority(Thread.NORМ_PRIORITY+З);
System.out.println("Hoвoe имя основного потока: " +
thrd.getName());
System.out.println("Hoвoe значение приоритета: " +
thrd.getPriority());
4. Ниже приведен результат выполнения данной проrраммы.
Имя основного потока: main
Приоритет: 5
Установка имени и приоритета
Новое имя основного потока: Thread #1
Новое значение приоритета: В
5. Выполняя операции над основным потоком, необходимо соблюдать осторожность.
Так, если добавить в конце метода main () приведенный ниже код, проrрамма
никогда не завершится, потому что будет ожидать завершения основного
потока.
:ffl
try {
thrd. j oin () ;
catch(InterruptedException ехс) {
System.out.println("Interrupted");
Вопросы н упражнения для самопроверки
1. Каким образом имеющиеся в Java средства мноrопоточноrо программирования
обеспечивают создание более эффективных проrрамм?
2. Для поддержки мноrопоточноrо проrраммирования в Java предусмотрены класс
_____ и интерфейс _____ _
3. В каких случаях при создании выполняемого объекта следует отдать предпочтение
расширению класса Thread, а не реализации интерфейса RunnaЫe?
4. Покажите, как с помощью метода j oin () можно организовать ожидание завершения
потокового объекта MyThrd.
5. Покажите, как установить приоритет потока MyThrd на три уровня выше нормального.
6. Что произойдет, если в объявлении метода указать ключевое слово synchronized?
434 Java 8: руководство для начинающих. 6-е издание
7. Методы wait () и notify () предназначены для обеспечения ______ _
8. Внесите в класс TickTock изменения для организации фактического отчета времени.
Первую половину секунды должен занимать вывод на экран слова "Tick",
а вторую - вывод слова "Tock". Таким образом, сообщение "Tick-Tock" должно
соответствовать одной секунде отсчитываемого времени. (Время переключения
контекстов можно не учитывать.)
9. Почему в новых программах на Java не следует применять методы suspend () ,
resume () и stop ()?
10. С помощью какого метода из класса Thread можно получить имя потока?
11. Какое значение возвращает метод isAli ve ()?
12. Попытайтесь самостоятельно реализовать средства синхронизации в классе
Queue, разработанном в предыдущих главах. Ваша цель - обеспечить корректное
функционирование класса в условиях многопоточной обработки.
Глава 12
Перечисления,
автоупаковка,
статическии импорт
и аннотации
436 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
%i Основные сведения о перечислимых типах
􀂷 Объектные свойства перечислений
* Применение методов values () и valueof () к перечислениям
@ Создание перечислений с конструкторами, переменными экземпляров
и методами
it,i Применение методов ordinal () и compareTo (), наследуемых перечис-
лениями от класса Enum
􀂸 Использование объектных оболочек Java
<1' Основные сведения об автоупаковке и автораспаковке
􀂹 Использование автоупаковки в методах
·t:: Использование автоупаковки в выражениях
,r, Использование статического импорта
'* Общий обзор аннотаций
в данной главе рассматриваются перечисления, аннотации, механизмы автоупаковки
и статического импорта. И хотя ни одно из этих средств первоначально не входило
в Java (все они были добавлены в версии JDK 5), каждое из них увеличивает мощь
языка и делает его использование более удобным. Включение в язык Java перечислений
и автоупаковки удовлетворило давнюю потребность программистов в этих средствах,
статический импорт упростил использование статических членов классов, а введение
аннотаций позволило внедрять в исходные файлы дополнительную информацию. Совокупность
этих средств обеспечила более эффективные способы решения часто встречающихся
задач программирования. В этой главе обсуждаются также оболочки типов Java.
Перечисления
В своей простейшей форме перечисление - это список именованных констант, определяющих
новый тип данных. В объектах перечислимого типа могут храниться лишь
значения, содержащиеся в этом списке. Таким образом, перечисления позволяют определять
новый тип данных, характеризующийся строго определенным рядом допустимых
значений.
Перечисления часто встречаются в повседневной жизни. В качестве примера можно
привести номинальные значения денежных купюр, а также названия дней недели или
месяцев в году - все они являются перечислениями.
С точки зрения программирования перечисления оказываются удобными в тех случаях,
когда требуется определить набор значений, представляющих коллекцию элементов.
Например, с помощью перечисления можно представить набор кодов состояния
(успешное завершение, ожидание, ошибка, необходимость повторной попытки), которые
соответствуют различным стадиям какого-либо процесса. Разумеется, для этих
Глава 12. Перечисления. автоупаковка. статический импорт... 437
целей вполне можно использовать константы типа final, но перечисления обеспечивают
более структурированный подход к решению подобных задач.
Основные сведения о перечислениях
Перечисления создаются с использованием ключевого слова enum. Вот так, например,
может выглядеть простое перечисление, представляющее различные виды транспортных
средств .
// Перечисление, представляющее разновидности транспортных средств
enurn Transport {
CAR, TRUCK, AIRPLANE, TRAIN, ВОАТ
Идентификаторы CAR, TRUCK и т.д. - константы перечисления. Каждый из них неявно
объявлен как открытый (puЫic), статический (static) член перечисления Transport.
Типом этих констант является тип перечисления (в данном случае Transport). В Java
подобные константы называют самотипизированными, где приставка "само" относится к
перечислению, которому они принадлежат.
Определив перечисление, можно создавать переменные этого типа. Однако, несмотря
на то что перечисление - это тип класса, объекты этого класса создаются без привлечения
оператора new . Переменные перечислимого типа создаются подобно переменным
элементарных типов. Например, для определения переменной tp типа Transport
понадобится следующая строка кода:
Transport tp;
Поскольку переменная tp относится к типу Transport, ей можно присваивать только
те значения, которые определены для данного типа. Например, в следующей строке
кода переменной tp присваивается значение AIRPLANE:
tp = Transport.AIRPLANE;
Обратите внимание на то, что значению AIRPLANE предшествует указанный через
точку тип Transport.
Для проверки равенства констант перечислимого типа используется операция сравнения
(==). Например, в следующей строке кода содержимое переменной tp сравнивается
с константой TRAIN.
if(tp == Transport.TRAIN) // ...
Перечисления можно использовать в качестве селектора в переключателе swi tch.
Разумеется, в ветвях case должны указываться только константы того же перечислимого
типа, что и в выражении swi tch. Например, вполне допустим код наподобие следующего.
// Использование перечисления для управления оператором switch
switch (tp) {
case CAR:
//
case TRUCK:
//
Заметьте, что в ветвях case оператора swi tch используются простые имена констант,
а не уточненные. Так, в приведенном выше коде вместо полного имени Transport.
TRUCK используется простое имя TRUCК. Этого достаточно, поскольку тип перечисления
438 Java 8: руководство для начинающих. 6-е издание
в выражении оператора swi tch неявно задает тип констант в ветвях case. Более того,
если вы попытаетесь указать тип констант явным образом, компилятор выведет сообщение
об ошибке.
При отображении константы перечислимого типа, например, с помощью метода
println (), выводится ее имя. Так, в результате выполнения следующего оператора отобразится
имя ВОАТ:
System.out.println(Transport.BOAT);
Ниже приведен пример программы, демонстрирующий все особенности применения
перечисления Transport.
// Использование перечисления Transport.
// Перечисление, представляющее разновидности транспортных средств
enum Transport {
CAR, TRUCK, AIRPLANE, TRAIN, ВОАТ
class EnumDemo {
puЫic static void main(String args[])
{
1
Обь11аление
nеречисnениА
Transport tp; ------------ОбъАаление ссыпки на перечисnение Transport
tp = Transport.AIRPLANE; -4------Присваивание переменной tp значениА в виде
константы AIRPLANE
// Отобразить перечислимое значение
System.out.println("Знaчeниe tp: " + tp);
System.out.println();
tp = Transport.TRAIN; -------Проверка равенства двух объектов типа Transport
// Сравнить два перечислимых значения
if(tp == Transport.TRAIN)
System.out.println("tp содержит TRAIN\n");
// Использовать перечисление для управления оператором switch
swi tch ( tp) { Испаn�,зование перечисnениА дnА управnениА оператором switch
case CAR:
System.out.println("Aвтoмoбиль перевозит людей");
break;
case TRUCK:
System.out.println("Гpyзoвик перевозит груз");
break;
case AIRPLANE:
System.out.println("Caмoлeт летит");
break;
case TRAIN:
System.out.println("Пoeзд движется по рельсам");
break;
case ВОАТ:
System.out.println("Лoдкa плывет по воде");
break;
Глава 12. Перечисления. автоупаковка. статический импорт... 439
Результат выполнения данной программы выглядит следующим образом.
Значение tp: AIRPLANE
tp содержит TRAIN
Поезд движется по рельсам
Прежде чем продвигаться дальше, следует сделать одно замечание. Имена констант
в перечислении Transport указываются прописными буквами (например, одна из
констант перечисления называется CAR, а не car). Однако это требование не является
обязательным. Никаких особых требований к регистру символов в именах констант не
предъявляется. Но поскольку константы перечислимого типа обычно играют ту же роль,
что и финальные (final) переменные, которые традиционно обозначаются прописными
буквами, для записи имен констант принято использовать тот же способ. И хотя на
этот счет существуют различные точки зрения, в примерах программ, представленных в
книге, для констант перечислимого типа будут использоваться имена, записанные прописными
буквами.
Перечисления Java являются типами классов
Несмотря на то что предыдущие примеры позволили продемонстрировать создание
и использование перечислений, они не дают полного представления обо всех возможностях
этого типа данных. В Java, в отличие от других языков программирования, перечисления
реализованы как типы классов. И хотя для создания экземпляров класса enurn
не требуется использовать оператор new, во всех остальных отношениях они ничем не
отличаются от классов. Реализация перечислений Java в виде классов позволила значительно
расширить их возможности. В частности, допускается определение конструкторов
перечислений, добавление в них объектных переменных и методов и даже создание
перечислений, реализующих интерфейсы.
Методы values () и valueOf ()
Все перечисления автоматически включают два предопределенных метода: values ()
и valueOf (), общие формы объявления которых приведены ниже.
puЬlic static перечислимый_ тип[] values ()
puЫic static перечислимый_тип valueOf(String str)
Метод values () возвращает массив, содержащий список констант перечисления,
а метод valueOf () - константу перечисления, значение которой соответствует строке
str, переданной методу в качестве аргумента. В обоих случаях перечислимый_
тип - это тип перечисления. Например, в случае рассмотренного выше перечисления
Transport вызов метода Transport. valueOf ( "TRAIN") возвратит значение TRAIN типа
Transport. Рассмотрим пример программы, демонстрирующей использование методов
values () и valueOf ().
// Использование встроенных методов перечислений.
// Перечисление, представляющее разновидности транспортных средств
enum Transport {
440 Java 8: руководство для начинающих. 6-е издание
CAR, TRUCK, AIRPLANE, TRAIN, ВОАТ
class EnumDemo2
puЬlic static void main(String args[J)
{
Transport tp;
System.out.println("Koнcтaнты Transport:");
// применение метода values()
Transport allTransports[] = Transport.values()
for(Transport t : allTransports)
System.out.println(t);
System.out.println();
// применение метода valueOf()
; -4---Поnученне массива
констант типа Transport
tp = Transport. valueOf ("AIRPLANE") ..-------nоnученне констонтwАIRРLАNЕ
System.out.println("tp содержит " + tp);
Выполнение этой программы дает следующий результат.
Константы Transport:
CAR
TRUCK
AIRPLANE
TRAIN
ВОАТ
tp содержит AIRPLANE
Обратите внимание на то, что в данном примере ДJIЯ перебора массива констант, полученного
с помощью метода values (), используется версия for-each цикла for. Чтобы
сделать пример более наглядным, в нем создается переменная allTransports, которой
присваивается ссьшка на массив констант перечисления. Однако делать это вовсе
не обязательно, и цикл for можно переписать так, как показано ниже. (В этом случае
необходимость в использовании дополнительной переменной allTransports отпадает.)
for(Transport t : Transport.values())
System.out.println(t);
Обратите внимание также на то, что значение, соответствующее имени AIRPLANE,
бьmо получено в результате вызова метода valueOf ():
tp = Transport.valueOf("AIRPLANE");
Как объяснялось ранее, метод valueOf () возвращает значение перечислимого типа,
ассоциированное с именем константы, представленной в виде строки.
Глава 12. Перечисления. автоупаковка. статический импорт... 441
Конструкторы, методы, переменные
экземпляра и перечисления
Очень важно, чтобы вы понимали, что в перечислении каждая константа является
объектом класса данного перечисления. Таким образом, перечисление может иметь
конструкторы, методы и переменные экземпляра. Если определить для объекта перечислимого
типа конструктор, он будет вызываться всякий раз при создании константы
перечисления. Для каждой константы перечислимого типа можно вызвать любой метод,
определенный в перечислении. Кроме того, у каждой константы перечислимого типа
имеется собственная копия любой переменной экземпляра, определенной в перечислении.
Ниже приведена переработанная версия предыдущей программы, которая демонстрирует
использование конструктора, переменной экземпляра, а также метода перечисления
Transport и выводит для каждого вида транспортного средства его типичную
скорость движения.
// Использование конструктора, переменной экземпляра и
// метода перечисления
enum Transport {
CAR(65), TRUCK(55), AIRPLANE(бOO), TRAIN(70), ВОАТ(22)
private int speed; // типичная скорость транспортного
Обратите внимание на
способ инициоnиэации
констант
/ / средства Добавление переменной экэеммяра
// конструктор
Transport(int s) { speed s; ) -----------Добавпенне конструктора
// метод
int getSpeed() { return speed; }
class EnumDemoЗ
puЫic static void main(String args[J)
{
Transport tp;
Добавление метода
// Отобразить скорость самолета
System.out.println("Tипичнaя скорость самолета: " +
Определение скорости
Transport. AIRPLANE. getSpeed () + ... с помощью
" миль в час\n"); мeтoдagetSpeed()
// Отобразить все виды транспорта и скорости их движения
System.out.println("Tипичныe скорости движения
транспортных средств");
for(Transport t : Transport.values())
System.out.println(t + ": " +
t.getSpeed() +
"миль в час");
442 Java 8: руководство для начинающих. 6-е издание
Выполнение этой программы дает следующий результат.
Типичная скорость самолета: 600 миль в час
Типичные скорости движения транспортных средств
CAR: 65 миль в час
TRUCK: 55 миль в час
AIRPLANE: 600 миль в час
TRAIN: 70 миль в час
ВОАТ: 22 миль в час
В этой версии программы перечисление Transport претерпело ряд изменений.
Во-первых, появилась переменная экземпляра speed, используемая для хранения скорости
движения транспортного средства. Во-вторых, в перечисление Transport добавлен
конструктор, которому передается значение скорости. И в-третьих, в перечисление
добавлен метод getSpeed () , возвращающий значение переменной speed, т.е. скорость
движения данного транспортного средства.
Когда переменная tp объявляется в методе main (), для каждой константы перечисления
автоматически вызывается конструктор Transport (). Аргументы, передаваемые
конструктору, указываются в скобках после имени константы, как показано ниже.
CAR(65), TRUCK(55), AIRPLANE(600), TRAIN(70), ВОАТ(22);
Числовые значения, передаваемые конструктору Transport () через параметр s,
присваиваются переменной speed. Обратите внимание на то, что список констант перечислимого
типа завершается точкой с запятой. Последней в этом списке указана константа
ВОАТ. Точка с запятой требуется в том случае, если класс перечисления содержит
наряду с константами и другие члены.
У каждой константы перечислимого типа имеется собственная копия переменной
speed, что позволяет получить скорость передвижения конкретного транспортного
средства, вызвав метод getSpeed (). Например, в методе main () скорость самолета
определяется с помощью следующего вызова:
Traпsport.AIRPLANE.getSpeed()
Скорость каждого транспортного средства определяется в процессе перебора констант
перечислимого типа в цикле for. А поскольку каждая такая константа имеет собственную
копию переменной speed, то значения скорости, ассоциированные с разными
константами, отличаются друг от друга. Такой принцип организации перечислений довольно
эффективен, но он возможен только в том случае, если перечисления реализованы
в виде классов, как это сделано в Java.
В предыдущем примере использовался только один конструктор, но перечисления,
как и обычные классы, допускают любое число конструкторов.
Два важных ограничения
В отношении перечислений действуют два ограничения. Во-первых, перечисление
не может быть подклассом другого класса. И во-вторых, перечисление не может выступать
в роли суперкласса. Иными словами, перечислимый тип enum нельзя расширять.
Если бы это было не так, перечисления вели бы себя как обычные классы. Основной же
особенностью перечислений является создание констант в виде объектов того класса, в
котором они определены.
Глава 12. Перечисления. автоупаковка. статический импорт ... 443
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Теперь, когда в Java включены перечисления, можно ли считать, что финальные
(final) переменные больше не нужны?
ОТВЕТ. Нет, нельзя. Перечисления удобны в тех случаях, когда приходится иметь
дело со списками элементов, которые должны представляться идентификаторами.
В то же время финальные переменные целесообразно применять для
хранения постоянных значений, например размеров массивов, которые многократно
используются в программе. Таким образом, у каЖдого из этих языковых
средств имеется своя область применения. Преимущество перечислений проявляется
в тех случаях, когда переменные типа final не совсем удобны.
Перечисления наследуются от класса Enшn
Несмотря на то что перечисление не может наследовать суперкласс, все перечисления
автоматически наследуют переменные и методы класса j ava. lang. Enum. В этом
классе определен ряд методов, доступных всем перечислениям. И хотя большинство
этих методов используются редко, тем не менее два из них иногда применяются в программах
на Java. Это методы ordinal () и compareтo ().
Метод ordinal () позволяет получить так называемое порядковое значение, которое
указывает позицию константы в списке констант перечисления. Ниже приведена общая
форма объявления метода ordinal () :
final int ordinal()
Этот метод возвращает порядковое значение вызывающей константы. Отсчет порядковых
значений начинается с нуля. Следовательно, в перечислении Transport порядковое
значение константы CAR равно нулю, константы TRUCK - 1, константы AIRPLANE -
2 И Т.Д.
Для сравнения порядковых значений двух констант одного и того же перечисления
можно воспользоваться методом compareTo (). Ниже приведена общая форма объявления
этого метода.
final int соmраrеТо(перечислимый_тип е)
Здесь перечислимый_ тип - это тип перечисления, а е - константа, сравниваемая
с вызывающей константой. При этом не следует забывать, что вызывающая константа и
константа е должны относиться к одному и тому же перечислимому типу. Если порядковое
значение вызывающей константы меньше порядкового значения константы е, то
метод compareTo () возвращает отрицательное значение. Если же их порядковые значения
совпадают, возвращается нулевое значение. И наконец, если порядковое значение
вызывающей константы больше порядкового значения константы е, метод возвращает
положительное значение.
Ниже приведен пример программы, демонстрирующий применение методов ordinal ()
и compareTo () .
444 Java 8: руководство для начинающих. 6-е издание
// Использование методов ordinal() и compareTo().
// Перечисление, представляющее разновидности транспортных средств
enum Transport {
CAR, TRUCK, AIRPLANE, TRAIN, ВОАТ
class EnumDemo4
puЬlic static void main(String args[J)
{
Transport tp, tp2, tрЗ;
// Получить порядковые значения с помощью метода ordinal()
System.out.println("Koнcтaнты перечисления Transport и их
порядковые значения: ");
for(Transport t : Transport.values())
System.out.println(t + " " + t.ordinal()) ; Попученнепорядковых
tp = Transport.AIRPLANE;
tp2 Transport.TRAIN;
tрЗ = Transport.AIRPLANE;
System.out.println();
// Демонстрация использования метода compareTo()
зноченнй
i f ( tp. compareTo ( tp2) < О) Сровненне порядко11ых зноченнй
System.out.println(tp + " идет перед " + tp2);
if(tp.compareTo(tp2) > О)
System.out.println(tp2 + " идет перед " + tp);
if(tp.compareTo(tpЗ) == О)
System.out.println(tp + " совпадает с " + tрЗ);
Результат выполнения данной программы выглядит следующим образом.
Константы перечисления Transport и их
порядковые значения:
CAR О
TRUCK 1
AIRPLANE 2
TRAIN 3
ВОАТ 4
AIRPLANE идет перед TRAIN
AIRPLANE совпадает с AIRPLANE
Упражнение 12.1 Автоматизированный светофор
[i:􀀛i:􀀜:􀀝􀀞:􀀟􀀠:􀀡i􀀢:􀀣􀀤􀀥ii):􀀦i.􀀧::::i 􀀨􀀩:::􀀪::􀀫;: в0 􀀴;􀀵::::;:::􀀶х􀀷д::0
0 ::::􀀆􀀇= :а;;;
констант, конкретные значения которых неважны, - достаточно, чтобы они отличались
друг от друга. Необходимость в подобных константах часто возникает при написании
Глава 12. Перечисления. автоупаковка. статический импорт ... 445
программ. В качестве показательноrо примера можно привести обработку ряда фиксированных
состояний некоеrо устройства. Допустим, требуется написать код, управляющий
светофором, трем состояниям которого соответствуют зеленый, желтый и красный
свет. Этот код должен периодически переключать светофор из одного состояния в другое.
Кроме того, данный код должен передавать некоему друтому коду информацию о
текущем цвете светофора и предоставлять ему возможность задавать нужный начальный
цвет. Отсюда следует, что необходимо каким-то образом представить три состояния светофора.
И хотя для этого вполне можно было бы использовать целочисленные значения,
например, 1, 2 и 3, или символьные строки "red" (красный), "green" (зеленый) и
"yellow" (желтый), лучше воспользоваться перечислением. С помощью перечисления
можно написать более эффективный и структурированный код, чем тот, в котором применяются
символьные строки или целочисленные значения.
В этом проекте предстоит сымитировать автоматизированный светофор. Наряду
с использованием перечислений в нем будет дополнительно продемонстрирован еще
один пример организации многопоточной обработки и синхронизации потоков. Поэтапное
описание процесса создания программы приведено ниже.
1. Создайте файл TrafficLightDemo. java.
2. Начните с создания перечисления TrafficLightColor, представляющего три состояния
светофора.
// Перечисление, представляющее цвета светофора
enum TrafficLightColor {
RED, GREEN, YELLOW
Каждая из констант в этом перечислении соответствует определенному цвету светофора.
3. Далее начните определять класс TrafficLightSimulator, как показано ниже.
Этот класс инкапсулирует имитацию светофора.
// Автоматизированное управление светофором
class TrafficLightSimulator implements RunnaЫe
private Thread thrd; // поток для имитации светофора
private TrafficLightColor tlc; // текущий цвет светофора
boolean stop = false; // для остановки имитации установить в true
boolean changed = false; // true, если светофор переключился
TrafficLightSimulator(TrafficLightColor init) {
tlc = init;
thrd = new Thread(this);
thrd.start();
TrafficLightSimulator()
tlc = TrafficLightColor.RED;
thrd = new Thread(this);
thrd.start();
446 Java 8: руководство для начинающих. 6-е издание
Заметьте, что класс TrafficLightSimulator реализует интерфейс RunnaЬle. Это
необходимо, поскольку для переключения цветов светофора будет использоваться
отдельный поток. Для класса TrafficLightSimulator определены два конструктора.
Первый из них позволяет задать начальный цвет светофора, второй устанавливает
для светофора красный цвет по умолчанию. В обоих конструкторах запускается
новый поток, предназначенный для управления переключением цветов.
Далее рассмотрим переменные экземrmяра. Ссылка на поток, регулирующий состояние
светофора, хранится в переменной thrd. Информация о текущем цвете
хранится в переменной tlc. Переменная stop служит для остановки имитации.
Первоначально она принимает значение false. Имитация светофора будет действовать
до тех пор, пока эта переменная не примет логическое значение true.
И наконец, переменная changed принимает значение true при переключении
светофора, когда его цвет меняется.
4. Добавьте приведенный ниже метод run (), запускающий имитацию автоматизированного
светофора.
// Запуск имитации автоматизированного светофора
puЫic void ruп() {
while ( ! stop) {
try {
switch(tlc)
case GREEN:
Thread.sleep(lOOOO); // зеленый на 10 секунд
break;
case YELLOW:
Thread.sleep(2000); // желтый на 2 секунды
break;
case RED:
Thread.sleep(l2000); // красный на 12 секунд
break;
catch(InterruptedException ехс) {
System.out.println(exc);
changeColor();
Этот метод циклически переключает цвета светофора. Сначала выполнение потока
приостанавливается на заданный промежуток времени, который выбирается
в зависимости от конкретного цвета светофора. Затем вызывается метод
changeColor () , переключающий цвет светофора.
5. Добавьте приведенный ниже метод changeColor () , переключающий цвет светофора.
// Переключение цвета светофора
synchronized void changeColor()
switch (tlc) {
case RED:
tlc = TrafficLightColor.GREEN;
Глава 12. Перечисления. автоупаковка. статический импорт ... 447
break;
case YELLOW:
tlc = TrafficLightColor.RED;
break;
case GREEN:
tlc = TrafficLightColor.YELLOW;
changed true;
notify(); // уведомить о переключении цвета светофора
В операторе swi tch проверяется информация о цвете светофора, хранящаяся
в переменной tlc, после чего этой переменной присваивается другой цвет.
Обратите внимание на то, что этот метод синхронизирован. Это необходимо было
сделать потому, что он вызывает метод notify (), уведомляющий о смене цвета.
(Напомним, что обратиться к методу notify () можно только из синхронизированного
контекста.)
6. Далее добавьте метод wai tForChange (), ожидающий переключения цвета светофора.
// Ожидание переключения цвета светофора
synchronized void waitForChange() {
try {
while ( ! changed)
wait(); // ожидать переключения цвета светофора
changed = false;
catch(InterruptedException ехс) {
Systern.out.println(exc);
Действие этого метода ограничивается вызовом метода wai t () . Возврат из него
не произойдет до тех пор, пока в методе changeColor () не будет вызван метод
notify (). Следовательно, метод wai tForChange () не завершится до переключения
цвета светофора.
7. И наконец, добавьте метод getColor (), возвращающий текущий цвет светофора,
а вслед за ним - метод cancel () , останавливающий имитацию светофора,
присваивая переменной stop значение true. Ниже приведен исходный код обоих
методов.
// Возврат текущего цвета
TrafficLightColor getColor()
return tlc;
// Прекращение имитации светофора
void cancel () {
stop = true;
8. Ниже приведен полный исходный код программы, имитирующей автоматизированный
светофор с помощью перечисления.
448 Java 8: руководство для начинающих. 6-е издание
// Упражнение 12.1
// Имитация автоматизированного светофора с использованием
// перечисления.
// Перечисление, представляющее цвета светофора
enurn TrafficLightColor
RED, GREEN, YELLOW
// Имитация автоматизированного светофора
class TrafficLightSimulator implements RunnaЫe
private Thread thrd; // поток для имитации светофора
private TrafficLightColor tlc; // текущий цвет светофора
boolean stop = false; // для остановка имитации установить в true
boolean changed = false; // true, если светофор переключился
TrafficLightSimulator(TrafficLightColor init) {
tlc = init;
thrd = new Thread(this);
thrd.start();
TrafficLightSimulator()
tlc = TrafficLightColor.RED;
thrd = new Thread(this);
thrd.start();
// Запуск имитации автоматизированного светофора
puЬlic void run() {
while ( ! stop) {
try {
switch(tlc)
case GREEN:
Thread.sleep(lOOOO); // зеленый на 10 секунд
break;
case YELLOW:
Thread.sleep(2000); // желтый на 2 секунды
break;
case RED:
Thread.sleep(l2000); // красный на 12 секунд
break;
catch(InterruptedException ехс) {
System.out.println(exc);
changeColor();
Глава 12. Перечисления. автоупаковка. статический импорт ... 449
// Переключение цвета светофора
synchronized void changeColor()
switch (tlc) {
case RED:
tlc = TrafficLightColor.GREEN;
break;
case YELLOW:
tlc = TrafficLightColor.RED;
break;
case GREEN:
tlc = TrafficLightColor.YELLOW;
changed true;
notify(); // уведомить о переключении цвета светофора
// Ожидание переключения цвета светофора
synchronized void waitForChange() {
try {
while ( ! changed)
wait(); // ожидать переключения цвета светофора
changed = false;
catch(InterruptedException ехс) {
System.out.println(exc);
// Возврат текущего цвета
TrafficLightColor getColor()
return tlc;
// Прекращение имитации светофора
void cancel() {
stop = true;
class TrafficLightDemo {
puЫic static void main(String args[]) {
TrafficLightSimulator tl =
new TrafficLightSimulator(TrafficLightColor.GREEN);
for (int i=O; i < 9; i++) {
System.out.println(tl.getColor());
tl.waitForChange();
tl.cancel();
450 Javo 8: руководство для начинающих. 6-е издание
При выполнении этой программы на экран выводится показанный ниже результат.
Как видите, цвета светофора переключаются в требуемой очередности: зеленый,
желтый, красный.
GREEN
YELLOW
RED
GREEN
YELLOW
RED
GREEN
YELLOW
RED
Обратите внимание на то, что использование перечисления позволило упростить
исходный код, нуждающийся в информации о состоянии светофора, и улучшить
его структуризацию . Светофор может находиться в одном из трех состояний , и
для этой цели в перечислении предусмотрены только три константы. Благодаря
этому предотвращается случайное переключение имитируемого светофора в недопустимое
состояние.
9. Можно усовершенствовать рассмотренную программу, используя тот факт, что
перечисления реализуются в виде классов. Соответствующее задание будет предложено
в упражнении для самопроверки в конце главы.
Автоупаковка
В версии JDK 5 были добавлены два очень полезных средства - автоупаковка и
автораспаковка, - существенно упрощающих и ускоряющих создание кода, в котором
приходится преобразовывать простые типы данных в объекты и наоборот. Поскольку
такие ситуации возникают в программах на Java довольно часто, вытекающие отсюда
преимущества почувствуют программисты, участвующие в различных проектах. Как будет
показано в главе 13, автоупаковка и автораспаковка в значительной мере обусловили
широкую применимость обобщенных типов.
Автоупаковка и автораспаковка непосредственно связаны с оболочками типов и способами
помещения и извлечения значений в экземпляры оболочек и из них. Поэтому
мы начнем с общего обзора оболочек типов и способов упаковки и распаковки значений
вручную.
Оболочки типов
Как вы уже знаете, в Java предусмотрены простые типы данных, в том числе int и
douЫe. Простые типы позволяют добиться более высокой эффективности вычислений
по сравнению с объектами. Однако простые типы не являются частью иерархии объектов
и не наследуют свойства и методы класса Obj ect.
Несмотря на высокую эффективность простых типов, возникают такие ситуации,
когда для представления данных желательно использовать объекты. Например, переменную
простого типа нельзя передать методу по ссылке. Кроме того, многие стандартные
структуры данных, реализованные в Java, предполагают работу с объектами,
Глава 12. Перечисления. автоупаковка. статический импорт... 451
и поэтому в них нельзя хранить данные простых типов. Для преодоления затруднений,
возникающих в подобных и во многих других ситуациях, в Java предусмотрены оболочки
типов - классы, инкапсулирующие простые типы данных. Классы оболочек типов упоминались
в главе IO, а здесь они будут рассмотрены более подробно.
Оболочки типов реализуются в классах DouЫe, Float, Long, Integer, Short, Byte,
Character и Boolean, входящих в пакет j ava. lang. Эти классы предоставляют методы,
позволяющие полностью интегрировать простые типы данных в иерархию объектов
Java.
Чаще всего применяются оболочки типов, представляющие числовые типы данных:
Byte, Short, Integer, Long, Float и DouЫe. Все оболочки числовых типов данных являются
производными от абстрактного класса NumЬer. В классе NumЬer определены методы,
возвращающие значение объекта для каждого числового типа данных. Эти методы
перечислены ниже.
byte byteValue()
douЫe douЫeValue()
float floatValue()
int intValue()
long longValue()
short shortValue()
Например, метод douЫeValue () возвращает значение объекта как douЫe, метод
floatValue () - как float и т.д. Перечисленные выше методы реализуются каждым
классом оболочки числового типа.
В каждом классе оболочки числового типа предусмотрены конструкторы, позволяющие
сформировать объект на основе соответствующего простого типа данных или его
строкового представления. Например, в классах Integer и DouЫe имеются следующие
конструкторы.
Integer(int num)
Integer(String str)
DouЫe(douЫe num)
DouЫe(String str)
Если параметр str не содержит допустимое строковое представление числового значения,
то генерируется исключение NumЬerForrnatException.
Во всех оболочках типов переопределен метод toString (). Он возвращает из оболочки
значение в удобной для чтения форме. Это позволяет выводить значения на
экран, передавая объекты оболочек в качестве параметра методу, например println (), и
не преобразуя их предварительно в простые типы данных.
Процесс инкапсуляции значения в оболочке типа называется упаковкой. До появления
версии JDK 5 упаковка производилась вручную, т.е. посредством явного создания
экземпляра класса оболочки с нужным значением. Например, для упаковки значения
100 в объект типа Integer требовалась следующая строка кода:
Integer iOb = new Integer(lOO);
В данном примере явно создается объект типа Integer, в который упаковывается
значение 100, а ссьшка на этот объект присваивается переменной iOb.
Процесс извлечения значения из объекта оболочки называется распаковкой. До
появления версии JDK 5 распаковка также производилась вручную, т.е. для извлечения
значения, упакованного в этом объекте, приходилось явным образом вызывать
452 Java 8: руководство для начинающих. 6-е издание
соответствующий метод объекта оболочки. Например, для распаковки значения из объекта
iOb вручную и присваивания результата переменной int требовалась следующая
строка кода:
int i = iOb.intValue();
В данном примере метод intValue () возвращает значение, упакованное в объекте
iOb как int.
Рассмотренные выше механизмы упаковки и распаковки демонстрируются в приведенном
ниже примере программы.
!/ Упаковка и распаковка значений вручную
class Wrap {
puЫic static void main(String args[J)
Integer iOb = new Integer(lOO) -----Упаковка значения 100
int i = iOb.intValue() -----Распаковка значения 100 из объекта iOb вручную
System.out.println(i + " " + iOb); // отображает 100 100
В данной программе целочисленное значение 100 упаковывается в объект типа
Integer, на который ссылается переменная iOb. Для извлечения упакованного числового
значения вызывается метод intValue (). Полученное значение сохраняется в переменной
i. А в конце программы на экран выводятся значения переменных i и iOb,
каждое из которых равно 100.
Аналогичная процедура использовалась в проrраммах для упаковки и распаковки
значений, начиная с ранних версий Java и до появления JDK 5. Но это не совсем удобно.
Более тоrо, создание объектов оболочек разных типов вручную может сопровождаться
ошибками. Но теперь, с появлением автоупаковки и автораспаковки, обращаться с
оболочками типов стало значительно проще.
Основные сведения об автоупаковке
Автоупаковка - это процесс автоматической инкапсуляции (упаковки) простого
типа данных в объектную оболочку соответствующего типа всякий раз, коrда в этом
возникает необходимость, причем создавать такой объект явным образом не нужно.
Автораспаковка - это обратный процесс автоматического извлечения (распаковки) значения,
упакованного в объектную оболочку. Благодаря автораспаковке отпадает необходимость
в вызове таких методов, как intValue () и douЫeValue ().
Поддержка автоупаковки и автораспаковки существенно упрощает реализацию целоrо
ряда алгоритмов, так как в этом случае все рутинные операции по упаковке и распаковке
значений простых типов берет на себя исполняющая система Java, что позволяет
уменьшить вероятность возникновения программных ошибок. Автоупаковка освобождает
программиста от необходимости создавать вручную объекты для заключения в них
простых типов данных. Достаточно присвоить упаковываемое значение переменной,
ссьшающейся на объект оболочки соответствующего типа, и нужный объект будет автоматически
создан исполняющей системой Java. Ниже приведен пример создания объекта
типа Integer, в который автоматически упаковывается целочисленное значение 100.
Integer iOb = 100; // автоупаковка целочисленного значения
Глава 12. Перечисления. автоупаковка. статический импорт... 453
Обратите внимание на то, что в данном примере отсугствует оператор new, конструирующий
объект явным образом. Создание объекта происходит автоматически.
Для распаковки значения из объекта достаточно присвоить переменной простого
типа ссылку на этот объект. Например, для распаковки значения, упакованного в объекте
iOb, нужно ввести в код следующую строку:
int i = iOb; // автораспаковка
Все остальное возьмет на себя исполняющая система Java. Ниже приведен пример
программы, демонстрирующий автоупаковку и автораспаковку.
// Демонстрация автоупаковки и автораспаковки
class AutoBox {
puЬlic static void main(String args[]) {
Integer iOb 100; ""
1--Автоупоковко и поспедующо•
int i = iOb; ...... _ ___, овтороспоковко зночени• 100
System.out.println(i +" "+ iOb); // отображает 100 100
Автоупаковка и методы
Автоупаковка и автораспаковка происходят не только в простых операциях присваивания,
но и в тех случаях, когда простой тип требуется преобразовать в объект и наоборот.
Следовательно, автоупаковка и автораспаковка могуг происходить при передаче
аргумента методу и при возврате значения последним . Рассмотрим в качестве примера
следующую программу.
// Автоупаковка и автораспаковка при передаче
!/ параметров и возврате значений из методов
class AutoBox2 {
// Этот метод принимает параметр типа Integer
static void m ( Integer v) { Поnучоет Integer
System.out.println("m() получил"+ v);
// Этот метод возвращает значение типа int
static int m2() { Возврощоетint
return 10;
// Этот метод возвращает значение типа Integer
static Integer mЗ( ) { Возвращает Integer
return 99; // автоупаковка значения 99 в объект типа Integer
puЫic static void main(String args[])
// Передача методу m() значения типа int.
// Метод m() принимает параметр типа Integer,
454 Java 8: руководство для начинающих. 6-е издание
// поэтому значение int автоматически упаковывается.
m(l99);
// Объект iOb получает значение типа int, возвращаемое
// методом m2(). Это значение автоматически упаковывается,
// чтобы его можно было присвоить объекту iOb.
Integer iOb = m2();
System.out.println("Знaчeниe, возвращенное из m2(): " + iOb);
// Далее метод mЗ() возвращает значение типа Integer, которое
// автоматически распаковывается и преобразуется в тип int.
int i = mЗ();
System.out.println("Знaчeниe, возвращенное из mЗ(): " + i);
// Далее методу Math.sqrt() в качестве параметра передается
// объект iOb, который автоматически распаковывается, а его
// значение повьппается до типа douЬle, требующегося для
// выполнения данного метода.
iOb = 100;
System.out.
println("Kopeнь квадратный из iOb: " + Math.sqrt(iOb));
Результат выполнения данной программы выглядит так.
m() получил 199
Значение, возвращенное из m2(): 10
Значение, возвращенное из mЗ(): 99
Корень квадратный из iOb: 10.0
В объявлении метода m () указывается, что ему должен передаваться параметр типа
Integer. В методе main () целочисленное значение 199 передается методу m () в качестве
параметра. В итоге происходит автоупаковка этого целочисленного значения. Далее
в программе вызывается метод m2 (), возвращающий целочисленное значение 10. Это
значение присваивается переменной ссьmки на объект iOb в методе main (). А поскольку
объект iOb относится к типу Integer, то целочисленное значение, возвращаемое
методом m2 (), автоматически упаковывается. Затем в методе main () вызывается метод
mЗ (). Он возвращает объект типа Integer, который посредством автораспаковки преобразуется
в тип int. И наконец, в методе main () вызывается метод Math. sqrt (), которому
в качестве аргумента передается объект iOb. В данном случае происходит автораспаковка
данного объекта, а его значение продвигается к типу douЫe, поскольку параметр
именно этого типа должен быть передан методу Math. sqrt ().
Автоупаковка и автораспаковка в выражениях
Автоупаковка и автораспаковка выполняются всякий раз, когда требуется преобразовать
простой тип в объект, а объект - в простой тип. Так, автораспаковка производится
при вычислении выражений, и, если это требуется, результат вычисления упаковывается.
Рассмотрим в качестве примера приведенную ниже программу.
Глава 12. Перечисления. автоупаковка. статический импорт... 455
// Автоупаковка и автораспаковка в выражениях
class AutoBoxЗ {
puЫic static void main(String args[]) {
Integer iOb, iOb2;
int i;
iOb = 99;
System.out.println("Иcxoднoe значение iOb: " + iOb);
// В следующем выражении объект iOb автоматически
// распаковывается, производятся вычисления, а результат
// снова упаковывается в объект iOb.
++iOb; 􀁢---􀁣􀁣􀁣􀁤􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁣􀁥
System.out.println("Пocлe ++iOb: " + iОЬ);
// Здесь выполняется автораспаковка объекта iOb,
// к полученному значению прибавляется число 10,
// а результат снова упаковывается в объект iOb.
iOb += 10;
System.out.println("Пocлe iOb += 10: " + iOb);
// Выполняется автораспаковка объекта iOb, производятся
// вычисления, а результат снова упаковывается в объект iOb.
i0b2 = iOb + (iOb / 3);
Systern.out.
println("i0b2 после вычисления выражения: " + iOb2);
// Вычисляется то же самое выражение,
// но повторная упаковка не выполняется.
i = iOb + (iOb / 3);
Systern.out.println("i после вычисления выражения: " + i);
Выполнение этой программы дает следующий результат.
Исходное значение iOb: 99
После ++iOb: 100
После iOb += 10: 110
iOb2 после вычисления выражения: 146
i после вычисления выражения: 146
Обратите внимание на следующую строку кода программы:
++iOb;
Автоуnаковка и
-авторасnаковка
в вwражени11х
В ней значение объекта iOb должно быть увеличено на единицу. Происходит это следующим
образом: объект iOb распаковывается, полученное значение инкрементируется,
а результат снова упаковывается в объект iOb.
456 Java 8: руководство для начинающих. 6-е издание
Благодаря автораспаковке объектные оболочки целочисленных типов, например
Integer, можно использовать в операторах swi tch. В качестве примера рассмотрим
следующий фрагмент кода.
Integer iOb 2;
switch (iOb)
case 1: System.out.println("oдин");
break;
case 2: System.out.println("двa");
break;
default: System.out.println("oшибкa");
При вычислении выражения в операторе switch объект iOb распаковывается и последующей
обработке подвергается значение типа int, упакованное в этом объекте.
Как следует из приведенных выше примеров, выражения, в которых применяются
объектные оболочки простых типов, становятся интуитивно понятными благодаря автоупаковке
и автораспаковке. До появления версии JDK 5 для достижения аналогичного
результата в программе приходилось прибегать к приведению типов и вызовам специальных
методов вроде intValue ().
Предупреждение относительно использования
автоупаковки и автораспаковки
Поскольку автоупаковка и автораспаковка предельно упрощают обращение с оболочками
простых типов, может возникнуть соблазн всегда использовать вместо простых
типов только их оболочки, например Integer или DouЫe. Так, например, автоупаковка
и автораспаковка позволяют создавать код, подобный следующему.
// Неоправданное использование автоупаковки и автораспаковки
DouЫe а, Ь, с;
а = 10.2;
ь 11. 4;
с = 9.8;
DouЬle avg = (а + Ь + с) / 3;
В данном примере в объектах типа DouЫe хранятся три значения, используемые для
вычисления арифметического среднего, а полученный результат присваивается другому
объекту типа DouЫe. И хотя такой код формально считается корректным, а следовательно,
будет выполняться правильно, применение в нем автоупаковки и автораспаковки
ничем не оправданно. Ведь подобный код значительно менее эффективен, чем
аналогичный код, написанный только с использованием переменных типа douЫe.
С любой из операций распаковки и упаковки связаны издержки, отсутствующие при использовании
простых типов.
В целом оболочки типов следует использовать только тогда, когда объектное представление
простых типов действительно необходимо. Ведь автоупаковка и автораспаковка
добавлены в Java не для того, чтобы сделать ненужными простые типы.
Глава 12. Перечисления, автоупаковка, статический импорт... 457
Статический импорт
Java поддерживает расширенное использование ключевого слова import. Указав
после слова import ключевое слово static, можно импортировать статические члены
класса или интерфейса. Данная возможность обеспечивается механизмом статического
импорта. Статический импорт позволяет ссылаться на статические члены по их простым
именам, без дополнительного указания имен классов, что упрощает синтаксис.
Для того чтобы оценить по достоинству возможности статического импорта, начнем
с примера, в котором это средство не используется. Ниже проведен пример программы
для решения следующего квадратного уравнения:
ах2 + Ьх +с = О
В этой программе используются два статических метода - Ма t h . pow ( ) и Ма t h .
sqrt () - из класса Math, который, в свою очередь, входит в пакет java. lang. Первый
из методов возвращает значение, возведенное в заданную степень, а второй - квадратный
корень переданного значения.
// Нахождение корней квадратного уравнения
class Quadratic {
puЬlic static void main(String args[]) {
// а, Ь и с представляют коэффициенты
// квадратного уравнения ах2 + Ьх + с О
douЫe а, Ь, с, х;
// Решить квадратное уравнение 4х2 + х - 3 О
а = 4;
Ь 1;
с = -3;
// Найти первый корень
х = (-Ь + Math.sqrt(Math.pow(b, 2)
System.out.println("Пepвый корень:
// Найти второй корень
х = (-Ь - Math.sqrt(Math.pow(b, 2)
System.out.println("Bтopoй корень:
- 4 * а * с))
.. + х);
- 4 * а * с))
.. + х);
/ (2 * а);
/ (2 * а);
Методы pow () и sqrt () - статические, а следовательно, их нужно вызывать, ссылаясь
на имя класса Math. Их вызов осуществляется в следующем выражении, которое
ВЫГЛЯДИТ ДОВОЛЬНО громоздким:
х = (-Ь + Math.sqrt(Math.pow(b, 2) - 4 * а * с)) / (2 * а);
В выражениях подобного типа приходится постоянно следить за тем, чтобы перед
методами pow () и sqrt () (и другими подобными методами, например sin (), cos () и
tan ()) бьшо указано имя класса, что неудобно и чревато ошибками.
Утомительной обязанности указывать всякий раз имя класса перед статическим методом
позволяет избежать статический импорт. Его применение демонстрирует приведенная
ниже переработанная версия предьщущей программы.
458 Java 8: руководство для начинающих, 6-е издание
// Использование статического импорта для
// помещения методов sqrt() и pow() в область видимости
irnport static java.lang .Math.sqrt; 􀃫 Обесnеченне неnосредственногодостуnо
irnport static java.lang.Math.pow; ...г-кметодамsqrt() ироw() средствами
статическоrо импорта
class Quadratic
puЬlic static void rnain (String args []) {
// а, Ь и с представляют коэффициенты квадратного уравнения
// ах2 + Ьх + с = О
douЫe а, Ь, с, х;
!/ Решить квадратное уравнение 4х2 + х - 3 О
а 4;
Ь 1;
с = -3;
// Найти первый корень
х = (-Ь + sqrt(pow(b, 2) - 4 * а * с)) / (2 * а);
Systern.out.println("Пepвый корень: " + х);
!/ Найти второй корень
х = (-Ь - sqrt(pow(b, 2) - 4 * а * с))/ (2 * а);
Systern.out.println("Bтopoй корень: " + х);
В данной версии программы имена методов sqrt и pow уже не нужно указывать полностью
(т.е. вместе с именем их класса). И достигается это благодаря статическому импорту
обоих методов в приведенных ниже операторах, делающих оба метода непосредственно
доступными.
irnport static java.lang.Math.sqrt;
irnport static java.lang.Math.pow;
Добавление этих строк избавляет от необходимости предварять имена методов
sqrt () и pow () именем их класса. В итоге выражение для решения квадратного уравнения
принимает следующий вид:
х = (-Ь + sqrt(pow(b, 2) - 4 * а * с)) / (2 * а);
Теперь оно выглядит проще и воспринимается много легче.
В Java предусмотрены две общие формы оператора import static. В первой форме,
использованной в предыдущем примере, непосредственно доступным для программы
делается единственное имя. Ниже приведена эта общая форма статического импорта:
irnport static пакет.имя
_
типа.имя
_
статического
_
члена;
где имя
_
типа обозначает класс или интерфейс, содержащий требуемый статический
член, на который указывает имя
_
статического
_
члена. Вторая общая форма оператора
статического импорта выглядит следующим образом:
irnport static пакет.имя
_
типа. *;
Глава 12. Перечисления. автоупаковка. статический импорт ... 459
Если предполагается использовать несколько статических методов или полей, определенных
в классе, то данная общая форма записи позволяет импортировать все эти
члены одновременно. Таким образом, обеспечить непосредственный доступ к методам
pow () и sqrt () в предьщущей версии программы (а также к другим статическим членам
класса Math) без указания имени класса можно с помощью следующей единственной
строки кода:
import static java.lang.Math.*;
Очевидно, что статический импорт не ограничивается только классом Math и его
методами. Так, если требуется сделать непосредственно доступным статическое поле
System. out потока стандартного вывода, достаточно ввести в программу следующую
строку кода:
import static java.lang.System.out;
После этого данные можно выводить на консоль, не указывая перед статическим полем
out имя его класса System:
out.println("Импopтиpoвaв System.out,
имя out можно использовать непосредственно.");
Насколько целесообразно поступать именно так - вопрос спорный. С одной стороны,
размер исходного кода в этом случае сокращается. А с другой стороны, тем, кто
просматривает исходный код программы, может быть непонятно, что конкретно обозначает
имя out: поток стандартного вывода System.out или нечто иное.
Каким бы удобным ни был статический импорт, важно следить за тем, чтобы он
применялся корректно. Как известно, библиотеки классов Java организованы в пакеты
именно для того, чтобы исключить конфликты имен. Если импортируются статические
члены класса, то они переносятся в глобальное пространство имен. Вследствие этого
увеличивается вероятность конфликтов и непреднамеренного сокрытия имен. Если
статический член используется в программе один или два раза, то импортировать его
нет никакого смысла. Кроме того, некоторые имена статических членов (например,
System. out) настолько знакомы всем программирующим на Java, что они окажутся менее
узнаваемыми, если будут использоваться без имени своего класса. Статический импорт
был добавлен в Java в расчете на программы, в которых постоянно используются
определенные статические члены. Следовательно, к статическому импорту следует прибегать
осмотрительно, не злоупотребляя им.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Допускается ли статический импорт статических членов самостоятельно
создаваемых классов?
ОТВЕТ. Допускается. Это средство можно применять для импорта статических
членов любых создаваемых вами классов и интерфейсов. Им особенно удобно
пользоваться в тех случаях, когда в классе определено несколько статических
членов, часто употребляемых в большой программе. Так, если в классе определен
ряд констант, обозначающих граничные значения, то статический импорт
позволит избежать излишнего упоминания их классов.
460 Java 8: руководство для начинающих. 6-е издание
Аннотации (метаданные)
Java предоставляет возможность внедрять в исходный файл дополнительную информацию
в виде аннотаций, не изменяя поведения программы. Эта информация может
быть использована различными инструментальными средствами как на этапе разработки,
так и в процессе развертывания программы. В частности, аннотации могут обрабатываться
генератором исходного кода, компилятором и средствами развертывания
прикладных программ. Дополнительные сведения, включаемые в исходный файл, также
называют метаданными, но термин аннотация представляется более описательным и
чаще используется.
Полное рассмотрение аннотаций выходит за рамки книги. Для подробного их рассмотрения
здесь просто недостаточно места. Поэтому ограничимся лишь кратким описанием
самого понятия и назначения аннотаций.
НА ЗАМЕТКУ
Подробнее о метаданных и аннотациях можно прочитать в книге Java 8. Полное руководство,
9-е издание (ИД "Вильяме", 2015 г.).
Аннотации создаются посредством механизма, основанного на интерфейсах. Ниже
приведен простой пример аннотации.
// Простой пример аннотации
@interface MyAnno
String str();
int val();
В данном примере объявляется аннотация MyAnno. Обратите внимание на то, что
ключевое слово interface предваряется знаком@. Тем самым компилятору сообщается
об объявлении аннотации. Обратите внимание на два члена: str () и val (). Все аннотации
содержат лишь объявления методов без определения их тел. Объявленные методы
реализует исполняющая система Java, причем они действуют во многом подобно полям.
Аннотации всех типов автоматически расширяют интерфейс Annotation. Следовательно,
интерфейс Annotation используется в качестве суперинтерфейса для всех аннотаций.
Он входит в пакет java. lang. annotation.
Первоначально аннотации использовались только для аннотирования объявлений.
При этом аннотацию можно связать с любым объявлением. В частности, аннотированными
могут быть объявления классов, методов, полей, параметров, констант перечислимого
типа и даже самих аннотаций. Но в любом случае аннотация предшествует
остальной части объявления. Начиная с версии JDK 8 можно аннотировать также использование
типов, например использование приводимого или возвращаемого методом
типа.
Вводя аннотацию, вы задаете значения ее членов. Ниже приведен пример применения
аннотации MyAnno к методу.
// Аннотирование метода
@MyAnno(str = "Пример аннотации", val 100)
puЫic static void myMeth () { / / ...
Глава 12. Перечисления. автоупаковка. статический импорт ... 461
Данная аннотация связывается с методом rnyMeth (). Обратите внимание на синтаксис.
Имени аннотации предшествует знак @, а после имени следует заключенный в скобки
список инициализируемых членов. Для того чтобы задать значение члена аннотации,
следует присвоить это значение имени данного члена. В рассматриваемом здесь примере
строка "Пример аннотации" присваивается члену str аннотации MyAnno. Обратите внимание
на отсутствие скобок после идентификатора str в этом присвоении. При присваивании
значения члену аннотации используется только ero имя. В этом отношении
члены аннотации похожи на поля.
Аннотация без параметров называется маркерной аннотацией. При определении маркерной
аннотации круглые скобки не указываются. Главное ее назначение - пометить
объявление некоторым атрибутом.
В Java определено множество встроенных аннотаций. Большинство из них являются
специализированными, но есть девять аннотаций общего назначения. Четыре из
них входят в пакет j ava. lang. annotation - это аннотации @Retention, @Docurnented,
@Target и @Inherited. Пять аннотаций - @Override, @Deprecated, @SafeVarargs,
@Functionalinterface и @SuppressWarnings - включены в пакет java. lang. Все эти
аннотации приведены в табл. 12.l.
Таблица 12.1. Встроенные аннотации
Аннотация
@Retention
@Documented
@Target
@Inherited
@Override
@Deprecated
@SafeVarargs
Описание
Определяет стратегию управления жизненным циклом аннотации. Это
стратегия определяет, будет ли видно аннотация в исходном коде, скомпилированном
файле и в процессе выполнения
Маркерная аннотация, сообщающая инструментальному средству о том,
что аннотация должно документироваться. Эту аннотацию следует использовать
только для аннотирования объявления другой аннотации
Задает виды объявлений, к которым может применяться аннотация. Донная
аннотация предназначено только для использования в отношении другой
аннотации. Оно принимает аргумент в виде константы или массива констант
перечислимого типа ElementType, таких кок CONSTROCTOR, FIELD
и METHOD. Аргумент определяет виды объявлений, к которым может быть
применено аннотация. Отсутствие аннотации @Target указывает но то,
что донная аннотация может применяться к любому объявлению
Маркерная аннотация, указывающая но то, что аннотация суперклассо
должно наследоваться подклассом
Метод, аннотированный кок @Override, должен переопределять метод
суперклоссо. Если это условие не выполняется, возникает ошибка времени
компиляции. Донная аннотация представляет собой маркер и позволяет
убедиться в том, что метод суперклоссо действительно переопределен, о
не перегружен
Маркерная аннотация, указывающая но то, что объявление устарело и
было заменено новым
Маркерная аннотация, которая указывает но то, что в методе или конструкторе
не выполняются действия, небезопасные с точки зрения использования
переменного количество аргументов. Может применяться только к
статическим или финальным методом и конструктором
462 Java 8: руководство для начинающих. 6-е издание
Аннотация Описание
Окончание табл. 12.1
@Functional!nterface Маркерная аннотация, испопьзуемоя для аннотирования объявлений интерфейсов.
Оно указывает но то, что аннотируемый ею интерфейс является
функцнонольным ннтерфейсом, который содержит один и только один абстрактный
метод. Функциональные ннтерфейсы используются в лямбда-выражениях.
(Функциональные интерфейсы подробно рассматриваются в
гл. 14.} Важно поннмать, что аннотация @Functionallnterface играет
исключнтельно информационную роль. Любой интерфейс, имеющий ровно
один абстрактный метод, по определению является функциональным интерфейсом
@SuppressWarnings Указывает но то, что одно или более предупреждающих сообщений, которые
могут быть сгенерированы в процессе компиляции, должны подавляться.
Подавляемые предупреждающие сообщения задаются именами, представляемыми
в виде строк
ПРИМЕЧАНИЕ
Кроме аннотаций, входящих в пакет java. lang. annotation, в JDK 8 определены аннотации
@RepeataЫe и @Native. Аннотация @RepeataЫe обеспечивает поддержку повторяющихся
аннотаций, для которых возможно более чем однократное применение к одному и тому же элементу.
Аннотация @Native используется для аннотирования постоянного поля, к которому имеет
доступ исполняемый {т.е. собственный машинный) код. Обе аннотации имеют специфическую
сферу применения, и их рассмотрение выходит за рамки книги.
Ниже приведен пример, в котором аннотацией @Deprecated помечены класс
MyClass и метод getMsg (). При попытке скомпилировать программу будет выведено
сообщение о том, что в исходном коде содержатся устаревшие и не рекомендованные к
применению элементы.
// Пример использования аннотации @Deprecated
// Пометить класс
@Deprecated
как не рекомендованный к применению
----- Помечает кnосс кок устаревший
class MyClass {
private String rnsg;
MyClass(String rn) {
rnsg = rn;
// Пометить метод
@Deprecated
String getMsg ()
return rnsg;
//
как не рекомендованный к применению
Помечает метод кок устаревший
Глава 12. Перечисления. автоупаковка. статический импорт ... 463
class AnnoDemo {
puЫic static void main(String args[])
MyClass myObj = new MyClass("тecт");
System.out.println(myObj.getMsg());
'.\·􀀃,:,;· Вопросы и упражнения для самопроверк111
1. Константы перечислимого типа иногда называют самотипизированными. Что это
означает?
2. Какой класс автоматически наследуют перечисления?
3. Напишите для приведенного ниже перечисления программу, в которой метод
values () используется для отображения списка констант и их значений.
enum Tools {
SCREWDRIVER, WRENCH, НАММЕR, PLIERS
4. Созданную в упражнении 12.1 программу, имитирующую автоматизированный
светофор, можно усовершенствовать, внеся ряд простых изменений, позволяющих
выгодно воспользоваться возможностями перечислений. В исходной версии
этой программы продолжительность отображения каждого цвета светофора регулировалась
в классе TrafficLightSirnulator, причем значения задержек были
жестко запрограммированы в методе run () . Измените исходный код программы
таким образом, чтобы продолжительность отображения каждого цвета светофора
задавалась константами перечислимого типа TrafficLightColor. Для этого вам
понадобятся конструктор, переменная экземпляра, объявленная как private, и
метод getDelay (). Подумайте о том, как еще можно улучшить данную программу.
(Подсказка: попробуйте отказаться от оператора switch и воспользоваться порядковыми
значениями каждого цвета для переключения светофора.)
5. Что такое упаковка и распаковка? В каких случаях выполняется автоупаковка и
автораспаковка?
6. Измените следующий фрагмент кода таким образом, чтобы в нем выполнялась
автоупаковка:
Short val = new Short(123);
7. Объясните, что такое статический импорт?
8. Какие действия выполняет приведенный ниже оператор?
import static java.lang.Integer.parseint;
9. Следует ли использовать статический импорт применительно к конкретным ситу-
ациям или желательно импортировать статические члены всех классов?
10. Синтаксис аннотации основывается на ________
11. Какая аннотация называется маркерной?
12. Справедливо ли следующее утверждение: "Аннотации применимы только к методам"?

Глава 13
Обобщения
466 Java 8: руководство дпя начинающих, 6-е издание
В этой главе ...
􀂖 Преимущества обобщений
􀂗 Создание обобщенного класса
off, Ограниченные параметры типов
􀂘 lllаблоны арrументов
et• Применение ограниченных шаблонов
1l'i Создание обобщенного метода
􀂙 Создание обобщенного конструктора
􀂚 Создание обобщенного интерфейса
􀂛 Использование базовых типов
,ъ Выведение типов
.r1 Очистка
qi Исключение ошибок неоднозначности
􀂜,. Ограничения обобщений
п осле выхода первоначальной версии 1.0 в язык Java было добавлено множество
новых средств. Каждое нововведение расширяло возможности языка и сферу его
применения, однако одно из них имело особенно глубокие и далеко идущие последствия.
Речь идет об обобщениях - абсолютно новой синтаксической конструкции, введение
которой повлекло за собой существенные изменения во многих классах и методах
ядра API. Не будет преувеличением сказать, что обобщения коренным образом изменили
сам язык Java.
Обобщения - слишком обширная тема, чтобы ее можно было полностью обсудить
в рамках данной книги, однако понимание базовых возможностей этого средства необходимо
каждому, кто программирует на Java. Поначалу синтаксис обобщений может показаться
вам удручающе сложным, но пусть вас это не смущает. На самом деле обобщения
на удивление просты в использовании. К тому моменту, когда вы завершите чтение
главы, вы не только усвоите все ключевые понятия, но и научитесь успешно применять
обобщения в своих программах.
Основные сведения об обобщениях
Термин обобщение по сути означает параметризированный тип. Специфика параметризированных
типов состоит в том, что они позволяют создавать классы, интерфейсы
и методы, в которых тип данных указывается в виде параметра. Используя обобщения,
можно создать единственный класс, который будет автоматически работать с различными
типами данных. Классы, интерфейсы и методы, оперирующие параметризированными
типами, называются обобщенными, как, например, обобщенный класс или обобщенный
метод.
Глава 13. Обобщения 467
Главное преимущество обобщенного кода состоит в том, что он будет автоматически
работать с типом данных, переданным ему в качестве параметра. Многие алгоритмы выполняются
одинаково, независимо от того, к данным какого типа они будут применяться.
Например, быстрая сортировка не зависит от типа данных, будь то Integer, String,
Obj ect или Thread. Используя обобщения, можно реализовать алгоритм один раз, а затем
применять его без дополнительных усилий к любому типу данных.
Следует особо подчеркнуть, что в Java всегда была возможность создавать обобщенный
код, оперирующий ссылками типа Obj ect. А поскольку класс Obj ect выступает
в качестве суперкласса по отношению ко всем остальным классам, то ссылки на тип
Obj ect позволяют обращаться к объекту любого типа. Таким образом, еще до появления
обобщений можно было оперировать разнотипными объектами посредством одной
переменной с помощью ссьuюк на тип Obj ect. Проблема состояла в том, что такой
подход, требующий явного преобразования типа Obj ect в конкретный тип посредством
приведений, не обеспечивал безопасность типов. Это служило потенциальным источником
ошибок из-за того, что приведение типов могло быть неумышленно выполнено
неверно. Обобщения привносят безопасность типов, которой раньше так недоставало,
поскольку в этом случае автоматически выполняются неявные приведения. Таким образом,
обобщения расширяют возможности повторного использования кода, делая этот
процесс безопасным и надежным.
СПРОСИМ У ЭКСПЕРТ А
ВОПРОС. Говорят, что обобщения в Java аналогичны шаблонам в С++. Так ли это?
ОТВЕТ. Действительно, обобщения в Java похожи на шаблоны в С++. То, что в Java
называют параметризованными типами, в С++ называют шаблонами. Однако
эти понятия не являются эквивалентными. Между ними имеется ряд принципиальных
различий, а в целом обобщения в Java намного более просты в применении.
Тем, у кого имеется опыт программирования на С++, важно помнить, что навыки
применения шаблонов нельзя механически переносить на обобщения в
Java. У этих языковых средств имеются отличия, которые слабо проявляются
внешне, но довольно значительны по сути.
Простой пример обобщений
Прежде чем приступить к более подробному обсуждению обобщений, полезно рассмотреть
простой пример их применения. Ниже приведен исходный код программы,
в которой объявлены два класса: обобщенный класс Gen и использующий его класс
GenDemo.
// Простой обобщенный класс.
// Здесь Т - это параметр типа, вместо которого
// при создании объекта класса Gen будет подставляться
// реально существующий тип.
468 Java 8: руководство для начинающих, 6-е издание
class Gen<T> { --------- В о61ояаnении этоrо масса Т означает обобщенный тип
Т оЬ; // объявить объект типа Т
// Передать конструктору ссылку на объект типа Т
Gen (Т о) {
оЬ = о;
// Вернуть объект оЬ из метода
т getob () {
return оЬ;
// Отобразить тип Т
void showType() {
System.out.println("Tип Т - это " +
ob.getClass() .getName());
// Демонстрация использования обобщенного класса
class GenDemo {
puЫic static void main(String args[]) {
// Создать ссылку на объект типа Gen<Integer>
Gen<Integer> iOb; Соэдание ссыпки на о6ьекттипа Gen<Integer>
// Создать объект типа Gen<Integer> и присвоить ссылку на
// него переменной iOb. Обратите внимание на автоупаковку при
// инкапсуляции значения 88 в объекте типа Integer.
iOb = new Gen<Integer> ( 88) ; Соэдание экэемпnяра типа Gen<Integer>
// Отобразить тип данных, используемых в объекте iOb
iOb.showType();
// Получить значения из объекта iOb. Обратите внимание
//на то, что приведение типов здесь не требуется.
int v = iOb.getob();
System.out.println("знaчeниe: " + v);
System.out.println();
// Создать объект типа Gen для строк
Gen<String> strOb = new Gen<String>("Tecтиpoвaниe
// Отобразить тип данных, используемых в объекте strOb
strOb.showType();
// Получить значение из объекта strOb.
// Заметьте, что приведение типов эдесь также не требуется.
String str = strOb.getob();
System.out.println("знaчeниe: " + str);
Глава 13. Обобщения 469
Выполнение данной программы дает следующий результат.
Тип Т - это java.lang.Integer
значение: 88
Тип Т - это java.lang.String
значение: Тестирование обобщений
Рассмотрим исходный код программы более подробно. Прежде всего обратите внимание
на способ объявления класса Gen. Для этого используется следующая строка кода:
class Gen<T> {
где т - имя параметра типа. Это имя - заполнитель, подлежащий замене фактическим
типом, передаваемым конструктору Gen () при создании объекта. Следовательно, имя т
используется в классе Gen всякий раз, когда возникает необходимость в использовании
параметра типа. Обратите внимание на то, что имя т заключено в угловые скобки ( < > ).
Этот синтаксис является общим: всякий раз, когда объявляется параметр типа, он указывается
в угловых скобках. Поскольку класс Gen использует параметр типа, он является
обобщенным классом.
В объявлении класса Gen имя для параметра типа могло быть выбрано совершенно
произвольно, но по традиции выбирается имя т. Вообще говоря, для этого рекомендуется
выбирать имя, состоящее из одной прописной буквы. Другими распространенными
именами параметров типа являются v и Е.
Далее в программе имя т используется при объявлении объекта оЬ:
Т оЬ; // объявить объект типа Т
Как уже отмечалось, имя параметра типа т служит заполнителем, вместо которого
при создании объекта класса Gen указывается конкретный тип. Поэтому объект оЬ будет
иметь тип, передаваемый в виде параметра т при получении экземпляра объекта класса
Gen. Так, если в качестве параметра типа т указывается String, то объект оЬ будет иметь
тип String.
Рассмотрим конструктор класса Gen.
Gen(T о) {
оЬ = о;
Отсюда следует, что параметр о конструктора имеет тип т. Это означает, что конкретный
тип параметра о определяется типом, передаваемым в виде параметра т при создании
объекта класса Gen. А поскольку параметр о и переменная экземпляра оЬ относятся
к типу т, то после создания объекта класса Gen их конкретный тип окажется одним и
тем же.
Кроме того, параметр типа т можно указывать в качестве типа значения, возвращаемого
методом.
Т getob () {
return оЬ;
Переменная экземпляра оЬ также относится к типу т, поэтому ее тип совпадает с
типом значения, возвращаемого методом getob ().
470 Java 8: руководство для начинающих. 6-е издание
Метод showType () отображает тип т. Это делается путем вызова метода getName ()
для объекта типа Class, возвращаемого вызовом метода getClass () для объекта оЬ.
Поскольку до этого мы еще ни разу не использовали такую возможность, рассмотрим
ее более подробно. Как объяснялось в главе 7, в классе Obj ect определен метод
getClass (). Следовательно, этот метод является членом класса любого типа. Он возвращает
объект типа Class, соответствующий классу объекта, для которого он вызван.
Класс Class, определенный в пакете java. lang, инкапсулирует информацию о текущем
классе. Он имеет несколько методов, которые позволяют получать информацию о
классах во время выполнения. К их числу принадлежит метод getName () , возвращающий
строковое представление имени класса.
В классе GenDemo демонстрируется использование обобщенного класса Gen. Прежде
всего, в нем создается версия класса Gen для целых чисел:
Gen<Integer> iOb;
Внимательно проанализируем это объявление. Заметьте, что в угловых скобках после
имени класса Gen указан тип Integer. В данном случае Integer - это аргумент
типа, передаваемый параметру т класса Gen. В конечном счете мы получаем класс Gen,
в котором везде, где был указан тип т, теперь фигурирует тип Integer. Следовательно,
после такого объявления типом переменной оЬ и возвращаемым типом метода getob ()
становится тип Integer.
Прежде чем мы начнем продвигаться дальше, важно подчеркнуть, что на самом деле
никакие разные версии класса Gen (как и вообще любого друтоrо класса) компилятором
Java не создаются. В действительности компилятор просто удаляет всю информацию об
обобщенном типе, выполняя все необходимые приведения типов и тем самым заставляя
код вести себя так, словно была создана специфическая версия класса Gen, хотя в действительности
в программе существует только одна версия Gen - обобщенная. Процесс
удаления информации об обобщенном типе называется очистка, и к этой теме мы еще
вернемся в данной главе.
В следующей строке кода переменной iOb присваивается ссьmка на экземпляр, соответствующий
версии класса Gen для типа Integer:
iOb = new Gen<Integer>(88);
Обратите внимание на то, что при вызове конструктора класса Gen указывается также
аргумент типа Integer. Это необходимо потому, что тип объекта, на который указывает
ссылка (в данном случае - iOb), должен соответствовать Gen<Integer>. Если
тип ссылки, возвращаемой оператором new, будет отличаться от Gen<Integer>, то компилятор
сообщит об ошибке. Например, это произойдет при попытке скомпилировать
следующую строку кода:
iOb = new Gen<DouЫe>(88.0); // Ошибка!
Переменная iOb относится к типу Gen<Integer>, а следовательно, она не может
быть использована для хранения ссьmки на объект типа Gen<DouЫe>. Этот вид проверки
- одно из основных преимуществ обобщенных типов, поскольку они обеспечивают
типовую безопасность.
Как следует из комментариев к программе, в рассматриваемом здесь операторе присваивания
осуществляется автоупаковка целочисленного значения 88 в объект типа
Integer:
iOb = new Gen<Integer>(88);
Глава 13. Обобщения 471
Это происходит потому, что обобщение Gen<Integer> создает конструктор, которому
передается аргумент типа Integer. А поскольку предполагается создание объекта
типа Integer, то в нем автоматически упаковывается целочисленное значение 88. Разумеется,
все это можно было бы явно указать в операторе присваивания, как показано
ниже.
iOb = new Gen<Integer>(new Integer(88));
Однако получаемая в этом случае длинная строка кода не дает никаких преимуществ
по сравнению с предыдущей, более компактной записью.
Затем программа отображает тип переменной оЬ, инкапсулированной в объекте iOb
(в данном случае это тип Integer). Значение переменной оЬ получается в следующей
строке кода:
int v = iOb.getob();
Метод getob () возвращает значение типа т, замененное на Integer при объявлении
переменной, ссылающейся на объект iOb, а следовательно, метод getob () фактически
возвращает значение того же самого типа Integer. Это значение автоматически распаковывается,
прежде чем оно будет присвоено переменной v типа int.
И наконец, в классе GenDemo объявляется объект типа Gen<String>.
Gen<String> strOb = new Gen<String>("Generics Test");
Поскольку аргументом типа является String, этот класс заменит параметр т во всем
коде класса Gen. В результате этого создается (концептуально) строковая версия класса
Gen, что и демонстрируют остальные строки кода программы.
Обобщения работают только с объектами
Когда объявляется экземпляр обобщенного типа, аргумент, передаваемый параметру
типа, должен быть типом класса. Использовать для этой цели простые типы, например
int или char, нельзя. Например, классу Gen можно передать через параметр т любой
тип класса, но передача любого простого типа недопустима. Иными словами, следующее
объявление приведет к ошибке во время компиляции:
Gen<int> strOb = new Gen<int>(53); // Ошибка, нельзя использовать
// простой тип
Очевидно, что невозможность подобной передачи простых типов не является серьезным
ограничением, поскольку всегда имеется возможность использовать объектные
оболочки для инкапсуляции значений (как это сделано в предыдущем примере). Кроме
того, механизм автоупаковки и автораспаковки Java делает использование оболочек
прозрачным.
Различение обобщений по аргументам типа
Ключом к пониманию обобщений является тот факт, что ссылки на разные специфические
версии одного и того же обобщенного типа несовместимы между собой. Так,
наличие в предыдущем примере следующей строки кода привело бы к ошибке во время
компиляции:
iOb = strOb; // Ошибка!
472 Java 8: руководство для начинающих, 6-е издание
Несмотря на то что обе переменные, iOb и strOb, относятся к типу Gen<T>, они ссылаются
на объекты разного типа, поскольку в их объявлениях указаны разные арrументы
типа. Это и есть частный пример той безопасности типов, которая обеспечивается использованием
обобщенных типов, способствующим предотвращению возможных ошибок.
Обобщенный класс с двумя параметрами типа
Обобщенные типы допускают объявление нескольких параметров типа. Параметры
задаются в виде списка элементов, разделенных запятыми. В качестве примера ниже
приведена переработанная версия класса TwoGen, в которой определены два параметра
типа.
// Простой обобщенный класс с двумя параметрами типа: Т и V
class TwoGen<T, V> ( Исnоn1>зованне двух параметров тнnа
Т оЫ;
V оЬ2;
// Передать конструктору класса ссылки на объекты типов Т и V
TwoGen(T ol, V о2) (.
оЫ ol;
оЬ2 = о2;
!/ Отобразить типы Т и V
void showTypes() {
System.out.println("Tип Т - это " +
oЫ.getClass() .getName());
System.out.println("Tип V - это " +
ob2.getClass() .getName());
Т getoЫ () {
return оЫ;
V getob2 () {
return оЬ2;
// Демонстрация класса TwoGen
class SimpGen {
puЬlic static void main(String args[]) { Пе редочатнnаintеgеrnарометруТ
TwoGen<Integer, String> tgObj = .....о-- ---н тнпа String параметру V
new TwoGen<Integer, String>(88, "Обобщения");
!/ Отобразить типы
tgObj.showTypes();
// Получить и отобразить значения
int v = tgObj.getoЫ();
System.out.println("знaчeниe: " + v);
String str = tg0bj.getob2();
System.out.println("знaчeниe: " + str);
Глава 13. Обобщения 473
Выполнение этой программы дает следующий результат.
Тип Т - это java.lang.Integer
Тип V - это java.lang.String
значение: 88
значение: Обобщения
Обратите внимание на приведенное ниже объявление класса TwoGen.
class TwoGen<T, V> {
В нем определены два параметра типа, т и v, разделенные запятыми. А поскольку в
этом классе используются два параметра типа, то при создании объекта на ero основе
следует указывать оба аргумента типа, как показано ниже.
TwoGen<Integer, String> tgObj =
new TwoGen<Integer, String>(88, "Обобщения");
В данном случае тип Integer передается в качестве параметра типа Т, а тип String -
в качестве параметра типа v. И хотя в этом примере типы аргументов отличаются, они
могут и совпадать. Например, следующая строка кода вполне допустима:
TwoGen<String, String> х = new TwoGen<String, String>("A", "В");
В данном случае в качестве обоих параметров типа т и v передается один и тот же
тип String. Очевидно, что если типы аргументов совпадают, то определять два параметра
типа в обобщенном классе нет никакой надобности.
Общая форма обобщенного класса
Синтаксис, представленный в предыдущих примерах, можно обобщить. Ниже приведена
общая форма объявления обобщенного класса.
class имя
_
класса<список
_
параметров
_
типа> { // ...
А вот как выглядит синтаксис объявления ссьmки на обобщенный класс.
имя
_
класса<список
_
аргументов
_
типа> имя
_
переменной
new имя
_
класса<список
_
аргументов
_
типа>
(список
_
аргументов
_
конструктора) ;
Ограниченные типы
В предыдущих примерах параметры типа могли заменяться любым типом класса.
Такая подстановка годится для многих целей, но иногда полезно ограничить допустимый
ряд типов, передаваемых в качестве параметра типа. Допустим, требуется создать
обобщенный класс для хранения числовых значений и выполнения над ними различных
математических операций, включая получение обратной величины или извлечение
дробной части. Допустим также, что в этом классе предполагается выполнение математических
операций над данными любых числовых типов: как целочисленных, так
47 4 Java 8: руководство для начинающих. 6-е издание
и с плавающей точкой. В таком случае будет вполне логично указывать числовой тип
данных обобщенно, т.е. с помощью параметра типа. Для создания такого класса можно
было бы написать примерно такой код.
// Класс NumericFns как пример неудачной попытки создать
// обобщенный класс для выполнения различных математических
// операций, включая получение обратной величины или
// извлечение дробной части числовых значений любого типа.
class NumericFns<T> {
Т num;
// Передать конструктору ссылку на числовой объект
NumericFns(T n) {
num = n;
// Вернуть обратную величину
douЫe reciprocal () {
return 1 / num.douЬleValue(); // Ошибка!
// Вернуть дробную часть
douЫe fraction () {
return num.douЬleValue() - num.intValue(); // Ошибка!
//
К сожалению, класс NumericFns в том виде, в каком он приведен выше, не компилируется,
так как оба метода, определенные в этом классе, содержат программную
ошибку. Рассмотрим сначала метод reciprocal (), который пытается возвратить величину,
обратную его параметру num. Для этого нужно разделить l на значение переменной
num, которое определяется при вызове метода douЫeValue (), возвращающего
версию douЫe числового объекта, хранящегося в переменной num. Как известно, все
числовые классы, в том числе Integer и DouЬle, являются подклассами, производными
от класса NumЬer, в котором определен метод douЫeValue (), что делает его доступным
для всех классов оболочек числовых типов. Но компилятору неизвестно, что объекты
класса NumericFns предполагается создавать только для числовых типов данных. Поэтому
при попытке скомпилировать класс NumericFns возникает ошибка, а соответствующее
сообщение уведомит вас о том, что метод douЬleValue () неизвестен. Аналогичная
ошибка возникает дважды при компиляции метода fraction (), где вызываются методы
douЬleValue () и intValue (). Вызов любого из этих методов также будет сопровождаться
сообщением компилятора о том, что они неизвестны. Чтобы разрешить данную
проблему, нужно каким-то образом сообщить компилятору, что в качестве параметра
типа т предполагается использовать только числовые типы. И нужно еще убедиться, что
в действительности передаются только эти типы данных.
Для подобных случаев в Java предусмотрены ограниченные типы. При указании параметра
типа можно задать верхнюю границу, объявив суперкласс, который должны наследовать
все аргументы типа. Это делается с помощью ключевого слова extends:
<Т extends суперкласс>
Глава 1 3. Обобщения 475
Это объявление сообщает компилятору о том, что параметр типа т может быть заменен
только суперклассом или его подклассами. Таким образом, суперкласс определяет
верхнюю границу в иерархии классов Java.
С помощью ограниченных типов можно устранить программные ошибки в классе
NumericFns. Дтlя этого следует указать верхнюю границу, как показано ниже.
// В этой версии класса NumericFns аргументом типа,
// заменяющим параметр типа Т, должен стать класс NurnЬer
// или производный от него подкласс, как показано ниже.
class NumericFns<T extends NumЬer> { Вдонн ом сnуч ое орrументомтиnодо nжен
Т num; бwт􀀢 nибо numЬer, nибо nодкпосс NumЬer
// Передать конструктору ссылку на числовой объект
NumericFns(T n) {
num = n;
// Вернуть обратную величину
douЫe reciprocal() {
return 1 / num.douЫeValue();
// Вернуть дробную часть
douЫe fraction() {
return num.douЬleValue() - num.intValue();
//
// Демонстрация класса NumericFns
class BoundsDemo {
puЫic static void main(String args[J)
NumericFns<Integer> iOb 4------------Доnустимо, потому что Integer
new NumericFns<Integer>(S);
System.out.println("Oбpaтнaя величина iOb - " +
iOb.reciprocal());
System.out.println("Дpoбнaя часть iOb - " +
iOb.fraction());
System.out.println();
// Применение класса DouЫe таюке допустимо.
явnяется nодкпоссом NumЬer
NumericFns<DouЫe> dOb 4----------Тиn DouЫe также допустим
new NumericFns<DouЫe>(S.25);
System.out.println("Oбpaтнaя величина dOb - " +
dOb.reciprocal());
System.out.println("Дpoбнaя часть dOb - " +
dOb.fraction());
476 Java 8: руководство для начинающих. 6-е издание
/! Следующая строка кода не будет компилироваться, так как
// класс String не является производным от класса NurnЬer.
// NumericFns<String> strOb = new NumericFns<String>("Oшибкa")
}
Ниже приведен результат выполнения данной программы.
Обратная величина iOb is 0.2
Дробная часть iOb is О.О
Обратная величина dOb - О.19047619047619047
Дробная часть dOb - 0.25
Тип String иедопусrим,
ток как он не яапяется
подкпоссом NumЬer
Как видите, для объявления класса NumericFns в данном примере используется следующая
строка кода:
class NumericFns<T extends NurnЬer> {
Теперь тип т ограничен классом NumЬer, а следовательно, компилятору Java известно,
что для всех объектов типа т доступен метод douЫeValue (), а также другие методы,
определенные в классе NumЬer. Это не только уже само по себе дает немалые преимущества,
но и предотвращает создание объектов класса NumericFns для нечисловых типов.
Если вы удалите комментарии из строки кода в конце программы и попытаетесь скомпилировать
ее, то компилятор выведет сообщение об ошибке, поскольку класс String
не является подклассом, производным от класса NumЬer.
Ограниченные типы особенно полезны в тех случаях, когда нужно обеспечить совместимость
одного параметра типа с другим. Рассмотрим в качестве примера представленный
ниже класс Pair. В нем хранятся два объекта, которые должны быть совместимы
друг с другом.
class Pair<T, V extends Т> {
Т first;
V second;
Pair (Т а, V Ь)
first = а;
second = Ь;
//
------------Тип V допжеи совпадать с типом Т
ипи быть ero подкпассом
В классе Pair определены два параметра типа, т и v, причем тип v расширяет тип т.
Это означает, что тип v должен быть либо того же типа, что и т, либо его подклассом.
Благодаря такому объявлению гарантируется, что два параметра типа, передаваемые
конструктору класса Pair, будут совместимы друг с другом. Например, приведенные
ниже строки кода корректны.
// Эта строка кода верна, поскольку Т и V имеют тип Integer
Pair<Integer, Integer> х = new Pair<Integer, Integer>(l, 2);
// И эта строка кода верна, так как Integer - подкласс NurnЬer
Pair<NumЬer, Integer> у= new Pair<Number, Integer>(l0.4, 12);
А следующий фрагмент кода содержит ошибку.
Глава 13. Обобщения 4П
// Эта строка кода недопустима, так как String не является
// подклассом NumЬer
Pair<NumЬer, String> z = new Pair<Number, String>(l0.4, "12");
В данном случае класс String не является производным от класса NumЬer, что нарушает
условие, указанное в объявлении класса Pair.
Использование шаблонов аргументов
Безопасность типов - вещь полезная, но иногда она может мешать созданию идеальных
во всех других отношениях конструкций. Допустим, требуется реализовать метод
absEqual (), возвращающий значение true в том случае, если два объекта уже упоминавшегося
класса NumericFns содержат одинаковые абсолютные значения. Допустим
также, что этот метод должен оперировать любыми типами числовых данных, которые
могут храниться в сравниваемых объектах. Так, если один объект содержит значение
l. 25 типа DouЫe, а другой - значение -1. 25 типа Float, то метод absEqual () должен
возвращать логическое значение true. Один из способов реализации метода absEqual ()
состоит в том, чтобы передавать этому методу параметр типа NumericFns, а затем сравнивать
его абсолютное значение с абсолютным значением текущего объекта и возвращать
значение true, если эти значения совпадают. Например, вызов метода absEqual ()
может выглядеть следующим образом.
NumericFns<DouЫe> dOb = new NumericFns<DouЫe>(l.25);
NumericFns<Float> fOb = new NumericFns<Float>(-1.25);
if(dOb.absEqual(fOb))
System.out.println("Aбcoлютныe значения совпадают");
else
System.out.println("Aбcoлютныe значения отличаются");
На первый взгляд может показаться, что при выполнении метода absEqual () не
должно возникнуть никаких затруднений, но это совсем не так. Проблемы начнутся при
первой же попытке объявить параметр типа NumericFns. Каким он должен быть? Казалось
бы, подходящим должно быть следующее решение, где т указывается в качестве
параметра типа.
// Это не будет работать!
boolean absEqual(NumericFns<T> оЬ) {
if(Math.abs(num.douЫeValue()) ==
-4----- Проверить равенство абсояютных
значений двух объектов
Math.abs(ob.num.douЫeValue()) return true;
return false;
В данном случае для определения абсолютного значения каждого числа используется
стандартный метод Math. abs (). Далее выполняется сравнение полученных значений.
Проблема состоит в том, что приведенное выше решение будет работать только
тогда, когда объект класса NumericFns, передаваемый в качестве параметра, имеет
тот же тип, что и текущий объект. Например, если текущий объект относится к типу
NumericFns<Integer>, то параметр оЬ также должен быть типа NumericFns<Integer>,
а следовательно, сравнить текущий объект с объектом типа NumericFns<DouЬle> не
удастся. Таким образом, выбранное решение не является обобщенным.
478 Java 8: руководство для начинающих. 6-е издание
Для того чтобы создать обобщенный метод absEqual () , следует использовать еще
одно средство обобщений - шаблон аргумента. Шаблон обозначается метасимволом ? ,
которому соответствует неизвестный тип данных. Используя этот метасимвол, можно
переписать метод absEqual () в следующем виде.
// Проверить равенство абсолютных значений двух объектов
boolean absEqual(NumericFns<?> оЬ) { // обратите внимание на
// метасимвол
if(Math.abs(num.douЬleValue()) ==
Math.abs(ob.num.douЬleValue()) return true;
return false;
В данном случае выражение NumericFns<?> соответствует любому типу объекта из
класса NшnericFns, что позволяет сравнивать абсолютные значения в двух произвольных
объектах класса NumericFns. Ниже приведен пример программы, демонстрирующий
использование шаблона аргумента.
// Использование шаблона аргумента
class NumericFns<T extends NumЬer> {
Т num;
// Передать конструктору ссылку на числовой объект
NumericFns(T n) {
num = n;
// Вернуть обратную величину
douЫe reciprocal() {
return l / num.douЬleValue();
// Вернуть дробную часть
douЫe fraction() {
return num.douЫeValue() - num.intValue();
// Проверить равенство абсолютных значений двух объектов
boolean absEqual(NumericFns<?> оЬ) {
if(Math.abs(num.douЬleValue()) ==
Math.abs(ob.num.douЫeValue())) return true;
return false;
//
// Демонстрация использования шаблона аргумента
class WildcardDemo {
puЫic static void main(String args[J) {
NumericFns<Integer> iOb
new NumericFns<Integer>(б);
Глава 13. Обобщения 479
NumericFns<DouЫe> dOb
new NumericFns<DouЫe>(-6.0);
NumericFns<Long> lOb
new NumericFns<Long>(5L);
System.out.println("Cpaвнeниe iOb и dOb"); Взтом аызове методотип аргумента-
if (iOb. absEqual (dОЬ)) wобnоиа совпадает с типом DouЫe
System.out.println("Aбcoлютныe значения совпадают.");
else
System.out.println("Aбcoлютныe значения отличаются.");
System.out.println();
System.out.println("Cpaвнeниe iOb и lOb."); В пом вызоае метода тип аргумента-
if(iOb.absEqual(lOЬ)) 4----------wабnоиа соаnадоет с типом Long
System.out.println("Aбcoлютныe значения совпадают.");
else
System.out.println("Aбcoлютныe значения отличаются.");
Выполнение этой программы дает следующий результат.
Сравнение iOb and dOb
Абсолютные значения совпадают.
Testing iOb and lOb.
Абсолютные значения отличаются.
Обратите внимание на два следующих вызова метода absEqual () .
if(iOb.absEqual(dOЬ))
if(iOb.absEqual(lOb))
В первом вызове iOb - объект типа NumericFns<Integer>, а dOb - объект типа
NumericFns<DouЫe>. Однако использование шаблона в объявлении метода absEqual ()
позволило вызвать этот метод для объекта iOb, указав объект dOb в качестве аргумента.
То же самое относится и к другому вызову, в котором методу передается объект типа
NumericFns<Long>.
И последнее замечание: не следует забывать, что шаблоны аргументов не влияют на
тип создаваемого объекта в классе NumericFns. Для этой цели служит оператор extends,
указываемый в объявлении класса NumericFns. Шаблон лишь указывает на соответствие
любому допустимому объекту класса NumericFns.
Ограниченные шаблоны
Шаблоны аргументов можно ограничивать в основном так же, как и параметры типов.
Ограниченные шаблоны особенно полезны при создании методов, которые должны
оперировать только объектами подклассов определенного суперкласса. Чтобы разобраться
в том, почему это так, обратимся к простому примеру. Допустим, имеется
следующий ряд классов.
480 Java 8: руководство для начинающих. 6-е издание
class А {
// . . .
class В extends А {
/ / ".
class С extends А {
/ / ".
// Обратите внимание на то, что D не является подклассом А
class D {
/ / . . .
Здесь класс А расширяется классами В и с, но не D.
Рассмотрим простой обобщенный класс.
// Простой обобщенный класс
class Gen<T> {
Т оЬ;
Gen(T о) {
оЬ = о;
В классе Gen предусмотрен один параметр типа, который определяет тип объекта,
хранящегося в переменной оЬ. Как видите, на тип т не налагается никаких ограничений.
Следовательно, параметр типа т может обозначать любой класс.
А теперь допустим, что требуется создать метод, принимающий аргумент любого
типа, соответствующего объекту класса Gen, при условии, что в качестве параметра типа
этого объекта указывается класс А или его подклассы. Иными словами, требуется создать
метод, который оперирует только объектами типа Gеn<тип>, где тип - это класс
А или его подклассы. Для этой цели нужно воспользоваться ограниченным шаблоном
аргумента. Ниже приведен пример объявления метода test (), которому в качестве аргумента
может быть передан только объект класса Gen, параметр типа которого обязан
соответствовать классу А или его подклассам.
// Здесь шаблон ? устанавливает соответствие
// классу А или его подклассам
static void test(Gen<? extends А> о) {
/ / . . .
Следующий пример класса демонстрирует типы объектов класса Gen, которые могут
быть переданы методу test ().
class UseBoundedWildcard {
// Здесь знак ? устанавливает соответствие
// классу А или производным от него подклассам.
Глава 1 3. Обобщения 481
// В объявлении этого метода используется ограниченный
// метасимвольный аргумент.
static void test (Gen<? extends А> о) { Исnоn􀀷зов ониеоrраиичен ноrо
// • • • wабnона
puЫic static void main(String args[J)
А а
в ь
с с =
D d
Gen<A>
Gen<B>
Gen<C>
Gen<D>
new А();
new в();
new с();
new D ();
w = new Gen<A>(a);
w2 new Gen<B> (Ь);
wЗ new Gen<C>(c);
w4 new Gen<D> (d);
{
// Эти вызовы метода test() допустимы
test(w);
test (w2); }-- Эrи вызовы метода test () допустимы,
tes t ( wЗ) ; так как об1.екты w, w2 и wЗ от носят ся к подклассом А
// А этот вызов метода test() недопустим, так как
// объект w4 не относится к подклассу А.
/ / test (w4) ; / / Ошибка! Недоп устимо, поскопысу объект w4
}
не относи тся к nод к.поссу А
В методе main () создаются объекты классов А, в, с и о, которые затем используются
для создания четырех объектов класса Gen (по одному на каждый тип). После этого
метод test () вызывается четыре раза, причем последний его вызов закомментирован.
Первые три вызова вполне допустимы, поскольку w, w2 и wЗ являются объектами класса
Gen, типы которых определяются классом А или производными от него классами.
Последний вызов метода test () недопустим, потому что w4 - это объект класса D, не
являющегося производным от класса А. Следовательно, ограниченный шаблон аргумента
в методе test () не позволяет передавать ему объект w4 в качестве параметра.
В общем случае для установки верхней границы шаблона аргумента используется выражение
следующего вида:
<? extends суперкласс >
где после ключевого слова extends указывается суперкласс, т.е. имя класса, определяющего
верхнюю границу, включая и его самого. Это означает, что в качестве аргумента
допускается указывать не только подклассы данного класса, но и сам этот класс.
По необходимости можно указать также нижнюю границу. Для этого используется
ключевое слово super, указываемое в следующей общей форме:
<? super подкласс >
В данном случае в качестве аргумента допускается использовать только суперклассы,
от которых наследует подкласс, включая его самого.
482 Java 8: руководство для начинающих. 6-е издание
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Можно ли привести один экземпляр обобщенного класса к другому?
ОТВЕТ. Да, можно. Но только в том случае, если типы обоих классов совместимы
и их аргументы типа совпадают. Рассмотрим в качестве примера обобщенный
класс Gen:
class Gen<T> { // ...
Далее допустим, что переменная х объявлена так:
Gen<Integer> х = new Gen<Integer>();
В этом случае следующее приведение типов может быть выполнено, поскольку
переменная х - это экземпляр класса Gen<Integer>:
(Gen<Integer>) х // Допустимо
А следующее приведение типов не может быть выполнено, поскольку переменная
хне является экземпляром класса Gen<Long >:
(Gen<Long>) х // Недопустимо
Обобщенные методы
Как было показано в предыдущих примерах, методы в обобщенных классах могут
использовать параметр типа своего класса, а следовательно, автоматически становятся
обобщенными относительно параметра типа. Однако можно объявить обобщенный метод,
который сам по себе использует параметры типа. Более того, такой метод может
быть объявлен в обычном, а не обобщенном классе.
Ниже приведен пример программы, в которой объявляется класс GenericMethod
Demo, не являющийся обобщенным. В этом классе объявляется статический обобщенный
метод arraysEqual (), в котором определяется, содержатся ли в двух массивах одинаковые
элементы, расположенные в том ж самом порядке. Такой метод можно использовать
для сравнения любых двух массивов с одинаковыми или совместимыми типами,
а сами элементы массивов допускают их сравнение.
// Пример простого обобщенного метода
class GenericMethodDemo {
// Определить, совпадает ли содержимое двух массивов
static <Т extends ComparaЫe<T>, V extends Т> boolean
arraysEqual(T[J х, V[] у) { Обобщенныйметод
// Массивы, имеющие разную длину, не могут быть одинаковыми
if(x.length != y.length) return false;
for(int i=O; i < x.length; i++)
if ( ! х [ i J . equals ( у [ i] ) )
return false; // массивы отличаются
Глава 13. Обобщения 483
return true; // содержимое массивов совпадает
puЫic static void main(String args[]}
Integer nums[] =
Integer nums2[]
Integer nums3[]
Integer nums4 []
{
{
{
{
1, 2,
1, 2,
1, 2,
1, 2,
3, 4, 5 } ;
3, 4, 5 } ;
7, 4, 5 } ;
7, 4, 5, 6 };
if(arraysEqual(nums, nums)} '4----------- Арrументw типа Т и V не,�вно
System.out.println("nums эквивалентен nums");
if(arraysEqual(nums, nums2))
System.out.println("nums эквивалентен nums2"};
if(arraysEqual(nums, nums3))
System.out.println("nums эквивалентен nums3");
if(arraysEqual(nums, nums4)}
System.out.println("nums эквивалентен nums4"};
// создать массив типа DouЫe
DouЫe dvals[] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
опредеп,�ютс• при вwзове метода
// Следующая строка не будет скомпилирована, так как
// типы массивов nums и dvals не совпадают.
// if(arraysEqual(nums, dvals)}
// System.out.println("nums эквивалентен dvals");
)
Результат выполнения данной программы выглядит следующим образом.
nums эквивалентен nums
nums эквивалентен nums2
Рассмотрим подробнее исходный код метода arraysEqual (). Прежде всего взгляните
на ero объявление.
static <Т extends ComparaЫe<T>, V extends Т> boolean
arraysEqual(T[] х, V[] у) {
Параметры типа объявляются перед возвращаемым типом. Также обратите внимание
на то, что т наследует интерфейс ComparaЫe<T>. Интерфейс ComparaЫe определен в
пакете j ava. lang. Класс, реализующий интерфейс ComparaЫe, определяет упорядочиваемые
объекты. Таким образом, установление ComparaЫe в качестве верхней границы
допустимых типов гарантирует, что метод arraysEqual () можно использовать только
в отношении объектов, допускающих сравнение. Интерфейс ComparaЫe - обобщенный,
и ero параметр типа задает тип сравниваемых объектов. (0 создании обобщенных
интерфейсов речь пойдет немного позже.) Заметьте, что тип v ограничен сверху типом
т. Следовательно, тип v должен либо совпадать с типом т, либо быть ero подклассом.
В силу этого метод arrayEquals () может вызываться лишь с аргументами, которые
можно сравнивать между собой. Кроме того, этот метод объявлен как статический и
484 Java 8: руководство для начинающих. 6-е издание
поэтому вызывается без привязки к какому-либо объекту. Однако вы должны понимать,
что обобщенные методы могут быть как статическими, так и нестатическими. Никаких
ограничений в этом отношении не существует.
А теперь проанализируем, каким образом метод arraysEqual () вызывается в методе
main (). Для этого используется обычный синтаксис, не требующий указания аргументов
типа. Дело в том, что типы аргументов распознаются автоматически, соответственно
определяя типы т и v. Например, в первом вызове
if(arraysEqual(nums, nums))
типом первого аргумента является Integer, который и подставляется вместо типа т.
Таким же является и тип второго аргумента, а следовательно, тип параметра v также заменяется
на Integer. Таким образом, выражение для вызова метода arraysEqual () составлено
корректно, и сравнение массивов между собой может быть выполнено.
Обратите внимание на следующие строки, помещенные в комментарий.
// if(arraysEqual(nums, dvals))
// System.out.println("nums эквивалентен dvals");
Если удалить в них символы комментариев и попытаться скомпилировать программу,
то компилятор выдаст сообщение об ошибке. Дело в том, что верхней границей для
типа параметра v является тип параметра т. Этот тип указывается после ключевого слова
extends, т.е. тип параметра v может быть таким же, как и у параметра т, или быть его
подклассом. В данном случае типом первого аргумента метода является Integer, заменяющий
тип параметра т, тогда как типом второго аргумента - DouЫe, не являющийся
подклассом Integer. Таким образом, вызов метода arraysEqual () оказывается недопустимым,
что и приводит к ошибке во время компиляции.
Синтаксис объявления метода arraysEqual () может быть обобщен. Ниже приведена
общая форма объявления обобщенного метода.
<список_параметров_типа> возвращаемый_тип
имя_метода(список параметров) (// ...
Во всех случаях параметры типа разделяются в списке запятыми. В объявлении обобщенного
метода этот список предшествует объявлению возвращаемого типа.
Обобщенные конструкторы
Конструктор может быть обобщенным, даже если сам класс не является таковым.
Например, в приведенной ниже программе класс Summation не является обобщенным,
но в нем используется обобщенный конструктор.
// Использование обобщенного конструктора
class Summation {
private int sum;
<Т extends NumЬer> Summation(T arg) {
sum = О;
4----Обобщенный конструктор
for(int i=O; i <= arg.intValue(); i++)
sum += i;
int getSum() {
return sum;
class GenConsDemo {
puЬlic static void main(String args[])
Summation оЬ = new Summation(4.0);
Глава 13. Обобщения 485
System.out.println("Cyммa целых чисел от О до 4.0 равна "
getSum());
В классе Surnmation вычисляется и инкапсулируется сумма всех чисел от О до N, причем
значение N передается конструктору. Для конструктора Summation () указан параметр
типа, ограниченный сверху классом NumЬer, и поэтому объект типа Surnmation может
быть создан с использованием любого числового типа, в том числе Integer, Float
и DouЫe. Независимо от того, какой числовой тип используется, соответствующее
значение преобразуется в тип Integer при вызове intValue (), после чего вычисляется
требуемая сумма. Таким образом, класс Summation не обязательно объявлять обобщенным
- достаточно сделать обобщенным только его конструктор.
Обобщенные интерфейсы
Как уже было показано на примере класса GenericMetodDemo, обобщенными могут
быть не только классы и методы, но и интерфейсы. Использование в этом классе
стандартного интерфейса ComparaЫe<T> гарантировало возможность сравнения элементов
двух массивов. Разумеется, вы также можете объявить собственный обобщенный
интерфейс. Обобщенные интерфейсы объявляются аналогично тому, как объявляются
обобщенные классы. В приведенном ниже примере программы создается обобщенный
интерфейс Containment, который может быть реализован классами, хранящими одно
или несколько значений. Кроме того, в этой программе объявляется метод contains () ,
позволяющий определить, содержится ли указанное значение в текущем объекте.
// Пример обобщенного интерфейса.
// Подразумевается, что класс, реализующий этот
// интерфейс, содержит одно или несколько значений.
interface Containment<T> { ---------------Обобщенный интерфейс
// Метод contains() проверяет, содержится ли
// некоторый элемент в объекте класса,
// реализующего интерфейс Containment.
boolean contains(T о);
// Реализовать интерфейс Containment с помощью массива,
// предназначенного для хранения значений.
class MyClass<T> implements Containment<T> {
Т [] arrayRef; Любой КJ1асс, реализующий обобщенный интерфейс,
также должен быть обобщенным
486 Java 8: руководство для начинающих. 6-е издание
MyClass (Т [] о) {
arrayRef = о;
// Реализовать метод contains()
puЬlic boolean contains(T о) {
for(T х: arrayRef)
if(x.equals(o)) return true;
return false;
class GenIFDemo
puЫic static void main(String args[]) {
Integer х[] = { 1, 2, 3 );
MyClass<Integer> оЬ new MyClass<Integer>(x);
if(ob.contains(2))
System.out.println("2 содержится в оЬ");
else
System.out.println("2 НЕ содержится в оЬ");
if(ob.contains(5))
System.out.println("5 содержится в оЬ");
else
System.out.println("5 НЕ содержится в оЬ");
// Следующие строки кода недопустимы, так как объект оЬ
// является вариантом реализации интерфейса Containment для
// типа Integer, а значение 9.25 относится к типу DouЫe.
// if(ob.contains(9.25)) // Недопустимо!
// System.out.println("9.25 не содержится в оЬ");
}
Выполнение этой программы дает следующий результат.
2 содержится в оЬ
5 Не содержится в оЬ
Большая часть исходного кода этой программы совершенно понятна, однако не помешает
сделать пару замечаний. Прежде всего обратите внимание на то, как объявляется
интерфейс Contairuneпt:
interface Containment<T> {
Нетрудно заметить, что это объявление напоминает объявление обобщенного класса.
В данном случае параметр типа т задает тип объектов содержимого.
Интерфейс Containment реализуется классом MyClass. Объявление этого класса
приведено ниже.
class MyClass<T> implements Containment<T> {
Глава 13. Обобщения 487
Если класс реализует обобщенный интерфейс, то он также должен быть обобщенным.
В нем должен быть объявлен как минимум тот же параметр типа, что и в объявлении
интерфейса. Например, такой вариант объявления класса MyClass недопустим:
class MyClass implements Containment<T> { // Ошибка!
В данном случае ошибка состоит в том, что в классе MyClass не объявлен параметр
типа, а это означает, что передать параметр типа интерфейсу Containrnent невозможно.
Если идентификатор т останется неизвестным, компилятор выдаст сообщение об ошибке.
Класс, реализующий обобщенный интерфейс, может не быть обобщенным только в
одном случае: если при объявлении класса для интерфейса указывается конкретный тип.
class MyClass implements Containrnent<DouЫe> { // Допустимо
Вас теперь вряд ли удивит, что один или несколько параметров типа, определяемых
обобщенным интерфейсом, могут быть ограниченными. Это позволяет указать, какие
именно типы данных допустимы для интерфейса. Например, если вы хотите ограничить
применимость интерфейса Containrnent числовыми типами, то его можно объявить следующим
образом:
interface Containment<T extends NumЬer> {
Теперь любой класс, реализующий интерфейс Containrnent, должен передавать ему
значение типа, удовлетворяющее тем же ограничениям. Например, класс MyClass, реализующий
данный интерфейс, должен объявляться следующим образом:
class MyClass<T extends Number> implements Containment<T> {
Обратите внимание на то, как параметр типа т объявляется в классе MyClass, а затем
передается интерфейсу Containment. На этот раз интерфейсу Containment требуется
тип, расширяющий тип NumЬer, поэтому в классе MyClass, реализующем этот интерфейс,
должны быть указаны соответствующие ограничения. Если верхняя граница задана
в объявлении класса, то нет никакой необходимости указывать ее еще раз после
ключевого слова implements. Если же вы попытаетесь это сделать, то компилятор выведет
сообщение об ошибке. Например, следующее выражение некорректно и не будет
скомпилировано.
// Ошибка!
class MyClass<T extends NumЬer>
implements Containment<T extends Nurnber> {
Коль скоро параметр типа задан, он просто передается интерфейсу без дальнейших
видоизменений.
Ниже приведена общая форма объявления обобщенного интерфейса:
interface имя_интерфейса<список_параметров_типа> { // ...
где список_ параметров_ типа содержит список параметров, разделенных запятыми.
При реализации обобщенного интерфейса в объявлении класса также должны быть указаны
параметры типа. Общая форма объявления класса, реализующего обобщенный интерфейс,
приведена ниже.
class имя_класса<список_параметров типа>
implements имя_интерфейса<список_параметров_типа>
488 Java 8: руководство для начинающих. 6-е издание
Упражнение l 3.1 Создание обобщенноrо класса очереди
:···················· .. ················: Одним из главных преимуществ обобщенных классов является
: IGenQ.java
, QExc. j ava возможность создания надежного кода, пригодного для повторного
) GenQueue. j ava использования. Как уже отмечалось в начале главы, многие алго-
1 GenQDemo. j ava ритмы могут быть реализованы одинаково независимо от типа дан-
: ...................................... , ных. Например, очередь в равной степени пригодна для хранения
целых чисел, строк, объектов типа File и других типов данных. Вместо того чтобы создавать
отдельный класс очереди для объектов каждого типа, можно разработать единое
обобщенное решение, позволяющее работать с объектами любого типа. В итоге цикл
проектирования, программирования, тестирования и отладки кода будет выполняться
только один раз, и его не надо будет проходить заново, когда потребуется организовать
очередь для нового типа данных.
В этом проекте вам предстоит видоизменить класс очереди, разработка которого
была начата в упражнении 5.2, и придать ему окончательную форму. Проект включает
обобщенный интерфейс, определяющий операции над очередью, два класса исключений
и один вариант реализации - очередь фиксированного размера. Разумеется, вам
ничто не помешает поэкспериментировать с другими разновидностями обобщенных
очередей, например, создать динамическую или циклическую очередь, следуя приведенным
ниже рекомендациям.
Кроме того, исходный код, реализующий очередь в этом проекте, будет организован
в виде ряда отдельных файлов. С этой целью код интерфейса, исключений, реализации
очереди фиксированного размера и программы, демонстрирующей очередь в действии,
будет распределен по отдельным исходным файлам. Такая организация исходного кода
отвечает подходу, принятому в работе над большинством реальных проектов. Поэтапное
описание процесса создания программы приведено ниже.
1. Первым этапом создания обобщенной очереди станет формирование обобщенного
интерфейса, описывающего две операции над очередью: размещение и извлечение
объектов. Обобщенная версия интерфейса очереди будет называться IGenQ,
и ее исходный код приведен ниже. Поместите этот код в файл IGenQ. j ava.
// Обобщенный интерфейс очереди
puЫic interface IGenQ<T> {
// Поместить элемент в очередь
void put(T ch) throws QueueFullException;
// Извлечь элемент из очереди
Т get() throws QueueEmptyException;
Обратите внимание на то, что тип данных, предназначенных для хранения в очереди,
определяется параметром типа т.
2. Создайте файлы QueueFullException. java и QueueEmptyException. java и введите
в каждый из них исходный код одноименного класса.
// Исключение, указывающее на переполнение
class QueueFullException extends Exception
int size;
QueueFullException (int s) { size s; }
Глава 13. Обобщения 489
puЫic String toString() {
return "\nОчередь заполнена. Максимальный размер очереди: " +
size;
// Исключение, указывающее на исчерпание очереди
class QueueEmptyException extends Exception {
puЫic String toString() {
return "\nОчередь пуста";
В этих классах инкапсулированы две ошибки, которые могут возникнуть в работе
с очередью: попытка поместить элемент в заполненную очередь и попытка
извлечь элемент из пустой очереди. Эти классы не являются обобщенными,
поскольку они действуют одинаково, независимо от типа данных, хранящихся в
очереди, и поэтому совпадают с теми, которые использовались в упражнении 9.1.
З. Создайте файл GenQueue. j ava. Введите в него приведенный ниже код, реализующий
очередь фиксированного размера.
// Обобщенный класс, реализующий очередь фиксированного размера
class GenQueue<T> implements IGenQ<T> {
private Т q[]; // массив для хранения элементов
// очереди
private int putloc, getloc; // индексы вставки и извлечения
// элементов очереди
// Создание пустой очереди из заданного массива
puЫic GenQueue(T[] aRef)
q = aRef;
putloc = getloc = О;
// Поместить элемент в очередь
puЬlic void put(T obj)
throws QueueFullException
if(putloc==q.length-1)
throw new QueueFullException(q.length);
q[putloc++] = obj;
// Извлечь элемент из очереди
puЫic т get ()
throws QueueEmptyException
if(getloc == putloc)
throw new QueueEmptyException();
return q[getloc++];
490 Java 8: руководство для начинающих. 6-е издание
Класс GenQueue объявляется как обобщенный с параметром типа т. Этот параметр
определяет тип данных, хранящихся в очереди. Обратите внимание на то,
что параметр типа т также передается интерфейсу IGenQ.
Конструктору GenQueue передается ссьшка на массив, используемый дЛЯ хранения
элементов очереди. Следовательно, чтобы создать объект класса GenQueue, необходимо
сначала создать массив, тип которого совместим с типом объектов, сохраняемых
в очереди, а его размер достаточен для размещения объектов в очереди.
Например, в следующих строках кода показано, как создать очередь для хранения
строк.
String strArray[) = new String[lO];
GenQueue<String> strQ = new GenQueue<String>(strArray);
4. Создайте файл GenQDemo.java и введите в него приведенный ниже код, демонстрирующий
работу обобщенной очереди.
/*
Упражнение 13.1.
Демонстрация обобщенного класса очереди.
*/
class GenQDerno {
puЫic static void rnain(String args[]) {
// Создать очередь для хранения целых чисел
Integer iStore[] = new Integer[lO];
GenQueue<Integer> q = new GenQueue<Integer>(iStore);
Integer iVal;
Systern.out.println("Дeмoнcтpaции очереди чисел типа Integer");
try {
for (int i=O; i < 5; i++) {
Systern.out.println("Дoбaвлeниe " + i + " в очередь q");
q.put{i); // добавить целочисленное значение в очередь q
catch (QueueFullException ехс)
Systern.out.println(exc);
Systern.out.println();
try {
for (int i=O; i < 5; i++) {
Systern.out.print("Пoлyчeниe следующего числа
типа Integer из очереди q: ");
iVal = q.get();
Systern.out.println(iVal);
catch (QueueErnptyException ехс) {
Systern.out.println(exc);
5.
System.out.println(};
Глава 13. Обобщения 491
// Создать очередь для хранения чисел с плавающей точкой
DouЫe dStore[] = new DouЬle[lO];
GenQueue<DouЫe> q2 = new GenQueue<DouЫe>(dStore};
DouЫe dVal;
System.out.
рrintln("Демонстрация очереди чисел типа DouЬle"};
try {
for (int i=O; i < 5; i++} {
System.out.println("Дoбaвлeниe " + (douЫe}i/2 +
в очередь q2" } ;
q2.put((douЫe}i/2); // ввести значение типа douЫe в очередь
q2
catch (QueueFullException ехс)
System.out.println(exc);
System.out.println(};
try {
for (int i=O; i < 5; i++) {
System.out.print("Пoлyчeниe следующего числа типа
DouЫe из очереди q2: "};
dVal = q2.get();
System.out.println(dVal);
catch (QueueEmptyException ехс) {
System.out.println(exc);
Скомпилируйте программу и запустите ее на выполнение. В итоге на экране ото-
бразится следующий результат.
Демонстрация очереди чисел типа Integer
Добавление о в очередь q.
Добавление 1 в очередь q.
Добавление 2 в очередь q.
Добавление 3 в очередь q.
Добавление 4 в очередь q.
Получение следующего числа типа Integer из очереди q: о
Получение следующего числа типа Integer из очереди q: 1
Получение следующего числа типа Integer из очереди q: 2
Получение следующего числа типа Integer из очереди q: 3
Получение следующего числа типа Integer из очереди q: 4
492 Java 8: руководство для начинающих. 6-е издание
Демонстрация очереди чисел типа DouЫe
Добавление О.О в очередь q2.
Добавление 0.5 в очередь q2.
Добавление 1.0 в очередь q2.
Добавление 1.5 в очередь q2.
Добавление 2.0 в очередь q2.
Получение следующего числа типа DouЫe ИЗ очереди q2:
Получение следующего числа типа DouЫe из очереди q2:
Получение следующего числа типа DouЫe из очереди q2:
Получение следующего числа типа DouЫe ИЗ очереди q2:
Получение следующего числа типа DouЫe из очереди q2:
о.о
0.5
1.0
1.5
2.0
6. Попытайтесь самостоятельно написать обобщенные версии классов CircularQueue
и DynQueue, созданных в упражнении 8.1.
Базовые типы и унаследованный код
Поскольку в версиях Java, предшествующих JDK 5, поддержка обобщенных типов
отсутствовала, необходимо бьvю предпринять меры к тому, чтобы обеспечить совместимость
новых программ с унаследованным кодом. По существу, возникла потребность в
средствах, позволяющих унаследованному коду сохранить свою функциональность и
при этом иметь возможность взаимодействовать с кодом, использующим обобщенные
типы.
Чтобы облегчить адаптацию существующего кода к обобщениям, Java позволяет использовать
обобщенные классы без указания аргументов типа. В результате для класса
создается так называемый "сырой" (далее - базовый) тип. Базовые типы совместимы с
унаследованным кодом, которому ничего не известно об обобщенных классах. Главный
недостаток использования базовых типов заключается в том, что безопасность типов,
обеспечиваемая обобщениями, при этом утрачивается.
Ниже приведен пример программы, демонстрирующей использование базового типа.
// Демонстрация использования базового типа
class Gen<T> {
Т оЬ; // объявить объект типа Т
// Передать конструктору ссылку на объект типа Т
Gen(T о) {
оЬ = о;
// Вернуть объект оЬ
Т getob() {
return оЬ;
// Продемонстрировать использование базового типа
class RawDemo {
puЬlic static void main(String args[J) {
Глава 13. Обобщения 493
// Создать объект класса Gen для типа Integer
Gen<Integer> iOb = new Gen<Integer>(88);
// Создать объект класса Gen для типа String
Gen<String> strOb = new Gen<String>("Tecтиpoвaниe обобщений");
// Создать базовый объект класса Gen и передать ему
// значение типа DouЫe
Gen raw = new Gen(new DouЫe(98.6)); -4---- Еспи арrумент типа не предоставляется,
создается базовый тип
// Здесь требуется приведение типов, так как тип неизвестен
douЫe d = (DouЫe) raw.getob();
System.out.println("знaчeниe: " + d);
// Использование базового типа может привести
// к исключениям времени выполнения. Соответствующие
// примеры представлены ниже.
// Следующее приведение типов вызывает ошибку
/ / времени вьmолнения !
// int i = (Integer) raw.getob(); // ошибка времени выполнения
/ / Это присваивание нарушает безопасность типов Безопасность
strOb = raw; // допустимо, но потенциально неверно ______ нспоnЬ3ования
базовоrо типа
/ / String str = strOb. getob () ; / / ошибка времени выполнении не проверяется
// Следующее присваивание также нарушает безопасность типов
raw = iOb; // допустимо, но потенциально неверно
// d = (DouЫe) raw.getob(); // ошибка времени выполнения
}
У этой программы имеется ряд интересных особенностей. Прежде всего, базовый
тип обобщенного класса Gen создается в следующем объявлении:
Gen raw = new Gen(new DouЫe(98.6));
В данном случае аргументы типа не указываются. В итоге создается объект класса
Gen, тип т которого заменяется типом Obj ect.
Базовые типы не обеспечивают безопасность типов. Переменной базового типа может
быть присвоена ссылка на любой тип объекта класса Gen. Справедливо и обратное:
переменной конкретного типа из класса Gen может быть присвоена ссылка на объект
класса Gen базового типа. Обе операции потенциально опасны, поскольку они действуют
в обход механизма проверки типов, обязательной для обобщений.
Недостаточный уровень безопасности типов демонстрируют примеры в строках кода
в конце данной программы, помещенных в комментарии. Рассмотрим их по отдельности.
Сначала проанализируем следующую строку кода:
// int i = (Integer) raw.getob(); // ошибка времени выполнения
В этом операторе присваивания в объекте raw определяется значение переменной
оЬ, которое приводится к типу Integer. Однако в объекте raw содержится не целое
число, а значение типа DouЫe. На стадии компиляции этот факт выявить невозможно,
494 Java 8: руководство для начинающих. 6-е издание
поскольку тип объекта raw неизвестен. Следовательно, ошибка возникнет на стадии выполнения
программы.
В следующих строках кода ссьmка на объект класса Gen базового типа присваивается
переменной strOb (предназначенной для хранения ссьmок объекты типа Gen<String>).
strOb = raw; // допустимо, но потенциально неверно
// String str = strOb.getob(); // ошибка времени выполнения
Само по себе присваивание синтаксически правильно, но все же сомнительно. Переменная
strOb ссьmается на объект типа Gen<String>, а следовательно, она должна
содержать ссьmку на объект, содержащий значение типа String, но после присваивания
объект, на который ссылается переменная strOb, содержит значение типа DouЫe. Поэтому,
когда во время выполнения программы предпринимается попытка присвоить переменной
str содержимое объекта, на который ссьmается переменная strOb, возникает
ошибка. Причиной ошибки является то, что в этот момент переменная strOb ссьmается
на объект, содержащий значение типа DouЫe. Таким образом, присваивание ссьmки на
объект базового типа переменной, ссьmающейся на объект обобщенного типа, делается
в обход механизма безопасности типов.
В следующих строках кода демонстрируется ситуация, обратная предыдущей.
raw = iOb; // допустимо, но потенциально неверно
// d = (DouЫe) raw.getob(}; // ошибка времени выполнения
В данном случае ссылка на объект обобщенного типа присваивается переменной
базового типа. И это присваивание синтаксически правильно, но приводит к ошибке,
возникающей во второй строке кода. В частности, переменная raw указывает на объект,
содержащий значение типа Integer, но при приведении типов предполагается, что он
содержит значение типа DouЫe. Эту ошибку также нельзя выявить на стадии компиляции,
так как она проявляется только на стадии выполнения программы.
В связи с тем что использование базовых типов сопряжено с потенциальными рисками,
в подобных случаях компилятор javac выводит так называемые непроверенные
предупреждения, указывающие на возможность нарушения безопасности типов. В рассматриваемой
программе причиной таких предупреждений являются следующие строки
кода.
Gen raw = new Gen(new DouЫe(98.6}};
strOb = raw; // Допустимо, но потенциально неверно.
В первой строке кода содержится обращение к конструктору класса Gen без указания
аргумента типа, что приводит к выдаче компилятором соответствующего предупреждения.
При компиляции второй строки предупреждающее сообщение возникнет из-за попытки
присвоить переменной, ссьmающейся на объект обобщенного типа, ссылки на
объект базового типа.
На первый взгляд может показаться, что предупреждение об отсутствии проверки
типов должна порождать и приведенная ниже строка кода, однако этого не происходит.
raw = iOb; // допустимо, но потенциально неверно
В данном случае компилятор не вьщает никаких предупреждающих сообщений, потому
что такое присваивание не вносит никаких дополнительной потери безопасности
типов кроме той, которая уже бьmа привнесена при создании переменной raw базового
типа.
Глава 13. Обобщения 495
Из всего вышесказанного можно сделать следующий вывод: базовыми типами следует
пользоваться весьма ограниченно и только в тех случаях, когда унаследованный
код объединяется с новым, обобщенным кодом. Базовые типы - лишь вспомогательное
средство, необходимое для обеспечения совместимости с унаследованным кодом, и их
использования во вновь создаваемом коде следует избегать.
Автоматическое определение
аргументов типов компилятором
Начиная с версии JDK 7 для создания экземпляров обобщенного типа предусмотрен
сокращенный синтаксис. В качестве примера обратимся к классу TwoGen, представленному
в начале этой главы. Ниже для удобства приведена часть его объявления. Обратите
внимание на то, что в нем определяются два обобщенных типа данных.
class TwoGen<T, V> {
Т оЫ;
V оЬ2;
// Передать конструктору ссылку на объект типа Т
TwoGen(T ol, V о2) {
}
оЫ ol;
оЬ2 = о2;
11 . . .
В случае версий Java, предшествующих JDK 7, для создания экземпляра класса
TwoGen пришлось бы использовать примерно следующий код.
TwoGen<Integer, String> tgOb =
new TwoGen<Integer, String>{42, "testing");
Здесь аргументы типа (в данном случае Integer и String) указываются дважды: сначала
при объявлении переменной tgOb, а затем при создании экземпляра класса TwoGen
с помощью оператора new. С тех пор как обобщения были введены в версии JDK 5, подобная
форма создания объектов обобщенного типа была обязательной для всех версий
Java, предшествующих JDK 7. И хотя эта форма сама по себе верна, она более громоздка,
чем это действительно требуется. Поскольку компилятору несложно самостоятельно
определить типы аргументов типа в операторе new, дублирование этой информации
оказывается излишним. Для разрешения этой ситуации в версии JDK 7 предусмотрен
специальный синтаксический элемент.
Версия JDK 7 позволяет переписать приведенное выше объявление в следующем
виде:
TwoGen<Integer, String> tgOb = new TwoGen<>(42, "testing");
Обратите внимание на ту часть кода, в которой создается экземпляр объекта обобщенного
типа. Угловые скобки ( < > ), обозначающие пустой список аргументов типа,
предписывают компилятору самостоятельно определить типы аргументов, требующиеся
конструктору, исходя из контекста (так называемое выведение типов). Главное преимущество
такого подхода состоит в том, что он позволяет существенно сократить размер
неоправданно громоздких объявлений. Эта возможность оказывается особенно удобной
496 Java 8: руководство для начинающих. 6-е издание
при объявлении обобщенных типов, определяющих границы наследования в иерархии
классов Java.
Приведенную выше форму объявления экземпляра класса можно обобщить. Для
того чтобы компилятор автоматически определял (выводил) типы аргументов типа, необходимо
использовать следующая общую синтаксическую форму объявления обобщенной
ссылки и создания экземпляра объекта обобщенного типа.
сlаss-пате<список_аргументов_типа> имя_переменной =
new имя_класса< >(список_аргументов_конструктора);
В подобных случаях список аргументов типа в операторе new должен быть пустым.
Как правило, автоматическое выведение типов компилятором возможно и при передаче
параметров методам. Так, если объявить в классе TwoGen следующий метод:
boolean isSame(TwoGen<T, V> о) {
if(oЫ == о.оЫ && оЬ2 == о.оЬ2) return true;
else return false;
то в JDK 7 будет вполне допустим вызов следующего вида:
if(tgOb.isSame(new TwoGen<>(42, "тестирование")))
System.out.println("Coвпaдaют"};
В этом случае аргументы типа, которые должны передаваться методу isSame (), опускаются.
Их типы могут быть автоматически определены компилятором, а следовательно,
их повторное указание бьvю бы излишним.
Возможность использования пустого списка аргументов типа появилась в версии
JDK 7, и поэтому в более ранних версиях компилятора Java она недоступна. По этой
причине в примерах программ, приводимых далее, будет использоваться прежний, несокращенный
синтаксис объявления экземпляров обобщенных классов, который воспринимается
любым компилятором Java, поддерживающим обобщения. Кроме того,
несокращенный синтаксис позволяет яснее понять, какие именно объекты создаются,
что делает примеры более наглядными и полезными. Однако использование синтаксиса
выведения типов в собственных программах позволит вам значительно упростить объявления.
Очистка
Как правило, программисту не требуется знать все детали того, каким образом компилятор
преобразует исходный код программы в объектный. Однако в случае обобщенных
типов важно иметь хотя бы общее представление о процессе их преобразования.
Это помогает лучше понять, почему обобщенные классы и методы действуют именно
так, а не иначе, и почему иногда они ведут себя не совсем обычно. Поэтому ниже приведено
краткое описание того, каким образом обобщенные типы реализуются в Java.
При реализации обобщенных типов в Java разработчикам пришлось учитывать важное
ограничение, суть которого состоит в необходимости обеспечить совместимость с
предыдущими версиями Java. Проще говоря, обобщенный код должен был быть совместимым
с предыдущими версиями кода, разработанными до появления обобщенных
типов. Таким образом, любые изменения в синтаксисе языка Java или механизме JVМ
не должны были нарушать работоспособность уже существующего кода. Поэтому для
Глава 13. Обобщения 497
реализации обобщенных типов с учетом указанных ограничений был выбран механизм,
получивший название очистка.
Механизм очистки действует следующим образом. При компиляции кода, написанного
на языке Java, все сведения об обобщенных типах удаляются. Это означает, что
параметры типа заменяются верхними границами их типа, а если границы не указаны,
то их функции выполняет класс Object. После этого выполняется приведение типов,
заданных аргументами типа. Подобная совместимость типов также контролируется компилятором.
Это означает, что во время выполнения программы параметры типа просто
не существуют. Этот механизм имеет отношение лишь к исходному коду.
Ошибки неоднозначности
Включение в язык обобщенных типов породило новый тип ошибок, от которых приходится
защищаться, - неоднозначность. Ошибки неоднозначности возникают в тех
случаях, когда процесс очистки порождает два на первый взгляд различающихся объявления
обобщений, которые разрешаются в один и тот же очищенный тип, что приводит
к возникновению конфликта. Рассмотрим пример, в котором используется перегрузка
методов.
// Неоднозначность, вызванная очисткой перегруженных методов
class MyGenClass<T, V> {
Т оЫ;
v оЬ2;
//
// Эти два объявления перегруженных методов порождают
// неоднозначность, и поэтому код не компилируется
void set (Т о) {
оЫ = о;
void set (V о) {
оЬ2 = о;
, _____ Пара этих методов nорождает
иеодиоэиачност􀀖
Обратите внимание на то, что в классе MyGenClass объявлены два обобщенных типа:
т и v. Здесь делается попытка перегрузить метод set () на основе параметров т и v.
Это представляется вполне разумным, поскольку типы т и v - разные. Однако здесь
возникают два затруднения, связанные с неоднозначностью.
Во-первых, в определении класса MyGenClass ничто не указывает на то, что типы т и
v - действительно разные. Например, не является принципиальной ошибкой создание
объекта типа MyGenClass так, как показано ниже.
MyGenClass<String, String> obj = new MyGenClass<String, String>()
В данном случае типы т и v будут заменены типом String. В результате оба варианта
метода set () становятся совершенно одинаковыми, что, безусловно, является ошибкой.
Во-вторых, более серьезное затруднение возникает в связи с тем, что в результате
очистки типов оба варианта метода set () преобразуются к следующему виду:
void set (Object о) { / / ...
498 Java 8: руководство для начинающих. 6-е издание
Таким образом, попытке перегрузить метод set () класса MyGenClass присуща неоднозначность.
В данном случае вместо перегрузки методов вполне можно использовать
два метода с различными именами.
Ограничения в отношении
использования обобщений
Существуют некоторые ограничения, которые вы должны учитывать, когда используете
обобщения. Эти ограничения касаются создания объектов параметров типа, статических
членов, исключений и массивов. Ниже каждое из этих ограничений рассматривается
по отдельности.
Невозможность создания экземпляров параметров типа
Создать экземпляр параметра типа невозможно. Рассмотрим в качестве примера следующий
класс.
// Невозможно получить экземпляр типа Т
class Gen<T> {
Т оЬ;
Gen () {
оЬ = new Т(); //Недопустимо!!!
В данном примере попытка получить экземпляр типа т приводит к ошибке. Причину
этой ошибки понять нетрудно: компилятору ничего не известно о типе создаваемого
объекта, поскольку тип т является заполнителем, информация о котором удаляется во
время КОМПИЛЯЦИИ.
Ограничения статических членов класса
В статическом члене нельзя использовать параметры типа, объявленные в его классе.
Так, все объявления статических членов в приведенном ниже классе недопустимы.
class Wrong<T> {
// Неверно, поскольку невозможно создать статическую
// переменную типа Т
static Т оЬ;
// Неверно, поскольку невозможно использовать переменную типа Т
// в статическом методе
static Т getob ()
return оЬ;
Несмотря на наличие описанного выше ограничения, допускается объявлять обобщенные
статические методы, которые определяют собственные параметры типа, как это
бьuю сделано ранее.
Глава 13. Обобщения 499
Ограничения обобщенных массивов
На массивы обобщенного типа накладываются два существенных ограничения.
Во-первых, нельзя получить экземпляр массива, тип элементов которого определяется
параметром типа. И во-вторых, нельзя создать массив обобщенных ссылок на объекты
конкретного типа. Оба эти ограничения демонстрируются в приведенном ниже примере.
// Обобщенные типы и массивы
class Gen<T extends NurnЬer> {
Т оЬ;
Т vals[J; // допустимо
Gen(T о, Т[] nums) {
оЬ = о;
// Следующее выражение недопустимо
// vals = new T[lOJ; // невозможно создать массив типа Т
// Однако такой оператор допустим
vals = nums; // присвоение ссылки на существующий
// массив допускается
class GenArrays
puЫic static void main{String args[])
Integer n[J = { 1, 2, З, 4, 5 } ;
Gen<Integer> iOb = new Gen<Integer>{SO, n);
// Невозможно создать массив обобщенных ссылок
// на объекты конкретного типа
// Gen<Integer> gens[J = new Gen<Integer>[lOJ; // Ошибка!
// Следующее выражение допустимо
Gen<?> gens[J = new Gen<?>[lO];
Как показано в этой программе, ничто не мешает создать ссьтку на массив типа т:
Т vals[J; // допустимо
Однако получить экземпляр массива типа т, как показано в строке ниже, невозможно.
// vals = new T[lOJ; // невозможно создать массив типа Т
В данном случае ограничение, налагаемое на массив типа т, состоит в том, что компилятору
не известно, какого типа массив следует в действительности создавать. Но в то
же время конструктору Gen ( ) можно передать ссьтку на массив совместимого типа при
создании объекта, а также присвоить это значение переменной vals:
vals = nums; // присвоение ссылки на существующий
// массив допускается
500 Java 8: руководство для начинающих. 6-е издание
Это выражение работает, поскольку тип массива, передаваемого конструктору Gen ()
при создании объекта, известен и совпадает с типом т. В теле метода main () содержится
выражение, демонстрирующее невозможность объявить массив обобщенных ссылок на
объекты конкретноrо типа. Поэтому приведенная ниже строка кода не будет скомпилирована.
// Gen<Integer> gens[J = new Gen<Integer>[lO]; // Ошибка!
Ограничения обобщенных исключений
Обобщенный класс не может расширять класс ThrowaЫe. Это означает, что создавать
обобщенные классы исключений невозможно.
Дальнейшее изучение обобщений
Как отмечалось в начале rлавы, приведенных в ней сведений вам будет достаточно
д11я тоrо, чтобы эффективно пользоваться обобщениями в проrраммах на Java. Вместе с
тем у обобщения имеют немало особенностей, которые не были отражены в этой rлаве.
Читатели, которых заинтересовала данная тема, вероятно, захотят узнать больше о
том влиянии, которое обобщения оказывают на иерархию классов, и, в частности, каким
образом осуществляется сравнение типов во время выполнения, как переопределяются
методы и пр. Все эти и мноrие друrие вопросы, связанные с использованием обобщений,
подробно освещены в друrой моей книrе: Java 8. Полное руководство, 9-е издание
(Ид "Вильяме", 2015 r).
>.К:
Вопрось, н упражнения ДJ1я самопроаеркн
1. Обобщения очень важны, поскольку они позволяют создавать код, который:
а) обеспечивает типовую безопасность;
б) приrоден мя повторноrо использования;
в) отличается высокой надежностью;
r) обладает всеми перечисленными выше свойствами.
2. Можно ли указывать простой тип в качестве арrумента типа?
3. Как объявить класс FlightSched с двумя параметрами типа?
4. Измените ваш ответ на вопрос 3 таким образом, чтобы второй параметр типа обозначал
подкласс, производный от класса Thread.
5. Внесите изменения в класс FlightSched таким образом, чтобы второй параметр
типа стал подклассом первоrо параметра типа.
6. Что обозначает знак ? в обобщениях?
7. Может ли шаблон арrумента быть оrраниченным?
8. У обобщенною метода MyGen () имеется один параметр типа, определяющий тип
передаваемоrо ему аргумента. Этот метод возвращает также объект, тип которою
соответствует параметру типа. Как должен быть объявлен метод MyGen ()?
9. Допустим, обобщенный интерфейс объявлен так:
interface IGenIF<T, V extends Т> { // ...
Напишите объявление класса MyClass, который реализует интерфейс IGenIF.
Глава 13. Обобщения 501
10. Допустим, имеется обобщенный класс Counter<T>. Как создать объект его базового
типа?
ll. Существуют ли параметры типа на стадии выполнения программы?
12. Видоизмените свой ответ на вопрос 10 в упражнении для самопроверки из главы
9 таким образом, чтобы сделать класс обобщенным. Для этого создайте интерфейс
стека IGenStack, объявив в нем обобщенные методы push () и рор () .
13. Что означает пара угловых скобок ( < > )?
14. Как упростить приведенную ниже строку кода в версии JDK 7?
MyClass<DouЫe,String> obj =
new MyClass<DouЬle,String>(l.l,"Пpивeт");

Глава 14
Лямбда-выражения
и ссылки на методы
504 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
11, Общая форма лямбда-выражений
1а1 Определение функционального интерфейса
;r, Использование лямбда-выражений
·R!· Использование блочных лямбда-выражений
* Использование обобщенных функциональных интерфейсов
·􀃔 Захват переменных в лямбда-выражениях
& Генерация исключений в лямбда-выражениях
􀃕 Ссылки на методы
􀃖 Ссылки на конструкторы
􀃗 Стандартные функциональные интерфейсы, определенные в пакете
java.util.function
в ыпуск JDK 8 дополнил Java новым средством - лямбда-выражениями, значительно
усилившим выразительные возможности языка. Лямбда-выражения не только вводят
в язык новый синтаксис, но и упрощают реализацию некоторых часто используемых
конструкций. Подобно тому как введение обобщенных типов несколько лет тому назад
оказало значительное мияние на дальнейшее развитие Java, лямбда-выражения формируют
сегодняшний облик Java. Их роль в развитии языка Java действительно весьма существенна.
Кроме того, лямбда-выражения катализировали разработку других новых возможностей
Java. Об одной из них - методах интерфейсов по умолчанию - шла речь в главе 8.
Эта возможность позволяет добамять неабстрактные реализации методов в интерфейсы
с помощью ключевого слова default. В качестве другого примера можно привести возможность
использования ссылок на методы без выполнения последних. В целом введение
лямбда-выражений существенно расширило возможности Java API.
Помимо непосредственной пользы, которую приносит использование лямбда-выражений,
существует еще одна причина, делающая столь важной их поддержку в Java. За
последние несколько лет лямбда-выражения стали важным элементом проектирования
компьютерных языков. Соответствующий синтаксис включен, например, в такие языки,
как С# и С++. Поэтому не последним фактором, диктовавшим необходимость включения
лямбда-выражений в Java, было стремление утвердить программистов во мнении,
что Java - живой, развивающийся язык, возможности которого постоянно обномяются.
Данная глава посвящена обсуждению этой умекательной темы.
Введение в лямбда-выражения
Ключом к пониманию лямбда-выражений служат две конструкции. Во-первых, это
само лямбда-выражение, во-вторых - функциональный интерфейс. Начнем с определений
каждого из этих понятий.
Глава 14. Лямбда-выражения и ссылки на методы 505
Лямбда-выражение - это, по сути, анонимный (т.е. неименованный) метод. Однако
сам этот метод никогда не выполняется. Он лишь позволяет назначить реализацию кода
метода, определяемого функциональным интерфейсом. Таким образом, лямбда-выражение
представляет собой некую форму анонимного класса. Другой часто употребляемый
эквивалентный термин в отношении лямбда-выражений - замыкание.
Функциональный интерфейс - это интерфейс, который содержит один и только один
абстрактный метод. Обычно такой метод определяет предполагаемое назначение интерфейса.
Таким образом, функциональный интерфейс представляет, как правило, какое-то
одно действие. Например, стандартный интерфейс RunnaЫe является функциональным
интерфейсом, поскольку в нем указан только один метод - run () , которым и определяется
назначение интерфейса. Помимо этого, функциональный интерфейс определяет
целевой тип лямбда-выражения. Здесь следует сделать одно важное замечание:
лямбда-выражение может использоваться только в том контексте, в котором определен
целевой тип. Стоит также отметить, что о функциональных интерфейсах иногда говорят
как об интерфейсах типа SАМ, где SАМ - сокращение от Single Abstract Method (одиночный
абстрактный метод).
Рассмотрим лямбда-выражения и функциональные интерфейсы более подробно.
ПРИМЕЧАНИЕ
Функциональный интерфейс тal()l(e может включать любой открытый метод, определенный в классе
Object, например метод equals (), не лишаясь при этом статуса функционального интерфейса.
Открытые методы класса Object считаются неявными членами функциональных интерфейсов,
поскольку они автоматически реализуются экземплярами таких интерфейсов.
Основные сведения о лямбда-выражениях
Лямбда-выражения вводят в язык Java новый синтаксис. В них используется новый
лямбда-оператор-> (другое название - оператор стрелка). Этот оператор разделяет
лямбда-выражение на две части. В левой части указываются параметры, если этого
требует лямбда-выражение, а в правой - тело лямбда-выражения, которое описывает
действия, выполняемые лямбда-выражением. В Java поддерживаются две разновидности
тел лямбда-выражений. Тело одиночного лямбда-выражения состоит из одного выражения,
тело блочного - из блока кода. Мы начнем с рассмотрения лямбда-конструкций,
определяющих одиночное выражение.
Прежде чем двигаться дальше, вам будет полезно ознакомиться с несколькими конкретными
примерами лямбда-выражений. Приведенное ниже лямбда-выражение является,
вероятно, самым простым из тех, которые вы можете использовать. Оно вычисляет
постоянное значение:
() -> 98.6
Это лямбда-выражение не принимает параметров, поэтому список параметров пуст.
Подразумевается, что возвращаемым типом является douЫe. Таким образом, данное
выражение эквивалентно следующему методу:
douЫe myMeth () { return 98. 6; }
Разумеется, метод, определяемый лямбда-выражением, не обладает именем.
Ниже приведен несколько более интересный пример лямбда-выражения.
() -> Math.random() * 100
506 Java 8: руководство для начинающих. 6-е издание
Данное лямбда-выражение получает псевдослучайное значение с помощью метода
Math. random (}, умножает его на 100 и возвращает результат. Оно также не требует параметров.
В случае лямбда-выражения, принимающего параметр, он указывается в списке параметров
слева от лямбда оператора:
(n) -> 1.0 / n;
Это лямбда-выражение возвращает результат, представляющий собой обратное значение
параметра n. Таким образом, если n равно 4. О, то будет возвращено значение
О. 25. Несмотря на то что тип параметра (в данном примере параметра n) можно указывать
явно, этого часто можно не делать, если он легко устанавливается из контекста. Как
и в случае именованных методов, в лямбда-выражении можно указывать любое необходимое
количество параметров.
В качестве возвращаемого типа лямбда-выражения может использоваться любой
действительный тип. Например, следующее лямбда-выражение возвращает значение
true в случае четного значения параметра n и false - в случае нечетного:
(n) -> (n % 2)==0;
Таким образом, возвращаемым типом данного лямбда-выражения является boolean.
Учтите также следующее. Если в лямбда-выражении имеется всего лишь один параметр,
заключать его в скобки в левой части лямбда-оператора необязательно. Например,
приведенная ниже форма записи лямбда-выражения является совершенно правильной.
n -> (n % 2)==0;
Чтобы избежать возможных разночтений, в данной книге списки параметров заключены
в кавычки во всех лямбда-выражениях, включая и те, которые имеют только один
параметр. Конечно же, в подобных случаях вы вправе придерживаться того стиля записи
лямбда-выражений, который вам удобнее.
Функциональные интерфейсы
Ранее уже отмечалось, что функциональный интерфейс должен определять ровно
один абстрактный метод. Прежде чем мы продолжим, вспомните, что не все методы интерфейса
должны быть абстрактными (см. главу 8). Начиная с JDK 8 допускается, чтобы
интерфейс имел один или несколько методов, используемых по умолчанию. Методы по
умолчанию не являются абстрактными. Не являются таковыми и статические методы.
Метод интерфейса является абстрактным лишь в том случае, если он не определяет никакой
реализации. Отсюда следует, что функциональный интерфейс может иметь методы
по умолчанию и статические методы, но в любом случае он должен иметь один и только
один абстрактный метод. Поскольку любой метод интерфейса, не определенный явно как
метод по умолчанию или статический, считается абстрактным, в использовании модификатора
static нет необходимости (хотя вы можете использовать его, если пожелаете).
Вот пример функционального интерфейса.
interface MyValue {
douЫe getValue();
В данном случае метод getValue () неявно задан как абстрактный и является единственным
методом, определяемым интерфейсом MyValue. Следовательно, MyValue -
функциональный интерфейс, и его функция определена как getValue ().
Глава 14. Лямбда-выражения и ссылки на методы 507
Ранее уже отмечалось, что лямбда-выражения сами по себе не выполняются. Они
формируют реализацию абстрактного метода, определяемого функциональным интерфейсом,
который задает свой целевой тип. Как следствие, лямбда-выражение может
быть задано лишь в том контексте, в котором определен целевой тип. Один из таких
контекстов создается при присвоении лямбда-выражения ссылке на функциональный
интерфейс. К числу других контекстов целевого типа относятся, в частности, инициализация
переменной, инструкция return и аргументы метода.
Обратимся к простому примеру. Прежде всего объявляется ссылка на функциональный
интерфейс MyValue.
// Создать ссылку на экземпляр MyValue
MyValue myVal;
Затем этой ссылке на интерфейс назначается лямбда-выражение.
// Использовать лямбда-выражение в контексте присваивания
myVal = () -> 98.6;
Данное лямбда-выражение согласуется с объявлением getValue (), поскольку, подобно
getValue (), оно не имеет параметров и возвращает результат типа douЫe. Вообще
говоря, тип абстрактного метода, определяемого функциональным интерфейсом,
должен быть совместимым с типом лямбда-выражения. Невыполнение этого условия
вызовет ошибку на стадии компиляции.
Как вы, вероятно, уже догадались, при желании оба предьщущих шага можно объединить
в одну инструкцию:
MyValue myVal = () -> 98.6;
где переменная rnyVal инициализируется лямбда-выражением.
Когда лямбда-выражение встречается в контексте целевого типа, автоматически
создается экземпляр класса, который реализует функциональный интерфейс, причем
лямбда-выражение определяет поведение абстрактного метода, объявленного функциональным
интерфейсом. Вызов этого метода через целевой тип приводит к выполнению
лямбда-выражения. Таким образом, лямбда-выражение выступает в роли средства, позволяющего
преобразовать сегмент кода в объект.
В предыдущем примере реализация метода getValue () обеспечивается лямбда-выражением.
Следовательно, в результате выполнения приведенного ниже кода отобразится
значение 98. 6.
// Вызвать метод getValue(), реализованный ранее присвоенным
// лямбда-выражением.
// Лямбда-выражение
System.out.println("Пocтoяннoe значение: " + myVal.getValue());
Поскольку лямбда-выражение, назначенное переменной rnyVal, возвращает значение
98. 6, это же значение будет получено и при вызове метода getValue ().
Если лямбда-выражение принимает параметры, абстрактный метод функционального
интерфейса также должен принимать такое же количество параметров. Рассмотрим,
например, функциональный интерфейс MyPararnValue, позволяющий передавать значение
методу getValue ().
interface MyParamValue {
douЫe getValue(douЫe v);
508 Java 8: руководство для начинающих, 6-е издание
Этот интерфейс можно использовать DЛЯ реализации лямбда-выражения, вычисляющего
обратную величину, которое приводилось в предыдущем разделе. Например:
MyParamValue myPval = (n) -> 1.0 / n;
В дальнейшем переменную rnyPval можно использовать, например, так:
System.out.println("Знaчeниe, обратное значению 4, равно " +
myPval.getValue(4.0));
Здесь метод getValue () реализован с помощью лямбда-выражения, доступного через
переменную rnyPval, и это выражение возвращает значение, обратное значению аргумента.
В данном случае методу getValue () передается значение 4. О, а возвращается
значение О. 25.
В предьщущем примере есть еще нечто, заслуживающее интереса. Обратите внимание
на то, что тип параметра n не определен. Заключение о нем делается на основании
контекста. В данном случае это тип douЫe, о чем можно судить по типу параметра
метода getValue (), определяемого интерфейсом MyPararnValue, каковым является тип
douЫe. Возможно также явное указание типа параметра в лямбда-выражении. Например,
предыдущее выражение можно было бы записать в следующем виде:
(douЫe n) -> 1.0 / n;
где DЛЯ n явно указан тип douЫe. Обычно необходимость в явном указании типов параметров
не возникает.
Прежде чем двигаться дальше, важно обратить внимание на следующий момент:
чтобы лямбда-выражение можно было использовать в контексте целевого типа, типы
абстрактного метода и лямбда-выражения должны быть совместимыми. Так, если в абстрактном
методе указаны два параметра типа int, то в лямбда-выражении также должны
быть указаны два параметра, типы которых либо явно определены как int, либо
могут неявно следовать из контекста. В общем случае типы и количество параметров
лямбда-выражения должны быть совместимыми с параметрами и возвращаемым типом
метода.
Применение лямбда-выражений
Теперь, когда мы достаточно подробно обсудили свойства лямбда-выражений, рассмотрим
конкретные примеры их применения. В первом из них отдельные фрагменты,
представленные в предыдущем разделе, собираются в завершенную программу, с которой
вы сможете экспериментировать.
// Демонстрация двух простых лямбда-выражений.
// Функциональный интерфейс
interface MyValue {
douЫe getValue();
// Еще один функциональный интерфейс
interface MyParamValue {
douЫe getValue(douЫe v);
1---- Функцноноnьные интерфейсы
class LamЬdaDemo {
Глава 14. Лямбда-выражения и ссылки на методы 509
puЫic static void main(String args[])
{
MyValue myVal; // объявление ссылки на интерфейс
// Здесь лямбда-выражение - это просто константа.
// При его назначении переменной myVal создается
// экземпляр класса, в котором лямбда-выражение
// реализует метод getValue() интерфейса MyValue.
myVal = () -> 98. 6; Простое nямбдо-вwроженне
// Вызвать метод getValue(), предоставляемый ранее
// назначенным лямбда-выражением.
System.out.println("Пocтoяннoe значение: " +
myVal.getValue());
// Создать параметризованное лямбда-выражение и назначить его
// ссылке на экземпляр MyParamValue. Это лямбда-выражение
// возвращает обратную величину своего аргумента.
MyParamValue myPval = (n) -> 1.0 / n; Лямбдо-вwроженне,нмеющееnорометр
// Вызвать метод getValue(v) посредством ссылки myPval.
System.out.println("Oбpaтнaя величина 4 равна " +
myPval.getValue(4.0));
System.out.println("Oбpaтнaя величина 8 равна " +
myPval.getValue(8.0));
// лямбда-выражение должно быть совместимым с методом,
// который определяется функциональным интерфейсом. Поэтому
// приведенные ниже два фрагмента кода не будут работать.
// myVal = () -> "three"; // Ошибка! Тип String несовместим
// с типом douЬle!
// myPval = () -> Math.random(); // Ошибка! Требуется параметр!
Данная программа выводит следующую информацию.
Постоянное значение: 98.6
Обратная величина 4 равна 0.25
Обратная величина 8 равна 0.125
Как ранее уже упоминалось, лямбда-выражение должно быть совместимым с абстрактным
методом, который вы IUiанируете реализовать. Поэтому в приведенной ниже
программе последние, "закомментированные" строки кода недопустимы. Первая из
них - из-за несовместимости типа String с типом douЫe, т.е. возвращаемым типом
метода getValue (), вторая - из-за того, что метод getValue (douЫe v) интерфейса
MyParamValue требует параметра, а он не предоставлен.
Важнейшим свойством функционального интерфейса является то, что его можно использовать
с любым совместимым с ним лямбда-выражением. В качестве примера рассмотрим
программу, определяющую функциональный интерфейс NumericTest, в котором
объявляется абстрактный метод test (). Этот метод имеет два параметра типа int,
возвращает результат типа boolean и предназначен для проверки того, что передаваемые
51 О Java 8: руководство для начинающих. 6-е издание
ему аргументы удовлетворяют определенному условию. Результат проверки возвращается
в виде булевою значения. В методе main () с помощью лямбда-выражений создаются
три теста. В первом из них проверяется, делится ли первый аргумент на второй без
остатка, во втором - меньше ли первый аргумент, чем второй, а третий тест возвращает
значение true в случае равенства абсолютных величин обоих аргументов. Обратите внимание
на то, что каждое из лямбда-выражений, реализующих эти тесты, имеет два параметра
и возвращает результат типа boolean. Конечно же, это является обязательным
требованием и обусловлено тем, что метод test () имеет два параметра и возвращает
результат типа boolean.
// Использование одного и того же функционального интерфейса
//с тремя различными лямбда-выражениями.
// Функциональный интерфейс принимает два параметра типа iпt и
// возвращает результат типа boolean.
iпterface NumericTest {
boolean test(int n, int m);
class LamЬdaDemo2 {
puЫic static void main(String args[J)
{
// Данное лямбда-выражение проверяет, кратно ли одно число другому
NumericTest isFactor = (n, d) -> (n % d) == О;
if(isFactor.test(lO, 2))
System.out.println("2 является делителем 10");
if(!isFactor.test(lO, 3))
System.out.println("З не является делителем 10");
System.out.println();
// Данное лямбда-выражение возвращает true, если
// первый аргумент меньше второго
NumericTest lessThan = (n, m) -> (n < m);
Исnоnьэуется один
--------+-и тот же интерфейс
с тремя раэnнчнwмн
nямбда-вwражениями
if (lessThan. test (2, 10))
System.out.println("2 меньше 10");
if(!lessThan.test(lO, 2))
System.out.println("lO не меньше 2");
System.out.println();
// Данное лямбда-выражение возвращает true, если оба
// аргумента равны по абсолютной величине
NumericTest absEqual = (n, m) -> (n <О? -n : n) == (m <О? -m m);
if(absEqual.test(4, -4))
System.out.println("Aбcoлютныe величины 4 и -4 равны");
if(!lessThan.test(4, -5))
System.out.println("Aбcoлютныe величины 4 и -5 не равны");
System.out.println();
Глава 14. Лямбда-выражения и ссылки на методы 5] 1
Данная программа выводит следующую информацию.
2 является делителем 10
З не является делителем 10
2 меньше 10
10 не меньше 2
Абсолютные величины 4 и -4 равны
Абсолютные величины 4 и -5 не равны
Как видите, поскольку все три лямбда-выражения совместимы с методом test (),
все они могли быть выполнены с использованием ссылок типа NumericTest. В действительности
в использовании трех отдельных переменных дЛЯ хранения соответствующих
ссылок не было необходимости, поскольку во всех трех тестах можно бьuю использовать
одну и ту же переменную. Например, можно было создать переменную myTest и использовать
ее поочередно в каждом из тестов.
NumericTest myTest;
myTest = (n, d) -> (n % d) == О;
if(myTest.test(lO, 2))
System.out.println("2 является делителем 10");
// . . .
myTest = (n, m) -> (n < m);
if(myTest.test(2, 10))
System.out.println("2 меньше 10");
// . . .
myTest = (n, m) -> (n <О? -n n) == (m <О? -m : m);
if(myTest.test(4, -4))
System.out.println("Aбcoлютныe величины 4 and -4 равны");
//
Преимуществом использования различных ссылочных переменных с именами
isFactor, lessThan и absEqual, как это было сделано в первоначальном варианте программы,
является то, что при этом сразу становится ясно, на какое именно лямбда-выражение
ссылается переменная.
С рассмотренной только что программой связан еще один интересный момент. Обратите
внимание на то, как в ней задаются параметры лямбда-выражений. Взгляните,
например, на выражение, с помощью которого проверяется кратность двух чисел:
(n, d) -> (n % d) == О
Заметьте, что параметры n и d разделены запятой. В общем случае, когда требуется
указать несколько параметров, они указываются в левой части лямбда-оператора в виде
списка с использованием запятой в качестве разделителя.
В предыдущих примерах в качестве параметров и возвращаемых значений абстрактных
методов, определяемых функциональными интерфейсами, использовались простые
типы значений, однако на этот счет не существует ограничений. Ниже приведен пример
программы, в которой объявляется функциональный интерфейс StringTest с абстрактным
методом test (), принимающим два параметра типа String и возвращающим результат
типа boolean. Следовательно, этот интерфейс может быть использован дЛЯ тестирования
некоторых условий, связанных со строками. В данной программе создается
лямбда-выражение, позволяющее определить, содержится ли одна строка в другой.
512 Java 8: руководство для начинающих. 6-е издание
// Функциональный интерфейс, тестирующий две строки
interface StringTest {
boolean test(String aStr, String bStr);
class LambdaDemoЗ {
puЫic static void main(String args[J)
{
// Данное лямбда-выражение определяет, является ли
// одна строка частью другой
StringTest isin = (а, Ь) -> a.indexOf(b) != -1;
String str = "Это тест";
System.out.println("Tecтиpyeмaя строка: " + str);
if (isin. test (str, "Это"))
System.out.println("'Этo' найдено");
else
System.out.println('"Этo' не найдено");
if (isin. test (str, "xyz"))
System.out.println("'xyz' найдено");
else
System.out.println("'xyz' не найдено");
Данная программа выводит следующую информацию.
Тестируемая строка: Это тест
'Это' найдено
'xyz' не найдено
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Ранее вы говорили о том, что в случае необходимости тип параметра
лямбда-выражения можно указать в явном виде. Как быть в тех случаях, когда
в лямбда-выражении имеется несколько параметров? Следует ли указывать
типы всех без исключения параметров или можно предоставить компилятору
возможность самостоятельно определить тип одного или нескольких из них?
ОТВЕТ. В тех случаях, когда требуется явное указание типа одного из параметров,
типы всех остальных параметров в списке также должны быть указаны в явном
виде. Например, ниже приведена допустимая форма записи лямбда-выражения:
(int n, int d) -> (n % d) == О
А вот пример недопустимой формы записи лямбда-выражения:
(int n, d) -> (n % d) == О
Недопустимым является также следующее выражение:
(n, int d) -> (n % d) == О
Глава 14. Лямбда-выражения и ссылки на методы 51 З
Обратите внимание на то, что для определения вхождения одной строки в другую в
лямбда-выражении используется метод indexOf (), определенный в классе String. Это
работает, поскольку тип параметров а и Ь автоматически устанавливается компилятором
из контекста как String. Таким образом, вызов метода класса String для параметра а
является вполне допустимым.
Блочные лямбда-выражения
В предыдущих примерах тело каждого лямбда-выражения представляло собой одиночное
выражение. В подобных случаях говорят об одиночном (или строчном) лямбда-выражении
(иногда употребляют также термин выражение-лямбда). Код с правой стороны
лямбда-оператора в лямбда-выражениях этого типа должен состоять всего лишь из одного
выражения, значение которого становится значением лямбды. Несмотря на несомненную
полезность выражений-лямбд, встречаются ситуации, в которых одного выражения
оказывается недостаточно. Чтобы можно было справляться с такими ситуациями,
в Java поддерживается другая разновидность лямбда-выражений, в которых код с правой
стороны лямбда-оператора, представляющий тело лямбды, может содержать несколько
инструкций, записанных в виде блока кода. Лямбда-выражения с таким блочным телом
называют блочными лямбда-выражениями.
Введение блочных лямбда-выражений, допускающих включение нескольких инструкций
в тело лямбды, позволило расширить круr возможных операций. Например,
в блочных лямбда-выражениях можно объявлять переменные, использовать циклы и
такие операторы, как if и switch, создавать вложенные блоки и т.п. Создание блочного
лямбда-выражение не составляет особого труда. Для этого достаточно заключить
тело выражения в фигурные скобки, как это делается в случае обычных блоков инструкций.
За исключением тоrо, что их тело состоит из нескольких инструкций, блочные
лямбда-выражения используются в основном точно так же, как одиночные. Единственное
существенное отличие заключается в том, что для возврата значений в блочных
лямбда-выражениях необходимо явно использовать инструкцию return. Это приходится
делать, поскольку тело блочной лямбды содержит ряд выражений, а не одно.
Обратимся к примеру, в котором блочное лямбда-выражение используется для поиска
наименьшего положительного делителя заданного целого числа. Мы будем использовать
интерфейс NwnericFunc с методом func () , который принимает один аргумент типа
int и возвращает результат типа int.
// Блочное лямбда-выражение, предназначенное для нахождения
// наименьшего положительного делителя заданного целого числа
interface NumericFunc
int func(int n);
class BlockLamЬdaDemo {
puЫic static void main(String args[])
{
// Данное блочное лямбда-выражение возвращает наименьший
// положительный делитель заданного целого числа
514 Java 8: руководство для начинающих. 6-е издание
NumericFunc smallestF = (n) -> {
int result = 1;
} ;
// Get absolute value of n.
n = n <О? -n : n;
for(int i=2; i <= n/i; i++)
if((n %i) О){
result i;
break;
return result;
1----- Блочное лямбда-выражение
System.out.println("Haимeньшим делителем 12 является " +
smallestF.func(12));
System.out.println("Haимeньшим делителем 11 является " +
smallestF.func(ll));
Данная программа выводит следующую информацию.
Наименьшим делителем 12 является 2
Наименьшим делителем 11 является 1
Обратите внимание на то, что в данном блочном лямбда-выражении объявляется
переменная result, используется цикл for и осуществляется возврат по инструкции
return. В лямбда-выражениях блочного типа это вполне допустимо. По сути, блочное
тело лямбды аналогично телу метода. И еще одно замечание: когда в лямбда-выражении
встречается инструкция return, она приводит к возврату из лямбда-выражения, но не
из метода, в котором она содержится.
Обобщенные функциональные интерфейсы
Само лямбда-выражение не может определять типы параметров. Следовательно,
лямбда-выражение не может быть обобщенным. (Разумеется, с учетом возможности выведения
типов все лямбда-выражения могут считаться в некоторой степени обобщенными.)
Однако функциональный интерфейс, связанный с лямбда-выражением, может
быть обобщенным. В подобных случаях целевой тип лямбда-выражения отчасти определяется
типами аргумента или аргументов, указываемыми при объявлении ссылки на
функциональный интерфейс.
Попытаемся проанализировать, в чем состоит ценность обобщенных функциональных
интерфейсов. Ранее мы создали два различных интерфейса: NumericTest и
StringTest. Они использовались для того, чтобы определить, удовлетворяют ли два заданных
значения определенным условиям. С этой целью в каждом из интерфейсов определялся
свой метод test (), принимающий два параметра и возвращающий результат
типа boolean. В случае интерфейса NumericTest тестируемыми значениями являются
целые числа, а в случае интерфейса StringTest - строки. Таким образом, единственное,
чем различаются оба метода, так это типом данных, которыми они оперируют. Такая
Глава 14. Лямбда-выражения и ссылки на методы 515
ситуация идеальна для применения обобщенных типов. Вместо двух функциональных
интерфейсов, методы которых отличаются лишь используемыми типами данных, можно
объявить один обобщенный интерфейс, пригодный для использования в обоих случаях.
Продемонстрируем этот подход на примере приведенной ниже программы.
!/ Использование обобщенного функционального интерфейса.
// Обобщенный функциональный интерфейс с двумя параметрами,
// который возвращает результат типа boolean
interface SomeTest<T> { Обобщеннwн функционаnьнwн инrерфенс
boolean test(T n, Т m);
class GenericFunctionalinterfaceDemo {
puЫic static void main(String args[])
{
// Данное лямбда-выражение определяет, является ли
// одно целое число делителем другого
SomeTest<Integer> isFactor = (n, d) -> (n % d) == О;
if{isFactor.test(lO, 2))
System.out.println("2 является делителем 10");
System.out.println();
// Данное лямбда-выражение определяет, является ли
// одно число типа DouЫe делителем другого
SomeTest<DouЫe> isFactorD = (n, d) -> (n % d) == О;
if(isFactorD.test(212.0, 4.0))
System.out.println("4.0 является делителем 212.0");
System.out.println();
// Данное лямбда-выражение определяет, является ли
// одна строка частью другой
SomeTest<String> isin = (а, Ь) -> a.indexOf(b) != -1;
String str = "Обобщенный функциональный интерфейс";
System.out.println("Tecтиpyeмaя строка: " + str);
if(isin.test(str, "face"))
System.out.println("'face' найдено");
else
System.out.println("'face' не найдено");
Данная программа выводит следующую информацию.
2 является делителем 10
4.0 является делителем 212.0
Тестируемая строка: Обобщенный функциональный интерфейс
'face' найдено
516 Java 8: руководство для начинающих. 6-е издание
Обобщенный функциональный интерфейс SomeTest объявлен в программе следующим
образом.
interface SomeTest<T>
boolean test(T n, Т m);
Здесь т определяет тип обоих параметров метода test ( ) . Это означает, что данный
интерфейс совместим с любым лямбда-выражением, принимающим два параметра того
же типа и возвращающим результат типа boolean.
Интерфейс S o meTes t используется для предоставления ссылок на три типа
лямбда-выражений. В первом из них используется тип Integer, во втором - тип
DouЫe, в третьем - тип String. Это позволило использовать один и тот же функциональный
интерфейс дЛЯ ссылок на лямбда-выражения isFactor, isFactorD и isin. Различаются
эти три случая лишь типом аргумента, передаваемого экземпляру SomeTest.
Следует отметить, что интерфейс NumericTest, рассмотренный в предыдущем разделе,
также может быть переписан в виде обобщенного интерфейса, на чем построено
упражнение дЛЯ самопроверки, приведенное в конце главы.
Упражнение 14. 1 Передача лямбда-выражения
в качестве аргумента
, .................................................................. ,
Лямбда-выражения можно использовать в любом кон:
LamЬdaArgumentDemo. java
, .................................................................. , тексте, предоставляющем целевой тип. В предыдущих
примерах использовались целевые контексты присваивания и инициализации. Примером
контекста другого типа может служить передача лямбда-выражения методу в качестве
аргумента. В действительности именно этот контекст является обычным способом
использования лямбда-выражений, значительно усиливающим выразительность языка
Java.
Проиллюстрируем этот процесс на примере проекта, в котором создаются три строковые
функции, с помощью которых выполняются следующие операции: обращение
строки, обращение регистра букв в пределах строки и замена пробелов дефисами.
В проекте эти функции реализуются в виде лямбда-выражений функционального интерфейса
StringFunc. Каждая из функций поочередно передается методу changeStr ()
в качестве первого аргумента. Метод changeStr () применяет полученную строковую
функцию к строке, которая задается вторым аргументом, и возвращает результат. Такой
подход обеспечивает возможность применения целого ряда различных строковых функций
посредством единственного метода changeStr (). Поэтапное описание процесса
создания программы приведено ниже.
1. Создайте файл LamЬdaArgumentDemo. java.
2. Добавьте в файл функциональный интерфейс StringFunc.
interface StringFunc
String func(String str);
Данный интерфейс определяет метод func () , который принимает аргумент типа
String и возвращает результат типа String. Таким образом, метод func () может
воздействовать на строку и возвращать результат.
Глава 14. Лямбда-выражения и ссылки на методы 517
3. Начните создавать класс LarnbdaArgurnentDerno , определив в нем метод
changeStr ().
class LamЬdaArgumentDemo
// В данном методе типом первого параметра является
// функциональный интерфейс. Следовательно, ему можно передать
// ссылку на любой экземпляр этого интерфейса, в том числе и на
// экземпляр, созданный посредством лямбда-выражения. С помощью
// второго параметра задается строка, подлежащая обработке.
static String changeStr(StringFunc sf, String s) {
return sf.func(s);
Как указано в комментариях, метод changeStr () имеет два параметра. Тип первого
из них - StringFunc. Это означает, что методу может быть передана ссылка
на любой экземпляр интерфейса StringFunc, в том числе и на экземпляр, созданный
с помощью лямбда-выражения, совместимого с интерфейсом StringFunc.
Строка, подлежащая обработке, передается с помощью параметра s. Возвращаемым
значением является обработанная строка.
4. Начните создавать метод rnain ().
puЬlic static void main(String args[])
{
String inStr = "Лямбда-выражения расширяют Java";
String outStr;
System.out.println("Bxoднaя строка: " + inStr);
Здесь inStr - ссылка на строку, подлежащую обработке, а outStr получает измененную
строку.
5. Определите лямбда-выражение, располагающее символы строки в обратном порядке,
и присвойте его ссьmке на экземпляр StringFunc. Заметьте, что оно представляет
собой еще один пример блочного лямбда-выражения.
// Определите лямбда-выражение, располагающее содержимое
// строки в обратном порядке, и присвойте его переменной,
// ссылающейся на экземпляр StringFunc
StringFunc reverse = (str) -> {
String result = "";
for(int i = str.length()-1; i >= О; i--)
result += str.charAt(i);
return result;
};
6. Вызовите метод changeStr () , передав ему лямбду reverse и строку inStr. Присвойте
результат переменной outStr и отобразите его.
// Передайте reverse методу changeStr() в качестве
// первого аргумента.
// Передайте входную строку в качестве второго аргумента.
outStr = changeStr(reverse, inStr);
System.out.println("Oбpaщeннaя строка: " + outStr);
518 Java 8: руководство для начинающих. 6-е издание
Мы можем передать лямбду reverse методу changeStr (), поскольку его первый
параметр имеет тип StringFunc. Вспомните, что в результате использования
лямбда-выражения создается экземпляр целевого типа, каковым в данном случае
является StringFunc. Таким образом, лямбда-выражение обеспечивает эффективную
передачу кода методу.
7. Завершите создание программы, добавив лямбда-выражения, заменяющие пробелы
дефисами и обращающие регистр букв, как показано ниже. Заметьте, что обе
лямбды непосредственно встраиваются в вызовы метода changeStr () , тем самым
избавляя нас от необходимости использовать для этого отдельные переменные
типа StringFunc.
// Данное лямбда-выражение заменяет пробелы дефисами.
// Оно внедряется непосредственно в вызов метода changeStr().
outStr = changeStr((str) -> str.replace(' ', '-'), inStr);
System.out.println("Cтpoкa с замененными пробелами: " +
outStr);
// Данное блочное лямбда-выражение обращает регистр
!! букв в строке. Оно также внедряется непосредственно
/! в вызов метода changeStr().
outStr = changeStr((str) -> (
String result "";
char ch;
for(int i = О; i < str.length(); i ++) (
ch = str.charAt(i);
if(Character.isUpperCase(ch))
result += Character.toLowerCase(ch);
else
result += Character.toUpperCase(ch);
return result;
} , inStr);
System.out.println("Cтpoкa с обращенным регистром букв: " +
outStr);
Как видно из приведенного выше кода, внедрение лямбда-выражения, заменяющего
пробелы на дефисы, непосредственно в вызов метода changeStr () не
только уменьшает размер кода, но и облегчает его понимание. Это обусловлено
простотой самого лямбда-выражения, которое содержит лишь вызов метода
replace (), осуществляющего требуемую замену символов. Метод replace ()
определен в классе String. Используемая здесь версия этого метода принимает
в качестве аргументов заменяемый и подставляемый символы и возвращает измененную
строку.
В то же время непосредственное внедрение лямбда-выражения, обращающего
регистр букв в строке, в вызов метода changeString () использовано здесь
исключительно в иллюстративных целях. В данном случае это породило скорее
неуклюжий код, разбираться в котором довольно трудно. Обычно такие
Глава 14. Лямбда-выражения и ссылки на методы 519
лямбда-выражения лучше передавать методу посредством использования отдельных
переменных (как это было сделано при обращении порядка следования
символов в строке). Но с технической точки зрения непосредственная передача
лямбда-выражений методу, использованная в данном примере, также корректна.
Следует также обратить ваше внимание на то, что в лямбда-выражении, меняющем
регистр букв на противоположный, используются статические методы
isUpperCase (), toUpperCase () и toLowerCase (), определенные в классе
Character. Вспомните, что класс Character служит оболочкой для типа char.
Метод isUpperCase () возвращает значение true, если переданный ему аргумент
представляет собой букву в верхнем регистре, и значение false в противном
случае. Методы toUpperCase () и toLowerCase () устанавливают для букв соответственно
верхний и нижний регистры и возврашают результат. Кроме этих методов,
в классе Character определен ряд других методов, предназначенных для
манипулирования символами и их тестирования. Более подробно об этом вы можете
узнать самостоятельно из других источников.
8. Ниже приведен полный код программы в законченном виде.
// Использование лямбда-выражения в качестве аргумента метода
interface StringFunc
String func(String str);
class LamЬdaArgumentDemo {
// В данном методе типом первого параметра является
// функциональный интерфейс. Это позволяет передать методу ссылку
// на любой экземпляр данного интерфейса, в том числе на экземпляр,
// созданный посредством лямбда-выражения. С помощью второго
// параметра задается строка, подлежащая обработке.
static String changeStr(StringFunc sf, String s) {
return sf.func{s);
puЫic static void main{String args[])
{
String inStr = "Лямбда-выражения расширяют Java";
String outStr;
System.out.println("Bxoднaя строка: " + inStr);
// Определите лямбда-выражение, располагающее содержимое
// строки в обратном порядке, и присвойте его переменной,
// ссылающейся на экземпляр StringFunc.
StringFunc reverse = (str) -> {
String result = "";
} ;
for(int i = str.length()-1; i >= О; i--)
result += str.charAt(i);
return result;
520 Java 8: руководство для начинающих, 6-е издание
// Передайте reverse методу changeStr{) в качестве
// первого аргумента.
// Передайте входную строку в качестве второго аргумента.
outStr = changeStr{reverse, inStr);
System.out.println{ ce Oбpaщeннaя строка: се + outStr);
// Данное лямбда-выражение заменяет пробелы дефисами.
// Оно внедряется непосредственно в вызов метода changeStr{).
outStr = changeStr { {str) -> str. replace {' ', '-'), inStr);
System.out.println{ ce Cтpoкa с замененными пробелами: се + outStr);
// Данное блочное лямбда-выражение обращает регистр
// букв в строке. Оно также внедряется непосредственно
// в вызов метода changeStr{).
outStr = changeStr{{str) -> {
String result сесе;
char ch;
for{int i = О; i < str.length{); i++ ) {
ch = str.charAt{i);
if{Character.isUpperCase{ch))
result += Character.toLowerCase{ch);
else
result += Character.toUpperCase{ch);
return result;
} , inStr);
System.out.println{ ceCтpoкa с обращенным регистром букв: се +
outStr);
1
9. Данная программа выводит следующую информацию.
Входная строка: Лямбда-выражения расширяют Java
Обращенная строка: avaJ dnapxE snoisserpxE adbmaL
Строка с замененными пробелами: Лямбда-выражения-расширяют-Jаvа
Строка с обращенным регистром букв: lAМBDA eXPRESSIONS eXPAND jAVA
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Существуют ли для лямбда-выражений другие контексты целевого типа,
кроме контекстов инициализации, присваивания и передачи арrумента?
ОТВЕТ. Да, такие контексты существуют. Это операторы приведения типов, оператор
? , инициализатор массива, оператор return, а также сами лямбда-выражения.
Глава 14. Лямбда-выражения и ссылки на методы 521
Лямбда-выражения и захват переменных
Переменные, определенные в области действия лямбда-выражения, доступны этому
выражению. Например, лямбда-выражение может использовать переменную экземпляра
или статическую переменную, определенную в классе, содержащем данное выражение.
Лямбда-выражение также имеет доступ (как явный, так и неявный) к переменной this,
которая ссылается на экземпляр класса, вызывающий данное выражение. Поэтому
лямбда-выражение может получать и устанавливать значения переменных указанного
типа и вызывать метод, определенный в содержащем данное выражение классе.
Однако, если лямбда-выражение использует локальную переменную из охватывающей
области видимости, возникает особая ситуация - захват переменной. В подобных
случаях лямбда-выражение может использовать такую переменную, но так, как если бы
это была переменная типа final, значение которой не может быть изменено. Модификатор
final для такой переменной можно не указывать, но если вы его укажете, то это
не будет считаться ошибкой. (Параметр this, соответствующий охватывающей области
видимости, эффективно ведет себя как финальная переменная, а собственного аналога
переменной this лямбда-выражения не имеют.)
Важно понимать, что значение локальной переменной из охватывающей лямбда-выражение
области видимости не может быть изменено выражением, поскольку это противоречило
бы статусу неизменности такой переменной и сделало бы ее захват недопустимым.
Приведенная ниже программа иллюстрирует различие между переменными, которые
эффективно ведут себя как финальные в лямбда-выражении, и переменными, значение
которых может быть изменено.
// Пример захвата локальной переменной из охватывающей
// лямбда-выражение области видимости
interface MyFunc {
int func(int n);
class VarCapture {
puЫic static void main(String args[])
{
// локальная переменная, которая может быть захвачена
int num = 10;
MyFunc myLamЬda = (n) -> {
// Такое использование переменной num корректно, поскольку
// ее значения не изменяется
int v = num + n;
// Приведенная ниже инструкция некорректна,
// поскольку она изменяет значение переменной num
// num++;
return v;
} ;
// Использование лямбды. Эта инструкция отобразит число 18.
System.out.println(myLamЬda.func(8));
522 Java 8: руководство для начинающих. 6-е издание
// Приведенная ниже строка породила бы ошибку, поскольку она
// лишает num статуса финальной переменной
// num = 9;
}
Как указано в комментариях к выполняющейся части программы, переменная num
не изменяется и может быть использована в теле myLamЬda. Поэтому в результате выполнения
инструкции println () выводится число 18. При вызове func () с аргументом 8
значение v внутри лямбды устанавливается равным сумме num (значение 10) и значения,
переданного параметру n (которое равно 8). Следовательно, func () возвращает число
18. Этот механизм работает, поскольку переменная num не изменяет своего значения после
инициализации. Но если бы значение num было изменено - будь-то в лямбда-выражении
или вне его, - переменная num потеряла бы свой статус неизменной (final)
переменной . Это породило бы ошибку, препятствующую компиляции программы.
Важно подчеркнуть, что лямбда-выражение может использовать и изменять переменную
экземпляра класса, в котором оно содержится. Не допускается лишь использование
тех локальных переменных в области видимости, охватывающей лямбда-выражение,
значения которых подвергаются изменениям.
Генерация исключений в лямбда-выражениях
Лямбда-выражения могут генерировать исключения. Однако если генерируется проверяемое
исключение, то оно должно быть совместимым с исключениями, перечисленными
в операторе throws абстрактного метода, определяемого функциональным
интерфейсом. Например, если лямбда-выражение может генерировать исключение
IOException, то в упомянутом абстрактном методе функционального интерфейса исключение
IOException должно быть указано в операторе throws. В качестве примера
рассмотрим следующую программу.
import java.io.*;
interface MyIOAction
boolean ioAction(Reader rdr) throws IOException;
class LamЬdaExceptionDemo (
puЬlic static void main(String args[])
(
douЫe[] values = ( 1.0, 2.0, 3.0, 4.0 };
// Данное блочное лямбда-выражение может генерировать
// исключение IOException. Следовательно, это исключение
// должно быть указано в операторе throws метода
// ioAction() функционального интерфейса MyIOAction.
MyIOAction myIO = (rdr) -> { .--данноеnямбдо-аырожениеможетrенерировотьискnючение
int ch = rdr.read(); // может генерировать
// исключение IOException
// . . .
return true;
} ;
Глава 14. Лямбда-выражения и ссылки на методы 523
Поскольку вызов метода read ( ) может сопровождаться генерацией исключения
IOException, оно должно быть указано в операторе throws метода ioAction () функционального
интерфейса MyIOAction. Без этого программа не будет скомпилирована ввиду
несовместимости лямбда-выражения с методом ioAction (). Чтобы это проверить,
удалите оператор throws и попытайтесь скомпилировать программу. Вы увидите, что
компилятор выведет сообщение об ошибке.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Можно ли использовать в лямбда-выражении параметр в виде массива?
ОТВЕТ. Да, можно. Однако в тех случаях, когда тип параметра выводится компилятором,
способ указания параметра лямбда-выражения отличается от того,
который обычно принят для массивов: вместо общепринятого обозначения,
например n [], используется простое имя переменной - n. Не забывайте о том,
что тип параметра лямбда-выражения будет выводиться на основании целевого
контекста. Таким образом, если целевой контекст требует использования массива,
то в качестве типа параметра будет подразумеваться массив. Чтобы вам
было легче в этом разобраться, рассмотрим следующий короткий пример.
Ниже приведен обобщенный функциональный интерфейс MyTransform, который
может быть использован для применения некоторого преобразования к
элементам массива.
// Функциональный интерфейс
interface MyTransform<T> {
void transform(T[] а};
Заметьте, что параметром метода transform () является массив типа <Т>.
Создадим следующее лямбда-выражение, которое использует интерфейс
MyTransformдля преобразования элементов массива типа DouЫe в их квадратные
корни.
MyTransform<DouЫe> sqrts = (v} -> {
for(int i=O; i < v.length; i++} v[i] = Math.sqrt(v[i]};
} ;
Здесь типом параметра а метода transform (} является тип DouЫe [], поскольку
при объявлении лямбды sqrts для интерфейса MyТransform задан
тип DouЫe. Поэтому тип v в лямбда-выражении выводится как DouЫe [].
Использовать для этой цели запись v [] было бы не только излишне, но и неправильно.
И последнее замечание: параметр для лямбда-выражения вполне мог быть объявлен
как DouЫe [] , поскольку это просто означало бы явное объявление типа
параметра, исключающее необходимость его автоматического определения
компилятором. Однако в данном случае это не дает никакого выигрыша.
524 Java 8: руководство для начинающих. 6-е издание
Ссылки на методы
С лямбда-выражениями тесно связано одно важное средство - ссылки на методы.
Оно позволяет ссылаться на метод без его выполнения. Данное средство связано с
лямбда-выражениями, поскольку для него также требуется контекст целевого типа, состоящий
из совместимого функционального интерфейса. При вычислении ссылки на метод
также создается экземrurяр функционального интерфейса. Существует несколько разновидностей
ссылок на методы. Начнем с рассмотрения ссылок на статические методы.
Ссылки на статические методы
Ссылка на статический метод создается посредством указания имени метода, которому
предшествует имя класса, с использованием следующего общего синтаксиса:
имя_класса::имя_метода
Заметьте, что имена класса и метода разделены парой двоеточий. Символ : : - это
новый разделитель, специально добавленный в Java в выпуске JDK 8. Данная ссылка на
метод может использоваться везде, где она совместима с целевым типом.
Применение ссылок на статические методы продемонстрируем с помощью приведенной
ниже программы. Сначала в программе объявляется функциональный интерфейс
IntPredicate, имеющий метод test (). Этот метод принимает параметр типа
int и возвращает результат типа boolean. Метод предназначен для проверки того, что
заданное целое число удовлетворяет определенным условиям. Далее в программе создается
класс MyintPredicates, содержащий три статических метода - isPrime (),
isEven () и isPosi ti ve (), соответственно предназначенных для проверки того, что
число является простым, четным или положительным. В классе MethodRefDemo создается
метод numTest (), первым параметром которого является ссылка на IntPredicate.
С помощью второго параметра задается целое число, подлежащее тестированию. Описанные
три теста выполняются в методе main () посредством вызова метода numTest () ,
которому поочередно передаются ссылки на три вышеперечисленных тестовых метода.
!/ Демонстрация использования ссылок на статические методы.
// Функциональный интерфейс для числовых предикатов, которые
// воздействуют на целочисленные значения
interface IntPredicate {
boolean test(int n);
// Данный класс определяет три статических метода, которые
// проверяют соответствие целого числа определенным условиям
class MyintPredicates {
// Статический метод, который возвращает true, если
// заданное число простое
static boolean isPrime(int n)
if(n < 2) return false;
for(int i=2; i <= n/i; i++)
i f ( ( n % i ) == О)
return false;
Глава 14. Лямбда-выражения и ссылки на методы 525
return true;
!/ Статический метод, который возвращает true, если
// заданное число четное
static boolean isEven(int n) {
return (n % 2) == О;
// Статический метод, который возвращает true, если
// заданное число положительное
static boolean isPositive (int n) {
return n > О;
class MethodRefDemo {
// В данном методе типом первого параметра является
// функциональный интерфейс. Следовательно, ему можно передать
// ссылку на любой экземпляр этого интерфейса, в том числе и на
// экземпляр, созданный посредством ссылки на метод.
static boolean numTest(IntPredicate р, int v) {
return p.test(v);
puЫic static void main(String args[J)
{
boolean result;
// Здесь методу numTest() передается ссылка на метод isPrime()
result = numTest(MyintPredicates::isPrime, 17); 4
if(result) System.out.println("l7 - простое число");
// Здесь методу numTest() передается ссылка на метод isEven()
result = numTest(MyintPredicates: :isEven, 12); --------
if(result) System.out.println("12 - четное число");
Испоn􀀘зовонне
ССЫЛОК НО
стотнческне
методы
// Здесь методу numTest() передается ссылка на метод isPositive()
result = numTest(MyintPredicates::isPositive, 11);
if(result) System.out.println("ll - положительное число");
Данная программа выводит следующую информацию.
17 - простое число
12 - четное число
11 - положительное число
В этой программе особый интерес для нас представляет следующая строка:
result = numTest(MyintPredicates::isPrime, 17);
где методу numTest () в качестве первого аргумента передается ссылка на статический
метод isPrime (). Это можно было сделать, поскольку ссылка isPrime совместима с
526 Java 8: руководство для начинающих, 6-е издание
функциональным интерфейсом IntPredicate. Таким образом, вычисление выражения
MyintPredicates: : isPrirne дает ссылку на объект, метод isPrirne () которого предоставляет
реализацию метода test () интерфейса IntPredicate. Остальные два вызова
метода nurnTest () работают аналогичным образом.
Ссылки на методы экземпляров
Ссылка на метод экземпляра конкретного объекта создается посредством следующего
базового синтаксиса:
ссылка_ на_ объект: : имя_метода
Как видите, приведенный синтаксис аналогичен синтаксису для ссылок на статические
методы, только вместо имени класса используется объектная ссьmка. Следовательно,
фигурирующий здесь метод связывается с объектом, на который указывает ссылка_
на_ объект. Сказанное иллюстрирует приведенная ниже программа, в которой используются
те же интерфейс IntPredicate и метод test (), что и в предыдущей программе.
Однако в данном случае создается класс MyintNurn, в котором хранится значение типа
int и определяется метод isFactor (), предназначенный для проверки того, что переданное
ему число является делителем числа, хранящегося в экземпляре MyintNurn. Далее
в методе rnain () создаются экземпляры класса MyintNurn. Затем для каждого из этих
экземпляров поочередно вызывается метод nurnтest () с передачей ему ссьmки на метод
isFactor () соответствующего экземпляра и выполняется необходимая проверка. В каждом
из этих случаев ссьmка на метод привязывается к конкретному объекту.
// Использование ссылки на метод экземпляра.
// Функциональный интерфейс для числовых предикатов, которые
// воздействуют на целочисленные значения
interface IntPredicate {
boolean test(int n);
// Данный класс хранит значение типа int и определяет метод
// isFactor(), который возвращает значение true, если его аргумент
/! является делителем числа, хранящегося в классе
class MyintNum {
private int v;
MyintNum(int х) { v = х;
int getNum () { return v;
// Возвратить true, если n - делитель v
boolean isFactor (int n) {
return (v % n) == О;
class MethodRefDemo2
puЫic static void main(String args[])
{
boolean result;
Глава 14. Лямбда-выражения и ссылки на методы 527
MyintNum myNum = new MyintNum(12);
MyintNum myNum2 = new MyintNum(lб);
// Создать ссылку ip на метод isFactor объекта myNum
IntPredicate ip myNum::isFactor;
// Использовать ссылку для вызова метода isFactor()
// через метод test()
result = ip.test(З);
if(result) System.out.println("З является делителем " +
myNum.getNum());
// Создать ссылку на метод isFactor для объекта myNum2
// и использовать ее для вызова метода isFactor()
// через метод test()
ip = myNum2::isFactor;
result = ip.test(З);
Сс1о111ка на метод
эк3емn11яра
if(!result) System.out.println("З не является делителем " +
myNum2.getNum());
Данная программа выводит следующую информацию.
3 является делителем 12
3 не является делителем 16
В этой программе особый интерес для нас представляет следующая строка:
IntPredicate ip = myNum::isFactor;
где переменной ip присваивается ссылка на метод isFactor () объекта myNum. Таким
образом, если вызвать метод test () , как показано ниже:
result = ip.test(З);
то он вызовет метод isFactor () для объекта myNum, т.е. того объекта, который бьm указан
при создании ссьmки на метод. Аналогичная ситуация возникает и в случае ссылки
на метод myNum2: : isFactor, если не считать того, что теперь метод isFactor () вызывается
для объекта myNum2. Это подтверждается выводимой информацией.
Иногда могут возникать ситуации, требующие указания метода экземпляра, который
может использоваться с любым объектом данного класса, а не только с каким-то конкретным
объектом. В этом случае ссьmка на метод создается с использованием следующего
синтаксиса:
имя класса::имя_метода_экземпляра
где вместо имени конкретного объекта указывается имя класса, даже если применяется
метод экземпляра. В этой форме первый параметр функционального интерфейса соответствует
типу вызывающего объекта, а второй - параметру (если таковой имеется), заданному
методом. Ниже приведен соответствующий пример, представляющий переработанный
вариант предыдущего примера. Во-первых, интерфейс IntPredicate заменен
интерфейсом MyintNumPredicate. В этом случае первый параметр метода test () имеет
тип MyintNum. Он будет использоваться для получения объекта, подлежащего обработке.
528 Java 8: руководство для начинающих. 6-е издание
Это позволяет программе создать ссылку на экземплярный метод isFactor (), который
может использоваться с любым объектом MyintNurn.
// Использование ссылки на метод экземпляра для обращения
// к любому интерфейсу.
// Функциональный интерфейс для числовых предикатов, которые
// воздействуют на объект типа MyintNurn и целочисленное значение
interface MyintNumPredicate {
boolean test(MyintNurn mv, int n);
// Данный класс хранит значение типа int и определяет метод
// isFactor(), который возвращает true, если его аргумент
// является делителем числа, хранящегося в классе
class MyintNurn {
private int v;
MyintNum(int х) { v = х;
int getNum() { return v;
// Вернуть true, если n - делитель v
boolean isFactor(int n)
return (v % n) == О;
class MethodRefDemo3
puЫic static void main(String args[])
{
boolean result;
MyintNum myNum = new MyintNurn(l2);
MyintNum myNum2 = new MyintNum{lб);
// Создать ссылку inp на экземплярный метод isFactor{)
MyintNumPredicate inp = MyintNum:: isFactor; Ccwnкo но методnюбоrо
обикто тнnо MyintNum
// Вызвать метод isFactor () для объекта myNum
result = inp.test(myNum, 3);
if (result)
System.out.println("3 является делителем " + myNurn.getNum());
// Вызвать метод isFactor() для объекта myNum2
result = inp.test(myNum2, 3);
if ( ! result)
System.out.println("3 является делителем " + myNum2.getNum());
Глава 14. Лямбда-выражения и ссылки на методы 529
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как следует указывать ссылку на метод в случае обобщенных методов?
ОТВЕТ. Зачастую благодаря выводу типов тип аргумента обобщенного метода при
получении его ссылки на метод необязательно задавать явно, но для таких случаев
в Java предусмотрен синтаксис, который позволяет это сделать. Предположим,
имеется следующий код.
interface SorneTest<T>
boolean test(T n, Т rn);
class MyClass {
static <Т> boolean rnyGenMeth(T х, Ту) {
boolean result false;
// . . .
return result;
Тогда следующая инструкция будет корректной:
SorneTest<Integer> rnRef = MyClass::<Integer>rnyGenMeth;
где тип аргумента для обобщенного метода myGenМeth задается явным образом.
Обратите внимание на то, что тип аргумента указан после парного двоеточия
(: : ). Существует следующее общее правило: если в качестве ссылки на метод
задается обобщенный метод, то тип его аргумента указывается вслед за символами
: : перед именем метода. В тех случаях, когда задается обобщенный класс,
тип аргумента указывается за именем класса и предшествует символам : : .
Данная программа выводит следующую информацию.
3 является делителем 12
3 не является делителем 16
В этой программе особый интерес для нас представляет следующая строка:
MyintNurnPredicate inp = MyintNurn::isFactor;
В ней создается ссылка на экземплярный метод isFactor (), который будет работать
с любым объектом типа MyintNum. Например, если вызвать метод test () через ссылку
inp, как показано ниже:
result = inp.test(rnyNurn, З);
то в результате будет вызван метод myNum. isFactor (3). Иными словами, объектом, для
которого осуществляется вызов myNum. isFactor ( 3) , является объект myNum.
530 Java 8: руководство для начинающих. 6-е издание
Ссылки на конструкторы
Аналогично тому, как создаются ссылки на методы, можно создавать также ссылки
на конструкторы. Используемый при этом синтаксис имеет следующую общую форму:
имя класса: : new
Данную ссылку можно присвоить ссылке на любой функциональный интерфейс, который
определяет метод, совместимый с конструктором. Рассмотрим следующий простой
пример.
// Демонстрация использования ссылок на конструкторы.
// MyFunc - функциональный интерфейс, метод которого
// возвращает ссылку на MyClass
interface MyFunc {
MyClass func(String s);
class MyClass {
private String str;
// Этот конструктор принимает аргумент
MyClass (String s) { str = s; }
// Это конструктор по умолчанию
MyClass () { str = ""; )
11 . . .
String getStr () { returп str; )
class ConstructorRefDemo {
puЫic static void main(String args[J)
{
// Создать ссылку на конструктор MyClass.
// Поскольку метод func() интерфейса MyFunc принимает аргумент,
// new ссылается на параметризованный конструктор MyClass,
// а не на конструктор по умолчанию.
MyFunc myClassCons = MyClass: : new; Ссыnка на конструктор
// Создать экземпляр MyClass посредством ссылки на конструктор
MyClass mc = myClassCons.func("Tecтиpoвaниe");
// Использовать только что созданный экземпляр MyClass
System.out.println("Cтpoкa str в mc: " + mc.getStr( ));
Данная программа выводит следующую информацию:
Строка str в mc: Тестирование
Обратите внимание на то, что метод func (} интерфейса MyFunc возвращает ссылку
типа MyClass и принимает параметр типа String. Далее, заметьте, что класс MyClass
определяет два конструктора. Для первого из них указан параметр типа String.
Глава 14. Лямбда-выражения и ссылки на методы 531
Второй - это конструктор по умолчанию, не имеющий параметров. Рассмотрим следующую
строку:
MyClass mc = myClassCons.func{"Tecтиpoвaниe");
По сути, myClassCons предлагает другой способ выполнения вызова MyClass ( String s) .
Если бы вы захотели использовать MyClass: : new для вызова конструктора по умолчанию
класса MyClass, то вам понадобился бы функциональный интерфейс, который
определяет метод, не имеющий параметров. Например, если вы определите функциональный
интерфейс MyFunc2, как показано ниже:
interface MyFunc2
MyClass func{);
то с помощью следующей инструкции сможете присвоить MyClassCons ссылку на конструктор
по умолчанию (т.е. не имеющий параметров) класса MyClass:
MyFunc2 myClassCons = MyClass::new;
В общем случае при использовании ссьuюк вида : : new будет вызываться конструктор,
параметры которого соответствуют параметрам, указанным в функциональном интерфейсе.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Mory ли я объявить ссьmку на конструктор, который создает массив?
ОТВЕТ. Это возможно. Для создания ссьmки на конструктор массива используется
следующий синтаксис:
тип[]: :new
где тип - тип создаваемого объекта. Пусть, например, имеется класс MyClass
из предьщущеrо примера и следующий интерфейс MyClassArrayCreator.
interface MyClassArrayCreator
MyClass[J func{int n);
Тогда приведенный ниже фрагмент кода создает массив объектов MyClass и
присваивает каждому его элементу начальное значение.
MyClassArrayCreator mcArrayCons = MyClass[J ::new;
MyClass[J а = mcArrayCons.func{З);
for{int i=O; i < 3; i++)
a[i] = new MyClass{i);
Здесь в результате вызова func ( З) создается массив, состоящий из трех элементов.
Этот пример можно обобщить. Любой функциональный интерфейс,
предназначенный для создания массива, должен содержать метод, который
принимает единственный параметр типа int и возвращает ссьmку на массив заданного
размера.
532 Java 8: руководство для начинающих. 6-е издание
Вам также будет интересно узнать, что ничто не мешает создать обобщенный
функциональный интерфейс, пригодный для использования с другими типами
классов.
interface MyArrayCreator<T>
Т[] func(int n);
Используя эту возможность, можно, например, создать массив, состоящий из
пяти объектов типа Thread.
MyArrayCreator <Thread> mcArrayCons = Thread[) ::new;
Thread(J thrds = mcArrayCons.func(5);
И последнее: в случае создания ссылки на конструктор для обобщенного класса вы
сможете указать тип параметра обычным способом - вслед за именем класса. Например,
если имеется класс, объявленный, как показано ниже:
MyGenClass<T> { // •••
то следующий код создаст ссылку на конструктор с типом аргумента Integer:
MyGenClass<Integer>::new;
С учетом вывода типов компилятором явное указание типа аргумента требуется не
всеrда, но в случае необходимости это может быть сделано.
Предопределенные функциональные интерфейсы
До этоrо момента во всех примерах, приведенных в данной rлаве, использовались
создаваемые специально для них функциональные интерфейсы, что облегчило объяснение
фундаментальных понятий, лежащих в основе функциональных интерфейсов и
лямбда-выражений. Однако во мноrих случаях можно не определять собственные функциональные
интерфейсы, а использовать предопределенные интерфейсы, содержащиеся
в новом пакете j ava. util. function, добавленном в JDK 8. Некоторые из них представлены
в приведенной ниже таблице.
Интерфейс
UnaryOperator<T>
BinaryOperator<T>
Consumer<T>
Назначение
Применение унарной операции к объекту типа Т и возврат результата, также
имеющего тип Т. Название метода этого интерфейса - apply ()
Применение операции к двум к объектам типа Т и возврат результата, также
имеющего тип Т. Название метода этого интерфейса - apply ()
Применение операции, ассоциированной с объектом типа Т. Название метода
этого интерфейса - accept ()
Глава 14. Лямбда-выражения и ссылки на методы 533
Окончание таблицы
Интерфейс Назначен не
Supplier<T>
Function<T, R>
Возврат объекта типа Т. Название метода этого интерфейса - get ()
Применение операции к объекту типа Т и возврат результата в виде объекта
типа R. Название метода этого интерфейса - apply ()
Predicate<T> Определение того, удовлетворяет ли объект типа Т некоторому ограничению.
Возвращает результат типа boolean, указывающий на исход проверки.
Название метода этого интерфейса - test ()
Ниже приведен пример программы, в которой используется интерфейс Predicate.
В данном случае он служит функциональным интерфейсом для лямбда-выражения,
которое проверяет четность числа. Вот как выглядит объявление абстрактного метода
test () интерфейса Predicate:
boolean test (Т val)
Этот метод должен возвращать значение true, если va 1 удовлетворяет некоторому
ограничению или условию. В данном случае он возвращает значение true, если val -
четное число.
!/ Использование встроенного функционального интерфейса Predicate.
// Импортировать интерфейс Predicate
import java.util.function.Predicate;
class UsePredicateinterface {
puЫic static void main(String args[])
{
// Данное лямбда-выражение использует интерфейс
// Predicate<Integer> для определения того, четно ли
// заданное число
Predicate<Integer> isEven = (n) -> (n %2) == О; Испоnьзуется встроенный 4-􀀂􀀂􀀃
ннтерфейс Predicate
if(isEven.test(4)) System.out.println("4 - четное число");
if(!isEven.test(5)) System.out.println("S - нечетное число");
Данная программа выводит следующую информацию.
4 - четное число
5 - нечетное число
534 Java 8: руководство для начинающих. 6-е издание
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. В начале этой главы вы упомянули о том, что в результате включения
лямбда-выражений стандартная библиотека Java обогатилась новыми встроенными
возможностями? Можете привести какой-либо пример?
ОТВЕТ. К числу наиболее важных улучшений Java, добавленных в JDK 8, относится
новый пакет j ava. util. stream. В этом пакете определено несколько классов
для работы с потоками, наиболее общим из которых является класс Stream.
Потоки, входящие в пакет j ava. util. stream, служат средством передачи данных.
Таким образом, поток представляет последовательность объектов. Кроме
того, поток поддерживает многочисленные операции, с помощью которых
можно создавать конвейеры, выполняющие ряд последовательных действий над
данными. Часто для представления этих действий используются лямбда-выражения.
Например, потоковый API позволяет конструировать цепочки действий,
напоминающие запросы к базе данных, для выполнения которых можно
было бы использовать инструкции SQL. Более того, во многих случаях эти действия
могут выполняться параллельно, что повышает производительность, особенно
в случае больших объемов данных. Проще говоря, потоковый API предоставляет
в ваше распоряжение мощные и вместе с тем простые в использовании
средства обработки данных. Следует сделать важное замечание: несмотря
на некоторое сходство между новым потоковым API и потоками ввода-вывода,
рассмотренными в главе 10, они не эквивалентны друг другу.
. 􀀁 \J:
Вопросы и упражнения для самопроверки
1. Что такое лямбда-оператор?
2. Что такое функциональный интерфейс?
3. Какая связь существует между функциональными интерфейсами и лямбда-выражениями?
4. Назовите два общих типа лямбда-выражений.
5. Составьте лямбда-выражение, которое возвращает значение true, если число
принадлежит к диапазону чисел 10-20, включая граничные значения.
6. Создайте функциональный интерфейс, способный поддерживать лямбда-выражение,
предложенное в п. 5. Вызовите интерфейс MyTest и его абстрактный метод
testing ().
7. Создайте блочное лямбда-выражение для вычисления факториала целого числа.
Продемонстрируйте его использование. В качестве функционального интерфейса
используйте интерфейс NumericFunc, который рассматривался в этой главе.
8. Создайте обобщенный функциональный интерфейс MyFunc<T>. Вызовите его абстрактный
метод func () . Метод func () должен принимать параметр типа т и возвращать
ссылку типа т. (Таким образом, интерфейс MyFunc должен представлять
Глава 14. Лямбда-выражения и ссылки на методы 535
собой обобщенную версию интерфейса NumericFunc, который рассматривался в
этой главе.) Продемонстрируйте его использование, переработав свое решение
для п. 7 таким образом, чтобы вместо интерфейса Num e ricFunc в нем использовался
интерфейс MyFunc<T>.
9. Используя программу, созданную в упражнении 14.1, создайте лямбда-выражение,
которое удаляет все пробелы из заданной строки и возвращает результат.
Продемонстрируйте работу этого метода, передав его методу changeStr () .
10. Можно ли использовать в лямбда-выражении локальную переменную? Если это
так, то какие при этом существуют ограничения?
11. Справедливо ли следующее утверждение: "Если лямбда-выражение может генерировать
проверяемое исключение, то абстрактный метод функционального интерфейса
должен содержать оператор throws, в котором указано данное исключение"?
12. Что такое ссьшка на метод?
13. При вычислении ссылки на метод создается экземпляр _________
предоставляемого целевым контекстом.
14. Предположим, имеется класс MyClas s , содержащий статический метод
myStaticMethod (). Продемонстрируйте, каким образом можно указать ссьшку на
метод myStatic Method ().
15. Предположим, имеется класс MyCla s s, содержащий объектный метод
myinstMethod () , и относящийся к этому классу объект mcObj. Продемонстрируйте,
каким образом можно создать ссылку на метод myinstMethod (), ассоциированный
с объектом mcObj.
16. В программе M e t o dRefDe m o2 добавьте в класс My i n t N u m новый метод
hasCommonFactor (). Этот метод должен возвращать true, если его аргумент
типа i nt и значение, которое хранится в вызывающем объекте MyintNum, имеют
по крайней мере один общий делитель. Продемонстрируйте работу метода
hasCommonFactor () , используя ссылку на метод.
17. Как определяется ссьшка на конструктор?
18. В каком пакете Java содержатся определения встроенных функциональных интерфейсов?

Глава 15
Аплеты, события
и другие вопросы
538 Java 8: руководство для начинающих, 6-е издание
В этой главе ...
Начальные сведения об аплетах
Архитектура аплетов
Создание каркаса аплета
Инициализация и завершение аплетов
Перерисовка аплетов
Вывод данных в окне состояния
Передача параметров аплету
Класс Applet
Модель делегирования событий
Описание остальных ключевых слов Java
г лавной целью, которую ставил перед собой автор книги, было обучить читателя основам
языка программирования Java, и эта цель уже почти достигнута. Предыдущие
четырнадцать глав были посвящены описанию возможностей Java, определяемых самим
языком. К ним относятся ключевые слова, синтаксис, блочная структура кода, правила
преобразования типов и т.п. К этому моменту уровня ваших знаний должно быть достаточно
для того, чтобы приступить к написанию сложных программ на Java, имеющих
практическую ценность. Однако вне поля нашего зрения оказались два важных раздела
программирования на Java, значимость которых определяется не ключевыми словами,
а классами API и использованием специализированных технологий. В этой главе речь
пойдет об аплетах и событиях.
Завершается глава описанием некоторых ключевых слов Java, таких как instanceof
и native, о которых пока что ничего не было сказано. Эти ключевые слова являются
элементами профессионального программирования и обсуждаются здесь в целях полноты
изложения.
Основные сведения об аплетах
Аплеты существенно отличаются от программ наподобие тех, примеры которых
приводились в предыдущих главах. Как отмечалось в главе l, аплеты - это небольшие
программы, которые хранятся на сервере, передаются через Интернет и выполняются в
браузере. В виртуальной машине Java поддерживаются все типы программ на Java, в том
числе и аплеты, что дает возможность обеспечить достаточный уровень безопасности
при динамической загрузке аплетов и последующем их выполнении в браузере.
Прежде всего следует подчеркнуть, что существуют две общие категории аплетов, которые
различаются типом библиотек, на основе которых они разрабатываются: Abstract
Windows Toolkit (АWГ) и Swing. Обе библиотеки поддерживают создание графического
интерфейса пользователя (GUI). Библиотека АWГ с самого начала была доступна в Java,
тогда как библиотека Swing представляет собой ее упрощенный вариант. В этой главе
Глава 15. Аплеты. события и другие вопросы 539
рассматриваются аплеты, создаваемые на основе библиотеки АWГ, тогда как библиотеке
Swing посвящена глава 16. Важно понимать, что в аплетах на основе Swing используется
та же базовая архитектура, что и в аплетах на основе АWГ. Более того, библиотека Swing
построена на основе библиотеки АWГ. Поэтому сведения и техника программирования,
представленные в этой главе, в равной степени относятся к обеим категориям аплетов.
Перед тем как приступить к подробному изложению теоретических вопросов, рассмотрим
простой пример аплета. Он выполняет лишь одно действие: отображает в окне
строку "Java makes applets easy".
// Аплет с минимальными функциональными возможностями
import java. awt. *; / / Обратите внимание на эти операторы import
import java.applet.*;
puЬlic class SimpleApplet extends Applet {
puЫic void paint(Graphics g) {
g.drawString("Java makes applets easy.", 20, 20);
L Эrа сrрока выводится в окне anneтa
Аплет начинается с двух операторов import. Первый импортирует классы библиотеки
Abstract Window Toolkit. Аплеты на основе библиотеки АWГ взаимодействуют с
пользователем непосредственно через саму библиотеку, без использования классов консольного
ввода-вывода. Как и следовало ожидать, библиотека АWГ достаточно сложная
и включает множество классов, подробное обсуждение которых выходит за рамки книги.
К счастью, поскольку в главе речь идет о создании самых простых аплетов, средства
АWГ будут использоваться лишь в весьма ограниченной степени. Второй оператор
import импортирует пакет applet, в который входит класс Applet. Любой аплет, который
вы будете создавать на основе библиотеки АWГ, должен быть подклассом, производным
от класса Applet.
В следующей строке кода объявляется класс SimpleApplet, который должен быть
объявлен открытым (puЬlic), поскольку доступ к нему будет осуществляться извне.
В классе SimpleApplet объявляется метод paint (), который является членом класса
Component из библиотеки АWГ, являющегося суперклассом по отношению к классу
Applet, и должен переопределяться в аплете. Метод paint () вызывается всякий раз, когда
аплет должен перерисовать свой вывод. Необходимость в перерисовке может возникать
по нескольким причинам. Например, окно, в котором присутствует аплет, может быть
перекрыто другим окном, а затем снова переведено на передний план. Кроме того, окно
может быть свернуто, а затем развернуто до обычных размеров. Метод paint () также
вызывается в начале выполнения аплета. Он принимает один параметр типа Graphics -
в нем содержится графический контекст, описывающий среду, в которой выполняется
аплет. Этот контекст используется всякий раз, когда запрашивается вывод в аплет.
В теле метода paint () вызывается метод drawString (), который является членом
класса Graphics. Этот метод служит для вывода текстовой строки в окне аплета, начиная
с точки с координатами Х,У. Общая форма его объявления имеет следующий вид:
void drawString(String сообщение, int х, int у)
Здесь сообщение - это строка, которая должна быть выведена, начиная с точки,
имеющей координаты х,у, где координатам О, О соответствует верхний левый угол окна.
Вызов метода drawString () в аплете отображает строку "Java makes app\ets easy", начиная
с точки, имеющей координаты 20, 20.
540 Java 8: руководство для начинающих. 6-е издание
Обратите внимание на то, что аплет не имеет метода main (). В отличие от рассмотренных
нами ранее примеров программ, выполнение аплета начинается не с метода
main (). Фактически большинство аплетов даже не имеют этого метода. Вместо этого
аплет запускается при передаче его имени браузеру или другой программе, предназначенной
для работы с аплетами.
После ввода исходного кода аплета SimpleApplet его можно компилировать, как
обычную программу. Однако запуск аплета выполняется иначе. Аплеты запускаются одним
из двух способов: в браузере или с помощью отдельного средства просмотра аплетов.
В Java для этого предусмотрен специальный инструмент - appletviewer, который
мы и будем использовать для запуска аплетов, разрабатываемых в этой главе. Конечно,
вы можете использовать для этой цели свой браузер, но на стадии разработки пользоваться
средством просмотра appletviewer намного удобнее.
ПРИМЕЧАНИЕ
Начиная с версии Java 7 (пакет обновления 21) Jаvа-аплеты, выполняющиеся в браузере, должны
иметь цифровую подпись, что позволяет отключить вывод соответствующих предупреждений
системы безопасности. В действительности выполнение аплета в браузере в некоторых случаях
может быть вообще запрещено. Особенно критичны в этом отношении аплеты, хранящиеся в локальной
файловой системе. К этой категории относятся, в частности, аплеты, создаваемые в результате
компиляции примеров из книги. В связи с этим для запуска локальных оплетав в браузере
может потребоваться выполнение соответствующей настройки с помощью панели управления
Java. На момент написания этих строк компания Oracle рекомендовала отказаться от использования
локальных оплетав и запускать аплеты только через веб-сервер. Кроме того, выполнение
локальных оплетав, не имеющих цифровой подписи, в будущем может (а скорее всего, будет)
блокироваться. Вообще говоря, для оплетав, распространяемых через Интернет (например в
виде коммерческих приложений), наличие цифровой подписи является чуть ли не обязательным
требованием. Обсуждение понятия цифровой подписи и процедур подписания оплетав (и других
типов программ Java) выходит за рамки книги. Соответствующую информацию вы можете найти
на сайте компании Oracle. Наконец, как уже отмечалось, выполнять примеры оплетав вам будет
проще всего с помощью средства appletviewer.
Один из способов выполнить аплет (в браузере или с помощью appletviewer) -
это написать короткий НТМL-документ, содержащий дескриптор для загрузки аплета.
В настоящее время компания Oracle рекомендует использовать для этой цели дескриптор
APPLET. (Для этого также можно воспользоваться дескриптором OBJECT или
другими доступными методиками развертывания прикладных программ. За более подробными
сведениями по данному вопросу обращайтесь к документации по Java.) Ниже
приведен пример содержимого НТМL-файла, с помощью которого запускается аплет
SimpleApplet.
<applet code="SimpleApplet" width= 200 height= 60>
</applet>
Атрибуты width и height задают размеры области отображения, занимаемой аплетом.
Для запуска аплета SimpleApplet с помощью средства appletviewer необходимо
выполнить представленный выше НТМL-файл. Так, если приведенный выше код
Глава 15. Аплеты. события и другие вопросы 541
HTML находится в файле StartApp. html, то для запуска аплета SimpleApplet в командной
строке необходимо ввести следующую команду:
C:\>appletviewer StartApp.htrnl
И хотя пользоваться отдельным файлом НТМL-документа для запуска аплета вполне
допустимо, существует более удобный метод. Для этого достаточно поместить в начале
исходного кода Jаvа-аплета комментарий, включив в него дескриптор APPLET.
irnport java.awt.*;
irnport java.applet.*;
/*
,..------- Сnедующий НТМL-код исnоnьзуется
f
а appletviewer дnя зоnуско onneтo
<applet code="SimpleApplet" width=200 height= 60>
</applet>
*/
puЫic class SirnpleApplet extends Applet {
puЫic void paint(Graphics g) {
g.drawString("Java rnakes applets easy.", 20, 20);
Аплет запускается путем передачи имени файла с исходным кодом средству просмотра
appletviewer. Чтобы отобразить аплет SimpleApplet, введите в командной строке
следующую команду:
C:>appletviewer SirnpleApplet.java
Вид окна аплета SimpleApplet, отображенного в средстве просмотра appletviewer,
показан на приведенном ниже рисунке .
., Apptet Viewt!c SimpleApplet 1·􀀅 11 8 !􀀂
Applet
Java makes applets easy.
Applet star1ed.
При отображении аплета средство просмотра appletviewer снабжает окно рамкой.
Если аплет запускается в браузере, обрамление окна отсутствует.
Итак, подведем краткий итог того, что вам уже известно об аплетах.
о Каждый аплет, созданный на основе библиотеки АWГ, является подклассом, производным
от класса Applet.
• Для выполнения аплета метод main () не требуется.
* Аплет должен выполняться средствами специальной программы просмотра или
веб-браузера, совместимого с Java.
;,,; Для обмена данными с пользователем аплета потоки ввода-вывода не используются.
Вместо этого используются средства, предоставляемые библиотекой АWГ
или Swing.
542 Java 8: руководство для начинающих, 6-е издание
Организация аплета и его основные элементы
Несмотря на то что рассмотренный ранее аплет удовлетворяет всем требованиям, он
настолько прост, что ему вряд ли можно найти практическое применение. Но прежде
чем приступать к созданию аплета, пригодного для применения на практике, следует
дать хотя бы самое общее представление об организации аплетов, используемых в них
методах, а также об их взаимодействии с исполняющей системой.
Архитектура аплетов
Как уже отмечалось, аплет - это программа с графическим интерфейсом пользователя.
Как следствие, аплеты отличаются по своей архитектуре от консольных программ,
рассмотренных ранее. Если вы знакомы с основными принципами создания графических
пользовательских интерфейсов, то можете считать себя полностью подготовленным
к написанию аплетов. В противном случае вам следует усвоить несколько ключевых
принципов.
Во-первых, аплеты управляются событиями, и в этом отношении они напоминают
набор программ, обрабатывающих прерывания. Взаимодействие аплета с исполняющей
системой и пользователем происходит следующим образом. Аплет ожидает наступления
некоторого события. Исполняющая система оповещает аплет о наступлении события,
вызывая его обработчик, предусмотренный в аплете. При наступлении события аплет
должен предпринять соответствующие действия, а затем немедленно вернуть управление
исполняющей системе. Последнее обстоятельство весьма существенно. Как правило,
аплет не входит надолго в режим выполнения операций, в котором он сохранял бы
за собой контроль в течение длительного промежутка времени. Вместо этого аплет предпринимает
некоторые действия в ответ на наступление событий, после чего возвращает
управление исполняющей системе. Если же в аплете требуется выполнить некоторое повторяющееся
действие (например, отображать в окне бегущую строку), то для этой цели
надо запускать отдельный поток выполнения.
Следует также иметь в виду, что взаимодействие с аплетом происходит по инициативе
пользователя, а не наоборот. Когда консольной программе требуются данные от
пользователя, она выводит на экран специальное приглашение, а затем вызывает один
из методов ввода данных с консоли. В аплете все происходит иначе. Пользователь обращается
к аплету, когда в этом возникает потребность. Соответствующий запрос передается
аплету в виде события, которое последний должен обработать. Так, если щелкнуть
мышью в окне аплета, будет сформировано событие мыши. Если же нажать клавишу на
клавиатуре в тот момент, когда фокус ввода находится в окне аплета, то будет сформировано
событие клавиатуры. Кроме того, в окне аплета могут присутствовать элементы
управления пользовательского интерфейса, например кнопки или флажки. Когда пользователь
активизирует такой элемент, наступает соответствующее событие.
Несмотря на то что архитектура аплетов несколько сложнее архитектуры консольной
программы, понять ее совсем не трудно. Если у вас имеется опыт написания программ
для Windows (или аналогичных систем с графическим интерфейсом пользователя), то
вы знаете, каким сложным может быть их окружение. К счастью, в Java предоставляется
более простой подход к разработке программ, который усваивается гораздо легче и быстрее.
Глава 15. Аплеты. события и другие вопросы 543
Завершенный каркас аплета
Хотя рассмотренный ранее класс SimpleApplet представляет собой самый настоящий
аплет, он все же не содержит всех тех элементов, которые требуются для большинства
аплетов. Практически во всех аплетах, кроме простейших, переопределяется ряд
методов, с помощью которых браузер или другая программа просмотра аплетов может
контролировать их выполнение. Жизненным циклом аплета управляют методы ini t (} ,
start (}, stop (} и destroy (}, определенные в классе Applet. Обычно в аплетах, создаваемых
на основе АWТ, переопределяется также пятый метод, paint (}, хотя он и не
входит в число методов, управляющих жизненным циклом аплета. Этот метод расширяет
класс Component из библиотеки АWГ. Четыре упомянутых выше метода включены
вместе с методом paint (} в приведенный ниже каркас аплета.
// Каркас аплета на основе библиотеки AWT
import java.awt.*;
import java.applet.*;
/*
*/
<applet code="AppletSkel" width= ЗOO height= lOO>
</applet>
puЫic class AppletSkel extends Applet
// Этот метод вызывается первым
puЫic void init()
// инициализация
}
/* Этот метод вызывается вторым после метода init(). Он
вызывается также при каждом перезапуске аплета. */
puЫic void start () {
// запуск или возобновление выполнения
// Этот метод вызывается для приостановки аплета
puЬlic void stop() {
// приостановка выполнения
/* Этот метод вызывается последним для уничтожения аплета. */
puЫic void destroy() {
// выполнение завершающих действий
/* Этот метод вызывается для обновления данных в окне аплета. */
puЫic void paint(Graphics g) {
// перерисовка содержимого окна
Несмотря на то что код представленного каркаса не выполняет никаких действий,
его можно скомпилировать и запустить на выполнение. Следовательно, вы сможете использовать
его в качестве отправной точки для создания собственных аплетов.
544 Java 8: руководство для начинающих. 6-е издание
ПРИМЕЧАНИЕ
Переопределять метод paint () в основном приходится только в аплетах, создаваемых на основе
библиотеки АWТ. В аплетах на основе библиотеки Swing для перерисовки содержимого окна
чаще всего используется другой механизм.
Инициализация и прекращение работы аплета
Очень важно, чтобы вы хорошо представляли себе, в каком порядке вызываются методы,
включенные в каркас аплета. При запуске аплета эти методы вызываются в следующей
очередности:
1) init ();
2) start ();
3) paint().
По завершении работы аплета вызываются следующие методы:
1) stop ();
2) destroy ().
Рассмотрим все эти методы более подробно.
При запуске аплета первым вызывается метод ini t () . В теле этого метода инициализируются
переменные аплета и выполняются другие действия, связанные с подготовкой
аплета к выполнению.
После метода init () вызывается метод start (), который также может вызываться
для перезапуска аплета после его остановки, например, в тех случаях, когда пользователь
возвращается на ранее просмотренную страницу, содержащую аплет. Таким образом,
в течение времени жизни аплета метод start () может быть вызван несколько раз.
Метод paint () вызывается всякий раз, когда требуется перерисовка аплета, созданного
на основе библиотеки АWГ, о чем ранее уже шла речь.
Когда пользователь покидает веб-страницу, содержащую аплет, вызывается метод
stop (). Вы будете использовать метод stop () для остановки дочерних потоков выполнения,
созданных аплетом, а также для выполнения любых других действий, необходимых
для перевода аплета в безопасное состояние бездействия. Не следует, однако, забывать,
что вызов метода stop () вовсе не означает завершение работы самого аплета.
Когда пользователь вернется к веб-странице с аплетом, его выполнение будет возобновлено
благодаря вызову метода start ().
Метод destroy () вызывается для уничтожения аплета, когда в нем больше нет необходимости.
Этот метод используется для выполнения всех операций по освобождению
памяти и ресурсов, связанных с аплетом.
Запрос на перерисовку окна аплета
Как правило, окно аплета, созданного на основе библиотеки АWГ, перерисовывается
лишь при вызове метода paint () средой выполнения. В связи с этим возникает вопрос:
может ли аплет самостоятельно инициировать обновление окна при изменении содержащейся
в нем информации? Необходимость в этом чаще всего возникает при изменении
данных, предназначенных для отображения. Допустим, в аплете отображается баннер
с бегущей строкой. Какой механизм должен быть использован для обновления окна
Глава 15. Аплеты. события и другие вопросы 545
в процессе анимации баннера? Напомним, что одним из основных архитектурных ограничений,
налагаемых на аплет, является требование скорейшего возврата управления
исполняющей системе. Поэтому в методе paint () нельзя создать цикл, периодически
перемещающий текст сообщения баннера, поскольку это препятствовало бы соблюдению
указанного требования. Принимая во внимание это ограничение, можно прийти
к заключению, что вывод данных в окне аплета - дело непростое. Всякий раз, когда
аплету требуется обновить информацию, отображаемую в его окне, достаточно вызвать
метод repaint ().
Метод repaint () определен в классе Component, входящем в состав библиотеки
АWГ. Его вызов инициирует вызов метода paint () исполняющей системой. Если, например,
аплету необходимо отобразить данные в окне, их следует сначала сохранить, а
затем вызвать метод repaint ( J. В итоге будет вызван метод paint ( J, который сможет
отобразить измененную информацию. Так, если в аплете требуется отобразить строку, ее
нужно сначала сохранить в переменной типа String, а затем вызвать метод repaint ().
В самом же методе paint () строка будет выведена с помощью метода drawString ().
Ниже приведена простейшая форма вызова метода repaint ( J.
void repaint {)
Этот метод выполняет перерисовку всего окна аплета.
В другой форме вызова метода repaint ( J задается конкретная область, нуждающаяся
в перерисовке.
void repaint{int left, int top, int width, int height)
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Можно ли выводить данные в окне аплета, не вызывая метод paint ()
или update ()?
ОТВЕТ. Да, можно. Для этого необходимо сначала получить графический контекст,
вызвав метод getGraphics ( J, определенный в классе Component, а затем использовать
полученный контекст для вывода данных в окне. Но в большинстве
прикладных программ, создаваемых на основе библиотеки АWГ, применяется
более удобный способ, в соответствии с которым все действия по отображению
данных в окне реализуются в методе paint ( J , а для вызова последнего используется
метод repaint ().
Координаты верхнего левого угла перерисовываемой области задаются с помощью
параметров left и top, а параметры width и height определяют ширину и высоту
этой области. Все размеры задаются в пикселях. Указывая области для перерисовки,
можно значительно увеличить быстродействие программы, поскольку для обновления
содержимого окна требуется немало времени. Если же требуется перерисовать лишь небольшую
область, то в обновлении всего окна нет никакой надобности.
Применение метода repaint () будет продемонстрировано в упражнении 15.1.
546 Java 8: руководство для начинающих, 6-е издание
Метод update ()
С перерисовкой окон связан еще один метод - update (), переопределение которого
в вашем аплете может пригодиться в некоторых ситуациях. Этот метод определен в
классе Component и вызывается в тех случаях, когда требуется перерисовать часть окна
аплета. В используемом по умолчанию варианте метода update () просто вызывается
метод paint (). Метод update () может быть переопределен для выполнения более тонких
операций перерисовки, однако это уже специализированная техника, рассмотрение
которой выходит за рамки данной книги. Кроме того, переопределение метода upda te ()
возможно только для аплетов, создаваемых на основе библиотеки АWГ.
Упражнение 15. l Простой аплет дnя формирования
крупноrо эаrоловка на веб-странице
:·································:
j Banner. j ava j Работу метода repaint () удобно продемонстрировать на примере
, ................................. , следующего простого аплета, который выполняет прокрутку заго-
ловка в окне в направлении слева направо. А поскольку такая прокрутка должна многократно
повторяться, реализовать ее следует в отдельном потоке, который создается
при инициализации аплета. Подобные баннеры популярны в Интернете, и приведенная
ниже программа демонстрирует, как аплеты Java упрощают их создание. Поэтапное описание
процесса создания программы приведено ниже.
1. Создайте файл Banner. java.
2. Начните создание аплета со следующих строк кода.
/*
*/
Упражнение 15.1.
Простой аплет баннера.
В этом аплете создается поток, управляющий прокруткой
текста сообщения, хранящегося в переменной msg,
справа налево в окне аплета.
import java.awt.*;
import java.applet.*;
/*
*/
<applet code="Banner" width=ЗOO height=SO>
</applet>
puЫic class Banner extends Applet implements RunnaЫe {
String msg = " Java rules the Web "; //
Thread t;
boolean stopFlag;
// Инициализировать переменную t значением null
puЫic void init () {
t = null;
Обратите внимание на то, что класс Banner не только является подклассом, производным
от класса Applet, но и реализует интерфейс RunnaЫe. Это необходимо
потому, что аплет создает второй поток исполнения, который используется для
Глава 15. Аплеты, события и другие вопросы 547
прокрутки текста баннера по горизонтали. Текст баннера хранится в переменной
msg типа String, ссылка на поток, в котором выполняется аплет, хранится в
переменной t, а логическая переменная stopFlag служит для остановки аплета.
В методе ini t () переменная t инициализируется значением null.
3. Добавьте метод start (), исходный код которого приведен ниже.
// Запустить поток
puЫic void start()
t = new Thread(this);
stopFlag = false;
t.start();
Исполняющая система вызывает метод start () для запуска аплета. В этом методе
создается новый поток выполнения, ссылка на который присваивается переменной
t типа Thread. Затем переменная stopFlag инициализируется логическим
значением false. Далее поток запускается при вызове t. start (). Это, в
свою очередь, приводит к вызову метода run ( ) . Следует, однако, иметь в виду, что
метод start () класса Thread не имеет ничего общего с одноименным методом,
определенным в классе Applet.
4. Добавьте метод run () , исходный код которого приведен ниже.
// Точка входа в поток, выполняющий анимацию баннера
puЫic void run() {
// Перерисовать баннер
for ( ; ; ) {
try {
repaint();
Thread.sleep(250);
if(stopFlag)
break;
catch(InterruptedException ехс) {}
В методе run () вызывается метод repaint (), что в конечном итоге приводит к
вызову метода paint () и отображению текущего содержимого переменной msg на
экране. Между последовательными шагами цикла выполнение метода run () приостанавливается
на четверть секунды. В результате содержимое переменной msg
постоянно прокручивается справа налево. На каждом шаге цикла проверяется
содержимое переменной stopFlag. Как только эта переменная примет значение
true, выполнение метода run () завершится.
5. Добавьте методы stop () и paint (), исходный код которых приведен ниже.
// Приостановить выполнение аплета
puЬlic void stop() {
stopFlag = true;
t = null;
// Отобразить баннер
puЫic void paint(Graphics g) {
548 Java 8: руководство для начинающих. 6-е издание
char ch;
ch = msg.charAt(O);
msg = msg.substring(l, msg.length());
msg += ch;
g.drawString(msg, 50, 30);
Если пользователь переходит в браузере на другую страницу, вызывается метод
stop (), в котором переменной stopFlag присваивается значение true, что приводит
к завершению выполнения метода run () . В этом же методе переменной t
присваивается значение null. Таким образом, данная переменная уже не ссылается
на объект типа Thread, и этот объект может быть удален системой "сборки
мусора". Этот механизм используется для остановки потока, когда страница с
аплетом не просматривается. Когда пользователь возвращается на эту страницу,
вызывается метод start (), запускающий новый поток, анимирующий баннер.
В методе paint () осуществляется сдвиг и последующее отображение текста баннера.
6. Ниже приведен полный исходный код аплета, отображающего баннер.
/*
*/
Упражнение 15.1.
Простой аплет баннера.
В этом аплете создается поток, управляющий прокруткой
текста сообщения, хранящегося в переменной msg,
справа налево в окне аплета.
import java.awt.*;
import java.applet.*;
/*
*/
<applet code="Banner" width=ЗOO height=50>
</applet>
puЫic class Banner extends Applet implements RunnaЫe {
String msg = " Java rules the Web ";
Thread t;
boolean stopFlag;
// Инициализировать переменную t значением null
puЫic void init() {
t = null;
// Запустить поток
puЫic void start()
t = new Thread(this);
stopFlag = false;
t.start();
Глава 15. Аплеты. события и другие вопросы 549
// Точка входа в поток, выполняющий анимацию баннера
puЫic void run()
// Перерисовать баннер
for ( ; ; ) {
try {
repaint();
Thread.sleep(250);
if(stopFlag)
break;
catch(InterruptedException ехс) {}
// Приостановить вьmолнение аплета
puЬlic void stop() {
stopFlag = true;
t = null;
// Отобразить баннер
puЬlic void paint(Graphics g) {
char ch;
ch = msg.charAt(O);
msg = msg.substring(l, msg.length());
msg += ch;
g.drawString(msg, 50, 30);
Результат выполнения данного аплета представлен на рисунке.
the Web Java Rules
I Applet started.
Использование окна состояния
Помимо отображения информации в основном окне, аплет может выводить сообщения
в окне состояния браузера или иного средства просмотра аплетов. Для вывода сообщения
в окне состояния следует вызвать метод showStatus (), определенный в классе
Applet, передав ему выводимую строку в качестве параметра. Ниже приведена общая
форма объявления метода showStatus ():
void showStatus(String сообщение)
где сообщение - строка, подлежащая отображению.
550 Java 8: руководство для начинающих. 6-е издание
В окне состояния удобно отображать сведения о том, что происходит при выполнении
аплета, предлагать пользователю дальнейшие действия или выводить сообщения
об ошибках. Окно состояния незаменимо при отладке, поскольку дает возможность без
труда выводить всю необходимую информацию об аплете.
Ниже приведен пример аплета, демонстрирующий использование метода show
Status ().
// Использование окна состояния
import java.awt.*;
import java.applet.*;
/*
*/
<applet code="StatusWiпdow" width=ЗOO height=50>
</applet>
puЬlic class StatusWindow extends Applet{
// Отобразить содержимое переменной msg в окне аплета
puЫic void paint(Graphics g) {
g.drawString("This is in the applet window.", 10, 20);
showStatus("This is shown in the status window.");
Результат выполнения данного аплета представлен на рисунке.
This is in lhe applet window.
This is shown in the status window.
Передача параметров оплету
Аплетам можно передавать параметры. Для этого предусмотрен атрибут РАRАМ дескриптора
APPLET, позволяющий задать имя и значение параметра. Для извлечения параметра
служит метод getParameter (), который определен в классе Applet. Вот его общая
форма объявления:
String getParameter(String имя_параметра)
где имя_параметра обозначает конкретное имя передаваемого параметра. Данный
метод возвращает значение указанного параметра в виде объекта типа String. Таким
образом, если аплету передаются числовые или логические параметры, их строковые
представления должны преобразовываться в их внутренний формат. Если указанный
параметр не найден, метод возвращает null. Поэтому в исходный код аплетов следует
включать проверку значений, возвращаемых методом getParameter (). Кроме того,
всегда проверяйте, правильно ли бьmо выполнено преобразование числового значения
параметра, передаваемого аплету.
Ниже приведен пример, демонстрирующий процесс передачи параметров аплету.
Глава 15. Аплеты. события и другие вопросы 551
// Передача параметров аплету
import java.awt.*;
Параметры передаются
аппету в коде HTML
import java.applet.*;
/*
<applet code= 11 Param 11 width=ЗOO height =80>
<param name =author value =11 Herb Schildt11 > 􀀁
<param name=purpose value =
11 Demonstrate Parameters11 >
<param name =version value=2>
</applet>
*/
puЬlic class Param extends Applet {
String author;
String purpose;
int ver;
puЫic void start(}
String temp;
author = getParameter( 11 author 11 };
if(author = = null} author = "not found 1 1; 4---􀀭Важно убеднт�.ся
purpose = getParameter( 11 purpose 11 );
if(purpose == null) purpose = 11not found1 1;
temp = getParameter( 1 1version 11 );
try {
if(temp ! = null)
ver
else
ver
Integer.parseint(temp);
О;
в существовании параметра
catch(NumЬerFormatException ехс) {
ver = -1; // Код ошибки
.---- Не менее важно убедиться • успешности
преобразования параметра в чис110
puЫic void paint(Graphics g} {
g.drawString(1 1Purpose: 11 + purpose, 10, 20);
g.drawString( 11 By: 11 + author, 10, 40);
g.drawString(1 1Version: 11 + ver, 10, 60);
Результат выполнения данного аплета представлен на рисунке.
Purpose: Demonstrate Parameters
Ву: Herb Schildt
Version: 2
Applet started.
552 Java 8: руководство для начинающих, 6-е издание
Класс Applet
Как отмечалось ранее, все аплеты представляют собой подклассы класса Applet.
Класс Applet наследует переменные и методы следующих классов из библиотеки АWГ:
Component, Container и Panel. В результате аплет получает все функциональные возможности,
доступные в библиотеке АWГ.
Помимо методов, рассмотренных в предыдущих разделах, класс Applet содержит
ряд других методов, предоставляющих средства для более полного управления процессом
выполнения аплетов. Перечень всех методов, определенных в классе Applet, приведен
в табл. 15.1.
Таблица 15.1. Методы, определенные в классе Applet
Метод
void destroy (}
AccessiЬleContext
getAccessiЬleContext(}
AppletContext
getAppletContext(}
String getAppletlnfo (}
AudioClip getAudioClip
(URL url)
AudioClip getAudioClip
(URL url, String имя_клипа)
URL getCodeBase (}
URL getDocumentBase (}
Image getimage (URL url)
Image getlmage (URL url,
String имя_изображения)
Locale getLocale (}
String getParameter
(String имя_параметра)
Описание
Вызывается браузером непосредственно перед уничтожением
аплета. Ваш аплет должен переопределить этот метод, если до
того, кок аплет будет уничтожен, должны быть выполнены операции
по освобождению ресурсов
Возвращает контекст доступности для вызывающего объекта
Возвращает контекст, ассоциированный с аплетом
Возвращает строку, описывающую оплет
Возвращает объект типа AudioClip, инкопсулирующий аудиоклип,
доступный по адресу, задаваемому параметром ur 1
Возвращает объект типа AudioClip, инкапсулирующий аудиаклип,
который доступен по адресу, указанному в параметре
и r 1, и обладающий именем, указанным в параметре имя_
клипа
Возвращает URL, ассоциированный с аплетом
Возвращает URL того НТМL-документа, который вызывает аплет
Возвращает объект типа Image, который инкапсулирует изображение,
доступное в расположении, определяемом параметром
url
Возвращает объект типа Image, который инкапсулирует изображение,
доступное в расположении, определяемом параметром
ur 1, и обладает именем, определяемым параметром
имя_ изображения
Возвращает объект типа Locale, который используется различными
классами и методами, чувствительными к настройкам
региональных и языковых параметров системы
Возвращает параметр имя_параметра. Если параметр не
найден, возвращается значение null
Глава 15. Аплеты. события и другие вопросы 553
Окончание табл. 15. 1
Метод Описание
String [] [] getParameterinfo () Переопределенные варианты этого метода должны возвращать
таблицу объектов типа String с описанием параметров, распознаваемых
аплетом. Каждый элемент таблицы должен состоять
из трех строк, содержащих имя параметра, описание его
типа и/или диапапзона допустимых значений, а также краткое
пояснение назначения параметра. В исходном варианте реализации
этот метод возвращает значение null
void init ()
boolean isActive()
boolean isValidateRoot ()
static final AudioClip
newAudioClip (URL ur 1)
void play(URL url)
void play(URL url,
String имя_клипа)
Вызывается при запуске аплета. Дnя любого аплета данный ме-
тод вызывается первым.
Возвращает значение true, если аплет выполняется, и false,
если аплет был остановлен
Возвращает значение true, указывающее на то, что аплет яв-
ляется действительным корнем
Возвращает объект типа AudioClip, инкапсулирующий аудиоклип,
доступный по адресу, задаваемому параметром ur 1.
Этот метод подобен методу getAudioClip (), за исключением
того, что он является статическим и для его вызова не требуется
ссылка на объект типа Applet
Воспроизводит аудиоклип, если он найден по адресу, задаваемому
параметром и r 1
Воспроизводит аудиоклип, если он найден по адресу, задаваемому
параметром и r 1, и обладает именем, определяемым
параметром имя_ клипа
void resize (Dimension размер) Изменяет размеры аплета в соответствии со значениями, указываемыми
параметром размер. Класс Dimension входит в
пакет java. awt. В нем содержатся два целочисленных поля,
ширина и высота, в которых задаются ширина и высота
void resize (int ширина,
int высота)
final void setStuЬ (AppletStuЬ
объект_заглушки)
void showStatus
(String строка)
void start ()
void stop()
аплета соответственно
Изменяет размеры аплета в соответствии со значениями, указываемыми
параметрами ширина и высота
Делает объект_заглушки объектом заглушки для аплета.
Используется в основном исполняющей системой и не вызывается
из аплета. Заглушкой называется фрагмент кода, устанавливающий
связъ между аплетом и браузером
Отображает строку в строке состояния браузера или другом
средстве просмотра аплетов. Если строка состояния не поддерживается
браузером, никакие действия не выполняются
Вызывается браузером в том случае, если аплет должен начать
(или возобновить) свое выполнение. Этот метод вызывается после
метода init () при запуске аплета
Вызывается браузером для приостановки выполнения аплета.
Выполнение приостановленного аплета может быть возобновлено
вызовом метода start ()
554 Java 8: руководство для начинающих. 6-е издание
Обработка событий
В Java все проrраммы с графическим пользовательским интерфейсом, в том числе и
аплеты, управляются событиями. Следовательно, умение обрабатывать события является
залогом успешного проrраммирования rрафического пользовательского интерфейса.
Большинство событий, на которые должна реагировать проrрамма, наступают в результате
действий пользователя. Эти события передаются проrрамме разными способами,
специфика которых определяется природой самого события. Существует несколько типов
событий, включая события, генерируемые мышью, клавиатурой и различными элементами
управления, такими как кнопки. Классы поддержки событий, используемые
библиотекой АWГ, содержатся в пакете j ava. awt. event.
Прежде чем приступить к подробному рассмотрению событий, следует подчеркнуть,
что обсудить столь обширную тему более или менее подробно в рамках этой книги просто
невозможно. Тем не менее приведенный ниже краткий обзор позволит вам успешно
создавать несложные обработчики событий при написании реальных проrрамм.
Модель делегирования событий
Современный подход к обработке событий основывается на модели делегирования
событий, определяющей стандартные и согласованные механизмы их генерации и обработки.
В основе модели лежит довольно простая концепция: источник генерирует событие
и уведомляет об этом одного или нескольких слушателей. В этой схеме слушатель
просто ожидает получения события. При наступлении события слушатель обрабатывает
его и возвращает управление. Преимущество такого подхода заключается в том, что логика
обработки событий полностью отделена от логики пользовательского интерфейса,
генерирующего эти события. Элемент пользовательского интерфейса способен делегировать
обработку события независимому фрагменту кода. В модели делегирования событий
слушатели должны быть зарегистрированы в источнике, чтобы получать уведомления
о событиях.
События
В модели делегирования событие - это объект, описывающий изменение состояния
источника. Событие может быть сгенерировано при взаимодействии пользователя с элементами
пользовательского интерфейса, например, в результате щелчка на кнопке, ввода
символа с клавиатуры, выбора элемента списка или щелчка мышью.
Источники событий
Источник - это объект, генерирующий событие. Для того чтобы получать уведомления
о конкретном виде события, слушатель должен быть зарегистрирован в его источнике.
Для каждого вида события определен собственный метод регистрации. Ниже приведена
общая форма объявления методов регистрации:
puЫic void addTипListener(TипListener элемент)
где Тип - это имя события, а элемент - ссылка на слушателя события. Например,
метод, регистрирующий слушателя событий от клавиатуры, называется addKey
Listener (), а метод, регистрирующий слушателя события перемещения мыши, -
Глава 15. Аплеты, события и другие вопросы 555
adc!МouseMotionListener (). При настутшении события все слушатели оповещаются об
этом и получают копию объекта данного события.
Источник должен также предоставлять метод, позволяющий слушателю отменить регистрацию
для определенного вида событий. Ниже приведена общая форма объявления
такого метода.
puЬlic void removeTипListener{TипListener элемент)
Здесь, как и прежде, Тип - это имя события, а элемент - ссылка на слушателя
данного события. Например, для удаления слушателя событий от клавиатуры следует
вызвать метод removeKeyListener () .
Методы, добавляющие или удаляющие слушателей событий, предоставляются источниками,
генерирующими эти события. Например, в классе Component предоставляются
методы, позволяющие добавлять или удалять приемники событий клавиатуры и мыши.
Слушатели событий
Слушатель - это объект, получающий уведомления о наступлении события. К нему
предъявляются два основных требования. Во-первых, он должен быть зарегистрирован
в одном или нескольких источниках, чтобы получать от них уведомления о конкретных
видах событий. И во-вторых, он должен реализовать методы для получения и обработки
таких уведомлений.
Методы, получающие и обрабатывающие события библиотеки АWГ, определены в
наборе интерфейсов, находящихся в пакете java. awt. event. Например, в интерфейсе
MouseMotionListener определены методы, получающие уведомления о перетаскивании
объекта и перемещении мыши. Любой объект может получать и обрабатывать одно или
оба этих события, если предоставляет реализацию этого интерфейса.
Классы событий
Классы, представляющие события, находятся в самой сердцевине механизма обработки
событий в Java. На вершине иерархии классов событий Java находится класс
EventObj ect, входящий в пакет j ava. util. Этот класс служит суперклассом для всех
событий. Класс AWTEvent, определенный в пакете java.awt, является подклассом, производным
от класса EventObject, и, в свою очередь, выступает (прямо или косвенно) в
роли суперкласса для всех событий библиотеки АWГ, используемых в модели делегирования
событий.
В пакете java. awt. event определено несколько видов событий, генерируемых различными
элементами пользовательского интерфейса. Перечень некоторых наиболее часто
используемых событий этой категории вместе с их краткими описаниями приведен
в табл. 15.2.
Таблица 15.2. Основные классы событий в пакете java.awt.event
Класс события
ActionEvent
AdjustmentEvent
ComponentEvent
Описание
Генерируется после щелчка но кнопке, двойного щелчка но элементе списка
или выбора пункта меню
Генерируется при манипулировании полосой прокрутки
Генерируется при сокрытии, перемещении, изменении размеров или включении
видимости компонента
556 Java 8: руководство для начинающих. 6-е издание
Класс события
ContainerEvent
FocusEvent
InputEvent
ItemEvent
KeyEvent
MouseEvent
TextEvent
WindowEvent
Окончание табл. 15.2
Описание
Генерируется при добавлении или удалении компонента контейнера
Генерируется при получении или утере фокуса ввода компонентом
Абстрактный суперкласс для всех классов событий, связанных с вводом
данных
Генерируется после щелчка на флажке или элементе списка, а также при
выборе или отмене выбора пункта меню
Генерируется при получении ввода с клавиатуры
Генерируется при перемещении или перетаскивании мыши, при нажатии,
отпускании или щелчке кнопкой мыши, а также при наведении курсора
мыши на элемент интерфейса или покидании занимаемой элементом области
Генерируется при изменении содержимого текстовой области или поля
Генерируется при активизации, закрытии, дезактивизации, свертывании,
развертывании, открытии окна или выходе из него
Интерфейсы слушателей событий
Слушатели получают уведомления о наступлении событий. Слушатели событий библиотеки
АWГ создаются путем реализации одного или нескольких интерфейсов, входящих
в пакет java. awt. event. Когда наступает событие, источник вызывает соответствующий
метод, определенный слушателем, и передает ему объект события в качестве
аргумента. Перечень наиболее часто используемых интерфейсов и определяемых ими
методов вместе с их краткими описаниями приведен в табл. 15.3.
Таблица 15.3. Основные интерфейсы слушателей событий
Интерфейс
ActionListener
AdjustmentListener
ComponentListener
ContainerListener
FocusListener
ItemListener
KeyListener
Описание
Определяет один метод для получения событий действия. События действия
генерируются такими, например, элементами, как кнопки или меню
Определяет один метод для получения событий настройки. События настройки
генерируются такими, например, элементами, как полоса прокрутки
Определяет четыре метода для распознавания сокрытия, перемещения, изменения
размеров или отображения компонента
Определяет два метода для распознавания добавления или удаления элемента
из контейнера
Определяет два метода для распознавания получения и утери компонентом
фокуса ввода
Определяет один метод, распознающий изменение состояния элемента.
Событие элемента генерируется, например, флажком
Определяет три метода, распознающих нажатие, отпускание клавиши или
ввод символа с клавиатуры
Интерфейс
MouseListener
Глава 15. Аплеты. события и другие вопросы 557
Окончание табл. 15.З
Описание
Оnредепяет пять методов, распознающих щелчок мышью, наведение указателя
мыши но компонент или покидоние занимаемой им области, о также
нажатие и отпускание кнопок мыши
MouseMotionListener Определяет два метода, распознающих перетаскивание объекта мышью и
перемещение мыши
MouseWheelListener Определяет один метод для распознавания прокрутки колесико мыши
TextListener Определяет один метод, распознающий изменение текстового значения
WindowListener Определяет семь методов, распознающих активизацию, закрытие, деоктивизоцию,
развертывание, свертывание, открытие окно или выход
Применение модели делегирования событий
Теперь, когда вы уже имеете общее представление о модели делегирования событий
и различных ее компонентах, перейдем к вопросам ее практического применения. Создавать
аплеты, используя эту модель, совсем не трудно. По сути, написание кода для
обработки событий сводится к следующему.
1. Реализация соответствующего интерфейса в слушателе событий для получения
событий определенного типа.
2. Реализация кода для регистрации и (если в этом есть необходимость) отмены регистрации
слушателя событий.
Не следует, однако, забывать, что, как правило, один источник может генерировать
несколько видов событий, для каждого из которых требуется регистрация отдельного
слушателя. Кроме того, один объект можно зарегистрировать для получения событий
нескольких типов, но тогда он должен реализовать все интерфейсы, соответствующие
этим типам событий.
Чтобы лучше разобраться в том, как модель делегирования событий работает на
практике, обратимся к простому примеру, в котором обрабатывается один из самых распространенных
типов событий - события мыши. Этот пример демонстрирует порядок
обработки элементарных событий мыши. (Обрабатывать можно также события колесика
мыши, но вам предлагается разобраться в этом вопросе самостоятельно в качестве
упражнения.)
Обработка событий мыши
Для обработки событий мыши следует реализовать интерфейсы MouseListener и
MouseMotionListener. В интерфейсе MouseListener объявлено пять методов. При
щелчке мышью вызывается метод mouseClicked (). Если курсор мыши наводится на
компонент пользовательского интерфейса, вызывается метод mouseEntered (), а если
курсор мыши покидает область экрана, занимаемую компонентом, - метод mouse
Exi ted (). Методы mousePressed () и mouseReleased () вызываются соответственно
при нажатии и отпускании кнопки мыши.
558 Java 8: руководство для начинающих. 6-е издание
Ниже приведены общие формы объявления вышеупомянутых методов.
void mouseClicked(MouseEvent me)
void mouseEntered(MouseEvent me)
void mouseExited(MouseEvent me)
void mousePressed(MouseEvent me)
void mouseReleased(MouseEvent me)
В интерфейсе MouseMotionListener объявлены два метода. Метод mouseDragged ()
многократно вызывается при перетаскивании мыши, когда нажата ее левая кнопка.
Обычное перемещение мыши приводит к такому же многократному вызову метода
mouseMoved ( ) . Ниже приведены общие формы объявления этих методов.
void mouseDragged(MouseEvent me)
void mouseMoved(MouseEvent me)
Событие описывается объектом типа MouseEvent, передаваемым каждому методу в качестве
параметра те. В классе MouseEvent определен целый ряд методов, которые можно
использовать для получения подробных сведений о наступившем событии. Вероятно,
наиболее часто используемыми в классе MouseEvent являются методы getX () и getY () ,
возвращающие координаты текущего положения курсора мыши (относительно окна) в
момент наступления события. Ниже приведены общие формы объявления этих методов.
int getX ()
int getY ()
В примере, приведенном в следующем разделе, эти методы будут использованы для
отображения сведений о текущем положении курсора мыши.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как ранее уже отмечалось, методы getX () и getY (), определенные в
классе MouseEvent, возвращают координаты текущего положения курсора
мыши относительно окна. Существуют ли методы, предоставляющие те же самые
сведения в экранных, т.е. абсолютных, координатах?
ОТВЕТ. Да, существуют. В версии JDK 6 в классе MouseEvent определены методы
int getXOnScreen () и int getYOnScreen (), с помощью которых можно получать
абсолютные координаты Х и У, определяющие текущее положение курсора
мыши относительно экрана.
Можете поэкспериментировать с этими методами, заменив ими методы getx ()
и getY () в примере аплета, представленном в следующем разделе.
Простой пример оплето, демонстрирующий
обработку событий от мыши
В этом разделе представлен пример аплета, в котором обрабатываются простые события
мыши, а в строке состояния отображаются координаты текущего положения
Глава 15. Аплеты, события и другие вопросы 559
указателя мыши. При нажатии кнопки мыши в месте расположения указателя на экран
выводится слово "Down" (Нажато), а при отпускании кнопки - слово "Up" (Отпушено).
И наконец, после щелчка кнопкой мыши в верхнем левом углу окна аплета появляется
сообщение "Mouse clicked" (Выполнен щелчок).
Когда указатель мыши наводится на окно аплета или выводится за ero пределы, в
левом верхнем ero углу отображается соответствующее сообщение. При перетаскивании
указателя мыши ero сопровождает символ *. Кроме того, при нажатии и отпускании
кнопки мыши или перетаскивании указателя координаты ero текущего положения
сначала сохраняются в переменных mouseX и mouseY, а затем используются в методе
paint () для вывода сообщения в той точке экрана, rде произошло событие.
// Демонстрация обработки событий мьпnи
import java.awt.event.*;
import java.applet.*;
/*
*/
<applet code="MouseEvents" width= ЗOO height= lOO>
</applet>
puЫic class MouseEvents extends Applet
implements MouseListener, MouseMotionListener
String msg "tl;
int mouseX О, mouseY О; // координаты указателя мьпnи
puЫic void init() {
addMouseListener(this);
addMouseMotionListener(this); 4---- Реrнсrрация кпасса в качесrве
cnywaтenя событиii мыши
// Обработчик события щелчка мьппью
puЫic void mouseClicked(MouseEvent me) {
mouseX = О;
mouseY = 10;
msg = "Mouse clicked.";
repaint();
----- Но события мыши реаrнруют зтот
и друrие обработчики соб􀀰1тиii
// Обработчик события наведения указателя на область элемента
puЫic void mouseEntered(MouseEvent me) {
mouseX = О;
mouseY = 10;
msg = "Mouse entered.";
repaint{);
// Обработчик события выхода указателя за пределы области элемента
puЫic void mouseExited(MouseEvent me)
mouseX = О;
mouseY = 10;
msg = "Mouse exited.";
repaint();
560 Java 8: руководство для начинающих, 6-е издание
// Обработчик события нажатия кнопки МЬШIИ
puЫic void mousePressed(MouseEvent те) {
// сохранить координаты
mouseX = me.getX();
mouseY = me.getY();
msg = "Down";
repaint();
// Обработчик события отпускания кнопки МЬПIIИ
puЫic void mouseReleased(MouseEvent те) {
// сохранить координаты текущего положения курсора
mousex = me.getX();
mouseY = me.getY();
msg = "Up";
repaint();
// Обработчик события перетаскивания указателя мьппи
puЫic void mouseDragged(MouseEvent те) {
// сохранить координаты
mouseX = me.getX();
mouseY = me.getY();
msg = "*";
showStatus ( "Dragging mouse at " + mouseX + 11, " + mouseY);
repaint();
// Обработчик события перемещения указателя мьппи
puЫic void mouseMoved(MouseEvent me) {
// отобразить статус
showStatus("Moving mouse at 11 + me.getX() + 11
, " +
me.getY());
// Отобразить сообщение в окне аплета
// в точке с текущими значениями Х и У
puЫic void paint(Graphics g) {
g.drawString(msg, mouseX, mouseY);
Выполнение этого аплета дает результат, показанный на иллюстрации
.t Applet Viewt!r. 􀀴ousefven.ts
Applet
Mouse clicked.
Moving mouse at 132, 57
Глава 15. Аплеты. события и другие вопросы 561
Рассмотрим приведенный выше исходный код аплета более подробно. Класс Mouse
Events расширяет класс Applet и реализует интерфейсы MouseListener и Mouse
MotionListener. В этих интерфейсах объявлены методы, получающие и обрабатывающие
различные виды событий мыши. В данном примере аплет одновременно выступает
в роли источника и слушателя событий. И это вполне допустимо, поскольку Applet
является подклассом, производным от суперкласса Component, в котором определены
методы adc!МouseListener () и adc!МouseMotionListener (). Ситуация, когда один и тот
же класс одновременно служит источником и приемником событий, является типичной
для аплетов.
В методе ini t () аплет регистрируется как слушатель событий мыши. Для этой цели
используются методы adc!МouseListener () и adc!МouseMotionListener (), являющиеся
членами класса Component. Ниже приведены общие формы объявления этих методов.
void addMouseListener(MouseListener ml)
void addМouseMotionListener(MouseMotionListener mml)
Здесь ml и mml - ссьики на объекты, принимающие события от мыши и перемещения
мыши соответственно. В данном примере для получения и обработки обоих видов
событий используется один и тот же объект.
В рассматриваемом здесь аплете реализованы все методы, объявленные в интерфейсах
MouseListener и MouseMotionListener. Эти методы выступают в роли обработчиков
разных событий, после чего возвращают управление.
Другие ключевые слова Java
В завершение этой главы будет сделан краткий обзор остальных, не упомянутых ранее
ключевых слов Java. К их числу относятся следующие ключевые слова:
􀂞 transient;
􀂟 volatile;
!i' instanceof;
4{t native;
1} strictfp;
􀂠 assert.
Перечисленные выше ключевые слова используются в более сложных программах,
чем те, которые представлены в виде примеров в данной книге. Ниже представлен их
краткий обзор, который даст вам хотя бы самое общее представление об их назначении.
Модификаторы transient и volatile
Ключевые слова transient и volatile имеют весьма специфическое назначение.
Если переменная экземпляра объявляется как transient, то при сохранении объекта ее
содержимое не запоминается. Иными словами, поле transient не влияет на состояние
объекта.
Модификатор volatile указывает компилятору на то, что значение переменной
может быть неожиданно изменено в результате действий, выполняемых в других частях
программы. Подобная ситуация может возникнуть в многопоточных программах. В них
одна и та же переменная часто используется несколькими потоками. Из соображений
562 Java 8: руководство для начинающих. 6-е издание
эффективности каждый поток может содержать собственную копию разделяемой переменной,
причем для этого могут использоваться даже регистры ЦП. Подлинная (или
главная) копия переменной обновляется в различные моменты времени, например, при
выполнении метода, объявленного как synchronized. Как правило, такой подход вполне
оправдан, но он не всегда годится. В некоторых случаях требуется, чтобы все потоки
использовали одно и то же текущее состояние, хранящееся в главной копии переменной.
Именно это и гарантирует объявление переменной как volatile.
Оператор instanceof
Иногда в процессе выполнения программы требуется выяснить тип того или иного
объекта. Допустим, разнотипные объекты создаются в одном потоке, а обрабатываются
в другом. В этой ситуации обрабатывающему потоку должен быть известен тип того
или иного объекта. Подобного типа информация требуется и в тех случаях, когда приведение
типов осуществляется во время выполнения программы. В Java недопустимое
приведение типов вызывает ошибку времени выполнения. Многие попытки недопустимого
приведения типов могут быть выявлены еше на стадии компиляции. Но если в
приведение типов вовлекается иерархия классов, то такое приведение типов может оказаться
недопустимым, однако обнаружить его удастся лишь после запуска программы.
Например, переменная, объявленная как ссылка на суперкласс, может использоваться
для ссьmки на объекты его подклассов, поэтому на стадии компиляции не всегда удается
определить, допустимо ли приведение типов, в которое вовлечена ссьmка на суперкласс.
Для разрешения подобных проблем предназначен оператор instanceof. Ниже
приведена общая форма этого оператора.
ссылка на объект instanceof тип
Здесь ссылка_ на_ объект обозначает ссьmку на экземпляр класса, а тип - имя
класса или интерфейса. Если экземпляр имеет заданный тип или может быть приведен
к нему, то выполнение оператора instanceof дает в результате true, в противном
случае - false. Таким образом, используя оператор instanceof, можно получать сведения
о типе объекта в процессе выполнения программы.
Модификатор strictfp
Ключевое слово strictfp относится к числу наименее известных. В выпуске Java 2
модель вычислений с плавающей точкой была несколько упрошена. В частности, новая
модель не требует округления некоторых промежуточных результатов вычислений.
В ряде случаев это позволяет избежать переполнения или потери значимости. Указав
перед классом, методом или интерфейсом модификатор strictfp, можно сообщить
системе, что вычисления с плавающей точкой (и округление промежуточных результатов)
должны выполняться точно так, как в ранних версиях Java. Действие модификатора
strictfp, примененного к классу, автоматически распространяется на все методы этого
класса.
Ключевое слово assert
Ключевое слово assert используется на стадии разработки программ для создания
так называемых утверждений, т.е. условий, которые предположительно должны быть
истинными при выполнении программы. Допустим, создан метод, который должен
возвращать лишь положительные целочисленные значения. Выполнение этого условия
Глава 15. Аплеты. события и другие вопросы 563
можно проверить, используя оператор assert. Если при выполнении программы условие
истинно, то никакие специальные действия не предпринимаются. Но если условие
окажется ложным, то будет сгенерировано исключение AssertionError. Утверждения
часто применяются при тестировании программ, в то время как в готовом коде они
обычно не встречаются.
Утверждение, создаваемое с помощью ключевого слова assert, может быть записано
в двух общих формах. Вот так выглядит первая из них:
assert условие;
где условие обозначает выражение, результатом вычисления которого является логическое
значение. Так, если условие оказывается истинным (true), то и утверждение
истинно, и никакие действия не предпринимаются. Но если условие оказывается ложным
(false), то и утверждение ложно, и в этом случае по умолчанию генерируется исключение
AssertionError. Рассмотрим следующий пример:
assert n > О;
В данном примере исключение возникнет лишь в том случае, если значение n меньше
или равно нулю. В противном случае программа продолжит обычное выполнение.
Вторая общая форма утверждения имеет следующий вид:
assert условие : выражение;
В данном случае выражение дает значение, которое передается конструктору класса
AssertionError. Это значение преобразуется в свое строковое представление и выводится
в том случае, если утверждение оказывается ложным. Обычно выражение указывается
в виде строки, но оно может быть любого типа, кроме void, лишь бы преобразование
его результата в строковое представление было допустимым.
Для того чтобы утверждения проверялись при выполнении программы, интерпретатор
следует запустить с параметром -еа. Так, если требуется разрешить проверку утверждений
в программе Sarnple, в командной строке необходимо ввести следующую команду:
java -еа Sample
Утверждения очень полезны на стадии разработки программ, поскольку они упрощают
и ускоряют поиск ошибок, что и является целью тестирования. Однако, проектируя
программу, вы не должны полагаться всецело на утверждения. Дело в том, что окончательная
версия готовой программы будет выполняться с отключенным механизмом проверки
утверждений, т.е. в условиях, когда выражение утверждения не будет вычисляться.
Машинно-зависимые методы
Иногда при выполнении программ на Java приходится вызывать подпрограммы, написанные
на других языках программирования. Чаще всего подобные подпрограммы
будут существовать в виде исполняемого кода для конкретного ЦП и рабочей среды,
в которой вы работаете, т.е. в виде машинно-зависимого кода. К использованию таких
подпрограмм вас может побудить либо желание ускорить вычисления, либо необходимость
использовать специализированные библиотеки независимых производителей,
например пакет программ для статистических расчетов. Но поскольку программы на
Java компилируются в байт-код, а затем интерпретируются исполняющей системой (или
компилируются динамически), то на первый взгляд может показаться, что вызвать подпрограмму,
предоставляемую в виде машинно-зависимого кода, из программы на Java
564 Java 8: руководство для начинающих. 6-е издание
невозможно. К счастью, это вовсе не так. Для этого в Java предусмотрено ключевое слово
native, с помощью которого объявляются машинно-зависимые методы. Если метод
объявлен как native, то он может быть вызван из программы на Java точно так же, как
и обычный метод.
Для того чтобы объявить собственный метод, перед его именем следует указать ключевое
слово native, но не определять тело метода, как показано ниже.
puЫic native int meth();
Объявив машинно-зависимый метод, необходимо предоставить сам этот метод и выполнить
довольно сложную процедуру связывания данного метода с кодом на Java.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Раз уж речь зашла о ключевых словах, вернемся к ключевому слову this.
Иноrда после неrо указывается выражение в круглых скобках. Например, что
означает выражение this (х) ;?
ОТВЕТ. Такая форма записи ключевого слова this используется для тоrо, чтобы
дать конструктору возможность вызвать друrой конструктор тоrо же класса.
В общем виде эта форма записи выглядит следующим образом:
this(список_аргументов)
Если в программе встречается выражение this (), то сначала выполняется перегруженный
конструктор с таким же списком параметров, как и список
_
аргументов.
После этого выполняется тело текущего конструктора. Вызов this ()
должен быть первым выражением в теле конструктора. Ниже приведен простой
пример использования выражения this () .
class MyClass
int а;
int Ь;
// Инициализировать переменные а и Ь по отдельности
MyClass ( int i, int j) {
а i;
ь = j;
// Использовать выражение this() для инициализации
// переменных а, Ь одним и тем же значением
MyClass ( int i) {
this(i, i); // вызвать конструктор MyClass(i, i)
В классе MyClass только первый конструктор фактически присваивает значения
переменным а и Ь, тоща как второй конструктор просто вызывает первый.
Таким образом, при вычислении выражения
tff
Глава 15. Аплеты. события и другие вопросы 565
MyClass mc = new MyClass(8);
вызов конструктора MyClass (8) приводит к вычислению выражения this (8,
8) , которое преобразуется в вызов конструктора MyClass ( 8, 8) .
Вызов переrруженноrо конструктора из выражения this ( ) нередко оказывается
очень удобным, поскольку это предотвращает дублирование кода. Но при
этом необходимо соблюдать осторожность. Конструкторы, использующие выражение
this (), выполняются медленнее, чем те, которые содержат весь необходимый
инициализирующий код. Причина такого замедления объясняется дополнительными
издержками, связанными с вызовом конструктора и возвратом
из него. Не следует забывать, что создание объекта оказывает влияние на весь
использующий его код. Если предполагается создание большоrо количества экземпляров
одного класса, следует тщательно взвесить, что важнее: получить более
компактный код или увеличить время создания объекта. Когда вы приобретете
достаточный опыт программирования на Java, вам будет легче принимать
подобные решения.
Имеются два ограничения, которые следует учитывать, используя выражение
this (). Во-первых, при вызове this () нельзя использовать переменные экземпляра
из того класса, к которому относится конструктор. И во-вторых, в одном
конструкторе не могут одновременно присутствовать вызовы super () и this (),
поскольку каждый из них должен быть первым выражением конструктора.
Вопросы н упражнения дпя самопроверки
1. Какой метод вызывается первым в начале выполнения аплета? Какой метод вызывается,
когда аплет должен быть удален из системы?
2. Почему в аплете, который должен работать непрерывно, следует использовать
мноrопоточный режим?
З. Видоизмените аплет, созданный в упражнении 15.1, таким образом, чтобы в нем
отображалась строка, переданная ему в качестве параметра. Добавьте еще один
параметр, позволяющий задавать время задержки (в миллисекундах) между последовательными
сдвигами строки.
4. Задание повышенной сложности. Создайте аплет, который отображает текущее
время, обновляя содержимое окна каждую секунду. Для того чтобы справиться
с этим заданием, вам придется провести дополнительное исследование. Вот
подсказка: получить текущее время можно, воспользовавшись объектом класса
Calendar, входящего в пакет java. util. (Напомним, что компания Oracle предоставляет
онлайновую документацию по всем стандартным классам Java.) Приобретенных
вами к этому моменту знаний должно быть достаточно для того, чтобы
самостоятельно изучить класс Calendar и использовать ero методы для выполнения
задания.
5. Кратко опишите модель делегирования событий в Java.
566 Java 8: руководство для начинающих. 6-е издание
6. Должен ли слушатель событий регистрироваться в источнике?
7. Задание повышенной сложности. Среди языковых средств Java, предназначенных
мя отображения информации, имеется метод drawLine (). Метод определен
в классе Graphics и позволяет отобразить отрезок прямой линии между
двумя заданными точками с использованием текущего цвета. Используя метод
drawLine (), создайте аплет, отслеживающий перемещение мыши. Если кнопка
мыши нажата, аплет должен рисовать на экране сплошную линию до тех пор,
пока кнопка не будет отпущена.
8. Объясните назначение ключевого слова assert.
9. Назовите хотя бы одну причину, по которой может возникнуть необходимость в
использовании машинно-зависимого метода в некоторых программах.
10. Задание повышенной сложности. Попытайтесь ввести поддержку события типа
MouseWheelEvent в пример аплета MouseEvents, рассмотренный в разделе "Применение
модели делегирования событий". Для этого реализуйте интерфейс
MouseWheelListener и сделайте аплет слушателем события, связанного с прокруткой
колесика мыши, воспользовавшись методом addМouseWheelListener ().
В процессе выполнения этого задания вам придется обратиться к документации
API языка Java и ознакомиться с вышеупомянутыми средствами обработки подобных
событий. На этот вопрос ответа не дается, поэтому вам придется призвать
на помощь все свои знания и навыки, чтобы найти собственное решение.
Глава 16
Введение в Swing
568 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
if Происхождение и философия Swing
·$1 Компоненты и контейнеры Swing
􀃝 Основные сведения о менеджерах компоновки
•1 Создание, компиляция и выполнение простого Swing-приложения
,1.1 Использование компонента JButton
􀃞 Работа с компонентом JTextField
􀃟 Создание флажков JCheckBox
􀃠 Работа с компонентом JList
􀃡 Использование анонимных внутренних классов и лямбда-выражений
для обработки событий
& Создание аплета средствами Swing
з а исключением аплетов, рассмотренных в главе 15, все программы, которые приводились
в качестве примеров в предыдущих главах, бьmи консольными. Это означает,
что в них не использовался графический интерфейс пользователя (Graphical User
Interface - GUI). Консольные программы весьма удобны для обучения основам Java и
эффективно используются в целом ряде специализированых приложений, например в
серверном коде, но в большинстве реальных приложений имеется графический пользовательский
интерфейс. Во время написания данной книги наиболее популярным средством
для создания подобных Jаvа-приложений бьmа библиотека Swing.
Библиотека Swing предоставляет коллекцию классов и интерфейсов, поддерживающих
богатый набор визуальных компонентов, таких как кнопки, поля для ввода текста,
полосы прокрутки, флажки, деревья узлов и таблицы. Наличие столь широкой палитры
элементов управления позволяет создавать чрезвычайно эффективные и вместе с тем
простые в использовании графические интерфейсы. Учитывая необычайную популярность
библиотеки Swing, ее можно с уверенностью отнести к категории средств, с которыми
должен быть знаком любой специалист, пишущий программы на Java.
Необходимо с самого начала подчеркнуть, что тема Swing очень обширна, и для ее
полного обсуждения понадобилась бы отдельная книга. Поэтому в данной главе мы коснемся
лишь самых важных вопросов. Однако и этого будет достаточно для того, чтобы
вы получили общее представление о том, что такое библиотека Swing, ознакомились с
историей ее создания, основными концепциями и философией проектирования. В этой
главе рассматриваются пять наиболее часто используемых компонентов (элементов
GUI), создаваемых средствами Swing: ярлыки, кнопки, текстовые поля, флажки и списки.
Завершает главу демонстрационный пример, в котором показано, как создавать
аплеты на основе Swing. Несмотря на то что ниже описана лишь небольшая часть инструментальных
средств Swing, изучив их, вы сможете самостоятельно создавать несложные
программы с GUI-поддержкой. Кроме того, это подготовит вас к последующему
более детальному изучению всех возможностей Swing.
Глава 16. Введение в Swing 569
Прежде чем продолжить, важно упомянуть о недавно выпущенной библиотеке
JavaFX, которая создавалась специально дпя поддержки графического пользовательского
интерфейса в программах на Java. В ней реализован весьма эффективный, тщательно
продуманный и гибкий подход, позволивший значительно упростить создание визуально
привлекательных графических интерфейсов. Поэтому библиотека JavaFX может
по праву считаться платформой будущего. Учитывая указанное обстоятельство, в книгу
была дополнительно включена глава 17, содержащая краткий обзор этой библиотеки.
Можно ожидать, что в будущем программы на Java будут разрабатываться с использованием
одновременно обеих библиотек - Swing и JavaFX.
ПРИМЕЧАНИЕ
Более подробные сведения о библиотеке Swing можно найти в книге SW/NG: руководство дпя
начинающих (ИД "Вильяме", 2007 г.).
Происхождение и философия Swing
В ранних версиях Java средства Swing отсутствовали. Их появление бьuю обусловлено
стремлением устранить недостатки, свойственные оригинальной подсистеме GUI Java,
реализованной в виде библиотеки АWГ (Abstract Window Toolkit). Библиотека АWГ содержит
базовый набор компонентов, поддерживающих создание вполне работоспособных,
но ограниченных по своим возможностям графических пользовательских интерфейсов.
Ограниченность библиотеки АWГ объясняется, в частности, тем, что различные
ее визуальные компоненты транслируются в соответствующие платформенно-зависимые
эквиваленты, так называемые равноправные компоненты (peers). Отсюда следует, что
внешний вид компонентов АWГ определяется не средствами Java, а платформой. Поскольку
в компонентах АWГ используются ресурсы в виде машинно-зависимого кода,
их называют тяжеловесными (heavyweight).
Использование машинно-зависимых равноправных компонентов порождает ряд
проблем. Во-первых, из-за отличий в операционных системах компоненты могут выглядеть
и даже вести себя по-разному на различных платформах. Это нарушает основополагающий
принцип Java: "написано однажды, работает везде". Во-вторых, внешний вид
каждого компонента остается фиксированным, и изменить его очень трудно (причина
та же - зависимость от конкретной платформы). И в-третьих, применение тяжеловесных
компонентов влечет за собой ряд новых ограничений. В частности, тяжеловесный
компонент всегда имеет прямоугольную форму и является непрозрачным.
Вскоре после выпуска первоначальной версии Java стало очевидным, что ограничения
АWГ настолько серьезны, что дпя их преодоления требуется совершенно иной подход.
В итоге в 1997 году появилась библиотека компонентов Swing, включенная в состав
набора библиотек классов JFC (Java Foundation Classes). Первоначально библиотека
Swing использовалась в версии Java 1.1 как отдельная библиотека. Но в версии Java 1.2
средства Swing (как, впрочем, и остальные элементы JFC) были полностью интегрированы
в Java.
Swing устраняет ограничения, присущие компонентам АWТ, благодаря использованию
двух основных средств: легковесных компонентов и подключаемых стилей оформления.
Несмотря на то что программисту почти не приходится использовать эти средства
напрямую, именно они составляют фундамент философии проектирования, заложенной
570 Java 8: руководство для начинающих, 6-е издание
в Swing , и в значительной мере обусловливают возможности и удобство использования
этой библиотеки. Рассмотрим каждое из них в отдельности.
За небольшим исключением все компоненты Swing являются легковесными. Это означает,
что они написаны полностью на Java и не зависят от конкретной платформы,
поскольку не опираются на платформенно-зависимые равноправные компоненты. Легковесные
компоненты обладают рядом существенных преимуществ, к числу которых
относятся эффективность и гибкость. Например, легковесный компонент может быть
прозрачным, а его форма может отличаться от прямоугольной. Легковесные компоненты
не транслируются в платформенно-зависимые равноправные компоненты, и поэтому
их внешний вид определяет библиотека Swing, а не базовая операционная система.
Следовательно, элементы пользовательского интерфейса, созданные средствами Swing,
выглядят одинаково на разных платформах.
Благодаря тому что каждый компонент Swing визуализируется кодом Java, а не платформенно-
зависимыми равноправными компонентами, становится возможным раздельное
управление внешним видом компонента и логикой его функционирования, и
именно эту задачу решает Swing. Такое разделение предоставляет значительное преимущество:
оно позволяет изменить внешний вид компонента, не затрагивая другие его
свойств. Иными словами, появляется возможность "подключать" новый стиль оформления
к компоненту, не создавая никаких побочных эффектов в коде, использующем
данный компонент.
Java предоставляет различные стили оформления, такие как "металлик" и Nimbus,
доступные каждому пользователю Swing. Металлический стиль также называют стилем
оформления Java. Это платформенно-независимый стиль оформления, доступный во
всех средах выполнения программ на Java. Он же применяется по умолчанию, поэтому
именно он и будет использоваться в примерах, представленных в этой главе.
Реализация подключаемых стилей оформления в Swing стала возможной благодаря
тому, что при создании Swing был использован видоизмененный вариант классической
архитектуры модель-представление-контроллер (MVC). В терминологии MVC модель соответствует
информации о состоянии, ассоциированном с компонентом. Например, в
случае флажка модель содержит поле, указывающее на состояние флажка. Представление
определяет, как выглядит компонент на экране, включая любые аспекты представления,
на которые может влиять текущее состояние модели. Контроллер определяет реакцию
компонента на действия пользователя. Так, если пользователь щелкнет мышью на
флажке, контроллер отреагирует, изменив модель таким образом, чтобы отразить выбор
пользователя (установку или сброс флажка). В ответ на действия пользователя обновляется
и представление . Разделение компонента на модель, представление и контроллер,
позволяет добиться того, что особенности реализация одной из этих составляющих не
будут влиять на две другие. Например, в некоторых реализациях представления один и
тот же компонент может отображаться разными способами, а модель и контроллер -
оставаться без изменения.
Несмотря на всю концептуальную привлекательность архитектуры МУС и лежащих
в ее основе принципов, для компонентов Swing разделение функций между представлением
и контроллером не обеспечило заметных преимуществ. В связи с этим в Swing
используется видоизмененный вариант MVC, в котором представление и контроллер
объединены в единую логическую сущность, называемую делегатом пользовательского
интерфейса. Поэтому принятый в Swing подход называется архитектурой модельделегат,
или архитектурой с отделяемой моделью. Таким образом, компоненты Swing
нельзя рассматривать как классическую реализацию архитектуры MVC, хотя их
Глава 16. Введение в Swing 571
архитектура и опирается на нее. В процессе разработки вам не придется иметь дело непосредственно
с моделями или делегатами пользовательского интерфейса, но они будут
незримо присутствовать в создаваемых вами программах.
Прорабатывая материал главы, вы обнаружите, что библиотека Swing необычайно
проста в применении, хотя и основана на довольно сложных принципах проектирования.
Одним из аргументов в пользу Swing служит то обстоятельство, что эта библиотека
улучшает управляемость такого сложного процесса, как построение пользовательского
интерфейса. Это дает разработчикам возможность сосредоточить основное внимание на
самом графическом интерфейсе приложения, не отвлекаясь на детали его реализации.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как отмечалось выше, библиотека Swing определяет внешний вид современных
Jаvа-приложений с графическим пользовательским интерфейсом. Означает
ли это, что средства Swing фактически заменили АWГ?
ОТВЕТ. Нет, не означает. Swing нельзя рассматривать как полную замену АWГ. Напротив,
библиотека Swing была построена на основе библиотеки АWГ, а следовательно,
АWГ остается важной составной частью Java. В Swing применяется
тот же самый механизм обработки событий, что и в АWГ (см. главу 15). Для
изучения материала главы знать АWГ не обязательно, но если вы хотите в полной
мере овладеть Swing, вам придется основательно разобраться в структуре и
возможностях АWГ.
Компоненты и контейнеры
Графический пользовательский интерфейс Swing состоит из двух ключевых элементов:
компонентов и контейнеров. Такое разделение во многом условно, поскольку все
контейнеры одновременно являются компонентами. Различие между ними кроется в их
предполагаемом назначении. В общепринятом понимании этого термина компонент -
это независимый визуальный элемент управления (например, кнопка или поле ввода
текста), тогда как контейнер может содержать в себе несколько компонентов. Следовательно,
контейнер - это особая разновидность компонента. Для того чтобы отобразить
компонент на экране, его следует поместить в контейнер. Поэтому в графическом интерфейсе
должен присутствовать хотя бы один контейнер. А так как контейнеры одновременно
являются компонентами, то один контейнер может содержать в себе другой.
Это дает возможность сформировать так называемую иерархию включения, на вершине
которой находится контейнер верхнего уровня.
Компоненты
Подавляющее большинство компонентов Swing являются производными от класса
JComponent. (Единственное исключение из этого правила - четыре контейнера верхнего
уровня, которые будут описаны в следующем разделе.) В классе JComponent реализуются
функциональные возможности, общие для всех компонентов. Например, в
572 Java 8: руководство для начинающих. 6-е издание
нем поддерживаются подключаемые стили оформления. Этот класс наследует свойства
классов Container и Component из библиотеки АWГ. Таким образом, компоненты Swing
создаются на основе компонентов АWГ и совместимы с ними.
Все компоненты Swing представляются классами, находящимися в пакете j avax.
swing. В приведенной ниже таблице перечислены имена классов всех компонентов
Swing (включая компоненты, используемые как контейнеры).
JApplet JButton JCheckBox JCheckВoxMenultem
JColorChooser JComЬoBox JComponent JDesktopPane
JDialog JEditorPane JFileChooser JFormattedTextField
JFrame JinternalFrame JLabel JLayer
JLayeredPane JList JМenu JМenuBar
JМenuitem JOptionPane JPanel JPasswordField
JPopupMenu JProgressBar JRadioButton JRadioButtonМenuitem
JRootPane JScrollBar JScrollPane JSeparator
JSlider JSpinner JSplitPane JТabbedPane
JТаЫе JТextArea JТextField JТextPane
JТogglebutton JToolBar JТoolTip JТree
JViewport JWindow
Как видите, имена всех классов начинаются с буквы "J". Например, метке соответствует
класс JLabel, кнопке - класс JВutton, флажку - класс JCheck.Вox.
Как уже отмечалось, в рамках данной книги нет возможности рассмотреть все компоненты
Swing, - для этого потребовалась бы отдельная книга. Но в этой главе будут
представлены пять наиболее часто используемых компонентов: JLabel, JButton,
JTextField, JCheckBox и JList. Разобравшись в том, как они работают, вам будет легче
овладеть другими компонентами.
Контейнеры
В Swing определены два типа контейнеров. К первому типу относятся следующие
контейнеры верхнего уровня: JFrame, JApplet, JWindow и JDialog. Эти контейнеры
не наследуют класс JComponent. В то же время они наследуют классы Component
и Container библиотеки АWГ. В отличие от других, легковесных компонентов Swing,
контейнеры верхнего уровня являются тяжеловесными. Именно поэтому они образуют
отдельную группу в библиотеке Swing.
Как следует из названия контейнеров верхнего уровня, они должны находиться на
вершине иерархии контейнеров и не могут содержаться в других контейнерах. Более
того, любая иерархия должна начинаться именно с контейнера верхнего уровня. В прикладных
программах чаще всего используется контейнер типа JFrame, а в аплетах -
контейнер типа JApplet.
Контейнеры второго типа являются легковесными и происходят от класса
JComponent. В качестве примера легковесных контейнеров можно привести классы
JPanel, JScrollPane и JRootPane. Легковесные контейнеры могут содержаться в других
контейнерах, и поэтому они нередко используются для объединения группы взаимосвязанных
компонентов.
Глава 16. Введение в Swing 573
Панели контейнеров верхнего уровня
В каждом контейнере верхнего уровня определен набор панелей. На вершине иерархии
находится корневая панель - экземпляр класса JRootPane, который представляет
собой легковесный контейнер, предназначенный для управления другими панелями. Он
также позволяет управлять строкой меню. Корневая панель включает в себя "стеклянную"
панель, панель содержимого и многослойную панель.
"Стеклянная" (иначе прозрачная) панель является панелью верхнего уровня. Она располагается
поверх всех остальных панелей и полностью покрывает их. Прозрачная панель
позволяет управлять событиями мыши, относящимися ко всему контейнеру (а не
к отдельным элементам управления), и выполнять операции рисования поверх любого
другого компонента. В большинстве случаев у вас не будет возникать необходимость в
непосредственном использовании прозрачной панели. Многослойная панель позволяет
задавать глубину расположения компонента, определяя порядок перекрытия одних
компонентов другими. (Таким образом, многослойная панель позволяет упорядочивать
компоненты по координате Z, хотя это требуется не так уж часто.) В состав многослойной
панели входит панель содержимого и (необязательно) строка меню. Несмотря на то
что прозрачная и многослойная панели являются неотьемлемыми частями контейнера
верхнего уровня и выполняют важные функции, их действия по большей части скрыты
не только от пользователей, но и от разработчиков прикладных программ.
Ваше приложение в основном будет взаимодействовать с панелью содержимого, в
которую добавляются визуальные компоненты. Иными словами, добавляя компонент,
например кнопку, в контейнер верхнего уровня, вы на самом деле добавляете его в панель
содержимого.
Менеджеры компоновки
Прежде чем приступить к написанию программ средствами Swing, вам необходимо
получить хотя бы общее представление о менеджерах компоновки. Менеджер компоновки
управляет размещением компонентов в контейнере. В Java определено несколько таких менеджеров.
Большинство из них входит в состав АWГ (т.е. в пакет j ava. awt), но Swing предоставляет
также ряд дополнительных менеджеров компоновки. Все менеджеры компоновки
являются экземплярами классов, реализующих интерфейс LayoutManager. (Некоторые
из менеджеров компоновки реализуют интерфейс Layoutмanager2.) Ниже перечислен ряд
менеджеров компоновки, доступных для разработчиков, использующих библиотеку Swing.
FlowLayout
BorderLayout
Простой менеджер компоновки, размещающий компоненты слева направо и
сверху вниз. (Для некоторых региональных настроек компоненты располагаются
справа налево.)
Располагает компоненты по центру или по краям контейнера. Этот менеджер
принимается по умолчанию для панели содержимого
GridLayout Располагает компоненты в ячейках сетки, как в таблице
GridBagLayout Располагает компоненты разных размеров в ячейках сетки с регулируемыми
размерами
BoxLayout Располагает компоненты в вертикальном и горизонтальном направлении
SpringLayout Располагает компоненты с учетом ряда ограничений
57 4 Java 8: руководство для начинающих, 6-е издание
Менеджеры компоновки, как и многие другие компоненты Swing, невозможно обсудить
во всех подробностях в одной главе. Поэтому ограничимся рассмотрением только
двух из них: BorderLayout и FlowLayout.
Для панели содержимого менеджером компоновки по умолчанию является
BorderLayout. Этот менеджер определяет в составе контейнера пять областей, в которые
могут помещаться компоненты. Первая область располагается посредине и называется
центральной. Остальные четыре располагаются в соответствии со сторонами света
и носят названия северная, южная, восточная и западная. По умолчанию компонент, добавляемый
в панель содержимого, располагается в центральной области. Для того чтобы
расположить компонент в другой области, следует указать ее имя.
Несмотря на то что возможностей, предоставляемых менеджером компоновки
BorderLayout, зачастую оказывается достаточно, иногда возникает потребность в других
менеджерах компоновки. К числу самых простых относится менеджер компоновки
FlowLayout, который размещает компоненты построчно: слева направо и сверху вниз.
Заполнив текущую строку, он переходит к следующей. Такая компоновка предоставляет
лишь ограниченный контроль над расположением компонентов, хотя и проста в применении.
Однако при изменении размеров контейнера расположение компонентов может
измениться.
Первая простая Swing-nporpaммa
Программы, создаваемые средствами Swing (Swing-пporpaммы), отличаются от консольных
программ, примеры которых были рассмотрены ранее в этой книге. Они отличаются
и от аплетов, создаваемых на основе библиотеки АWТ, которые обсуждались в
главе 15. Swing-пporpaммы не только используют набор компонентов Swing для обработки
взаимодействия с пользователем, но и удовлетворяют особым требованиям, связанным
с управлением потоками. Для того чтобы стала понятнее структура Swing-пporpaммы,
лучше всего обратиться к конкретному примеру. Программы, в которых
используются компоненты Swing, можно условно разделить на две категории. К первой
относятся обычные приложения для настольных систем, ко второй - аплеты. В этом
разделе будет показано, каким образом создается Swing-приложение. Создание Swingaплeтa
будет рассмотрено далее.
Несмотря на то что рассматриваемый здесь пример программы довольно прост, он
наглядно демонстрирует один из приемов написания Swing-приложений. В данной программе
используются два компонента Swing: классы JFrame и JLabel. Класс JFrame
представляет собой контейнер верхнего уровня, нередко используемый в Swing-приложениях,
а класс JLabel - компонент Swing, с помощью которого создается метка
(ярлык), используемая для отображения информации. Метка является самым простым
компонентом Swing, поскольку она не реагирует на действия пользователя, а только
отображает информацию. Контейнер JFrame служит для размещения экземпляра компонента
JLabel. С помощью метки отображается короткое текстовое сообщение.
// Простая Swing-пpoгpaммa
import javax.swing.*;
class SwingDemo {
4---- Swing·nporpaммы доnжны
нмnортнровать пакет javax. swing
Глава 16. Введение в Swing 575
SwingDemo() {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("A Simple Swing Application");
// Установить начальные размеры фрейма
..
Соэдание нового
контейнера JFr ame
1
j f rm. s е t S i z е ( 2 7 5 , 1 О О ) ; Установка ночоnьных размеров фрейма
// Завершить работу программы, когда пользователь При закрытии окно программа
// закрывает приложение доnжно зоверwиться
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); .. 1
// Создать текстовую метку
JLabel jlab = new JLabel(" Swing defines the modern Java GUI.");
// Добавить метку в панель содержимого
j f rm. add ( j 1 аЬ) ; Добовnеиие метки в понеnь содержимого
// Отобразить фрейм
jfrm.setVisiЬle(true); ----- Сдеnоть фрейм видимым
puЫic static void main(String args[]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЫe()
puЫic void run() {
}
) ) ;
new SwingDemo(); 4----Обьект SwingDemo доnжен создаваться
в потоке диспетчеризоцни событий
Создание метки
средствами Swing
Эта программа компилируется и запускается точно так же, как и любое другое
Jаvа-приложение. Для ее компиляции введите в командной строке следующую команду:
javac SwingDemol.java
Для запуска программы используйте следующую команду:
java SwingDemol
При выполнении данной программы отображается окно, приведенное на рис. 16.l.
_ А S!mpl􀀗 Swrng Applfcation J ='"!1-..@. J􀀅
sv,ing defines the modern Java. GUI.
Рис. 16. 1. Окно, отображаемое при выполнении
программы SwingDemo
576 Java 8: руководство для начинающих. 6-е издание
Построчный анализ первой Swing-nporpaммы
Поскольку программа SwingDemo иллюстрирует сразу несколько ключевых концепций
Swing, проанализируем ее очень тщательно, строка за строкой. Программа начинается
с импорта следующего пакета:
import javax.swing.*;
Этот пакет содержит компоненты и модели, определяемые библиотекой Swing. Например,
пакет javax.swing определяет классы, реализующие метки, кнопки, текстовые поля
и меню. Любая программа, использующая библиотеку Swing, должна включать этот пакет.
Далее объявляется класс SwingDemo и конструктор этого класса. Именно в конструкторе
выполняется большинство действий этой программы. Он начинается с создания
экземпляра класса JFrame:
JFrame jfrm = new JFrame("A Simple Swing Application.");
В результате создается контейнер j frm, определяющий прямоугольное окно со строкой
заголовка, кнопками закрытия, свертывания, развертывания и восстановления
окна, а также системным меню. Таким образом, данная строка кода создает стандартное
окно верхнего уровня. Строка заголовка передается конструктору в качестве параметра.
Размеры окна задаются с помощью следующей строки кода:
jfrm. setSize (275, 100);
Используемый для этого метод setSize () устанавливает размеры окна в пикселях.
Ниже приведена общая форма объявления этого метода.
void setSize(int ширина, int высота)
В этом примере ширина окна составляет 275 пикселей, высота - 100 пикселей.
По умолчанию при закрытии окна верхнего уровня (например, когда пользователь
щелкает на кнопке закрытия) оно удаляется с экрана, но приложение продолжает
работать. Иногда такое поведение окна действительно бывает необходимым, но для
большинства случаев оно не подходит. Чаще всего требуется, чтобы закрытие окна сопровождалось
завершением работы приложения. Этого можно добиться несколькими
способами. Самый простой из них - вызов метода setDefaultCloseOperation (), как
это сделано в программе:
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
Выполнение данного метода приводит к закрытию окна и завершению работы
всего приложения. Ниже приведена общая форма объявления метода set
DefaultCloseOperation ().
void setDefaultCloseOperation(int действие)
Значение параметра действие определяет, что именно должно произойти при закрытии
окна. Кроме константы JFrame. EXIT ON CLOSE, данному методу можно передавать
следующие константы.
JFrame.DISPOSE ON CLOSE
JFrame.HIDE ON CLOSE
JFrame.DO NOTHING ON CLOSE
Имена констант отражают выполняемые действия. Все эти константы определены в
интерфейсе WindowConstants (пакет javax. swing), реализуемом классом JFrame.
Глава 16. Введение в Swing SП
В следующей строке кода создается компонент JLabel:
JLabel jlab = new JLabel(" Swing defines the modern Java GUI.");
Компонент JLabel - самый простой в использовании среди всех компонентов Swing,
поскольку он не предполагает обработку событий, связанных с действиями пользователя,
а только отображает информацию: текст, изображение или и то и другое. Метка, созданная
в данной программе, содержит только текст, который передается в ее конструктор.
Следующая строка кода добавляет метку в панель содержимого фрейма:
jfrm.add(jlab);
Как уже отмечалось, все контейнеры верхнего уровня имеют панель содержимого,
в которой размещаются компоненты. Следовательно, чтобы добавить компонент во
фрейм, его следует добавить в панель содержимого. Это достигается путем вызова метода
add () для ссьmки на экземпляр класса JFrarne (переменная j frrn). Существует несколько
вариантов метода add () . Чаще других используется следующий вариант:
Component add(Component компонент)
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Мне встречались Swing-nporpaммы, в которых при добавлении компонента
в панель содержимого вызывался метод getContentPane (). Что это за
метод и зачем он вообще нужен?
ОТВЕТ. Этот вопрос напрямую связан с историей развития Java. До появления
версии JDK 5 при добавлении компонента в панель содержимого нельзя
бьmо вызвать метод add () непосредственно для экземпляра JFrame. Однако
его можно было вызвать для панели содержимого с объектом типа JFrame.
Именно для получения ссьmки на панель содержимого и вызывался метод
getContentPane () для экземпляра JFrame. Вот общая форма объявления метода
getContentPane ():
Container getContentPane()
Данный метод возвращает ссьmку типа Container на панель содержимого.
Затем, чтобы добавить компонент в панель содержимого, для этой ссылки вызъшался
метод add () . Таким образом, для того чтобы добавить компонент j lab
в контейнер j frrn, в ранних версиях Java потребовался бы следующий вызов:
jfrm.getContentPane() .add(jlab); // старый стиль
Здесь метод getContentPane () предварительно получает ссьmку на панель содержимого,
и уже после этого метод add () добавляет компонент в контейнер,
связанный с данной панелью. Аналогичная процедура требуется для вызова
метода remove (), удаляющего компонент, а также метода setLayout (), задающего
менеджер компоновки для панели содержимого. Явные вызовы метода
getContentPane () использовались до появления версии JDK 5, но теперь потребность
в этом отпала. Методы add (), remove () и setLayout () можно вызывать
непосредственно для экземпляров JFrame, поскольку теперь эти методы
автоматически работают с панелью содержимого.
578 Java 8: руководство для начинающих. 6-е издание
По умолчанию панель содержимого, ассоциированная с контейнером JFrame, использует
граничную компоновку. В приведенном выше варианте метода add () компонент
(в данном случае метка) добавляется по центру. Другие варианты метода add ()
позволяют задавать для компоновки одну из граничных областей. Когда компонент добавляется
в центральную область, его размер автоматически изменяется для того, чтобы
он мог уместиться по центру.
Последний оператор в конструкторе класса SwingDemo делает окно видимым:
jfrm.setVisiЫe(true);
Общий синтаксис объявления метода setVisiЫe () выглядит так:
void setVisiЬle(boolean флаг)
Если параметр флаг принимает значение true, окно отображается на экране, в противном
случае оно остается скрытым. По умолчанию фрейм (объект типа JFrame) не
виден, поэтому для его отображения требуется вызов setVisiЫe (true).
В методе main () создается объект типа SwingDemo, отображающий окно и метку на
экране. Особого внимания заслуживает способ вызова конструктора класса SwingDemo.
SwingUtilities.invokeLater(new RunnaЫe() {
puЫic void run() {
}
)) ;
new SwingDemo();
Объект типа SwingDemo создается здесь не в основном потоке приложения, а в потоке
диспетчеризации событий, и вот почему. Обычно программы Swing управляются
событиями. Например, когда пользователь активизирует GUI-компонент, генерируется
соответствующее событие. Событие передается приложению путем вызова обработчика
событий, определяемого приложением. Однако данный обработчик выполняется не
в главном потоке приложения, а в потоке диспетчеризации событий, предоставляемом
библиотекой Swing. Таким образом, несмотря на то что обработчики событий определяются
в программе, они выполняются в потоке, создаваемом вне программы. Чтобы избежать
возможных проблем (например, попытки двух потоков одновременно обновить
один и тот же компонент), все компоненты GUI библиотеки Swing должны создаваться
и обновляться в потоке диспетчеризации событий, а не в главном потоке приложения.
Однако метод main () выполняется в основном потоке и поэтому не может напрямую
создавать экземпляры класса SwingDemo. Что ему доступно, так это создать объект, реализующий
интерфейс RunnaЫe и выполняющийся в потоке диспетчеризации событий,
и поручить создание GUI этому объекту.
Для создания кода G Ul в потоке диспетчеризации событий необходимо использовать
один из двух методов, определенных в классе SwingUtili ties: invokeLater () или
invokeAndWait (). Эти методы объявляются следующим образом.
static void invokeLater(RunnaЬle объект)
static void invokeAndWait(RunnaЫe объект)
throws InterruptedException, InvocationTargetException
Здесь объект - это объект типа RunnaЫe, метод run () которого вызывается в
потоке диспетчеризации событий. Различие между этими методами состоит в том, что
метод invokeLater () сразу же возвращает управление вызывающему методу, тогда как
Глава 16. Введение в Swing 579
метод invokeAndWait () ожидает возврата из метода obj. run (). Можно использовать
эти методы для вызова метода, создающего графический пользовательский интерфейс
приложения Swing, а также во всех других случаях, когда требуется изменить состояние
GUI из кода, выполняющегося не в потоке диспетчеризации событий. Как правило, вы
будете использовать метод invokeLater (), как это сделано в предыдущей программе.
Но при создании исходного пользовательского интерфейса для аплета следует использовать
метод invokeAndWai t (). (0 создании аплетов Swing речь пойдет далее.)
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Ранее было сказано, что компоненты можно добавлять и в другие области,
а не только по центру, и для этого предусмотрены специальные варианты
метода add () . Нельзя ли рассказать об этом подробнее?
ОТВЕТ. Как уже отмечалось, для размещения компонентов в контейнере менеджер
компоновки BorderLayout определяет пять областей. Одна из них - центральная
область (CENTER), остальные четыре располагаются в соответствии со
сторонами света и называются северной (NORTH), южной (SOUTH), восточной
(EAST) и западной (WEST). По умолчанию компонент, добавляемый на панель
содержимого, располагается по центру. Для того чтобы указать другое расположение
компонента, используйте следующий вариант метода add ( ) :
void add(Cornponent компонент, Object расположение)
где параметр компонент задает компонент, добавляемый на панели содержимого,
а параметр расположение определяет область, в которой этот компонент
будет размещен. Допускаются следующие значения параметра расположение.
BorderLayout.CENTER
BorderLayout.EAST
BorderLayout.NORTH
BorderLayout.SOUTH
BorderLayout.WEST
Вообще говоря, менеджер компоновки BorderLayout чаще всего используется
для создания контейнеров JFrame, содержащих центральный компонент
(или группу компонентов, размещаемых в одном из легковесных контейнеров
Swing), а также ассоциированные с ним компоненты верхнего и нижнего колонтитулов.
В остальных же случаях более подходящими будут другие менеджеры
компоновки Java.
Следует отметить еще одну особенность анализируемой программы: в ней не предусмотрена
реакция на события, поскольку компонент JLabel пассивный, т.е. не генерирует
событий. Однако остальные компоненты генерируют события, на которые программа
должна реагировать соответствующим образом, что и будет продемонстрировано
на конкретных примерах далее.
580 Java 8: руководство для начинающих. 6-е издание
Использование компонента JВutton
Одним из наиболее часто используемых визуальных элементов управления Swing является
кнопка. Кнопка Swing - это экземпляр класса JВutton. Класс JВutton наследует
абстрактный класс AЬstractButton, который определяет функциональность, общую
для всех кнопок. На кнопке может отображаться текст, изображение или и то и другое,
но в этой книге рассматриваются только кнопки с надписями.
Класс JButton предоставляет несколько конструкторов. Мы будем использовать
конструктор следующей формы:
JButton(String сообщение)
где сообщение определяет строку, которая должна отображаться в виде надписи на
кнопке.
После щелчка на кнопке генерируется событие ActionEvent. Класс ActionEvent
определен в библиотеке АWТ, но используется и в библиотеке Swing. В классе JВutton
предоставляются методы, позволяющие зарегистрировать слушателя событий или отменить
его регистрацию.
void addActionListener(ActionListener а1)
void removeActionListener(ActionListener а1)
Здесь параметр а 1 задает объект, который будет получать уведомления о наступлении
событий. Этот объект должен представлять собой экземпляр класса, реализующего
интерфейс ActionListener.
В интерфейсе ActionListener определен только один метод: actionPerforrned ().
Ниже приведена его общая форма объявления.
void actionPerformed(ActionEvent ае)
Данный метод вызывается после щелчка на кнопке. Иными словами, он является
обработчиком события щелчка на кнопке. Реализуя метод actionPerforrned (), необходимо
позаботиться о том, чтобы он быстро реагировал на событие и возвращал управление.
В отношении обработчиков событий необходимо руководствоваться следующим
общим правилом: они не должны вовлекаться в длительные операции, поскольку это
будет замедлять работу приложения в целом. Если же обработка события предполагает
действия, требующие времени, их следует выполнять в отдельном потоке, специально
создаваемом для этой цели.
С помощью объекта типа ActionEvent, передаваемого методу actionPerforrned (),
можно получить важные сведения о событии щелчка на кнопке. В данной главе для этой
цели будет использоваться строка команды действия, связанная с кнопкой. По умолчанию
именно эта строка отображается на кнопке. Чтобы получить команду действия,
следует вызвать метод getActionCornrnand () для объекта события. Этот метод объявляется
следующим образом:
String getActionCommand()
Команда действия идентифицирует кнопку. При наличии в пользовательском интерфейсе
приложения нескольких кнопок команда действия позволяет достаточно просто
определить, какая из них была выбрана.
Ниже приведен пример программы, в которой показано, как создать кнопку, реагирующую
на действия пользователя. Вид окна, отображаемого данной программой на
экране, представлен на рис. 16.2.
Глава 16. Введение в Swing 581
// Демонстрация создания кнопки и обработки событий действий
irnport java.awt.*;
irnport java.awt.event.*;
irnport javax.swing.*;
class ButtonDerno irnplernents ActionListener {
JLabel jlab;
But tonDerno ()
// Создать новый контейнер JFrarne
JFrarne jfrrn = new JFrarne("A Button Exarnple");
// Задать объект FlowLayout для менеджера компоновки
jfrrn.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrrn.setSize(220, 90);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrrn.setDefaultCloseOperation(JFrarne.EXIT_ON_CLOSE);
// Создать две кнопки
JButton jbtnUp = new JButton("Up"); .....1-- -----􀁹
f- Соэданне двух кнопок
JButton jЬtnDown = new JButton("Down"); .....о-- ---􀀇-
// Добавить слушатели действий
jЬtnUp. add.ActionListener (this); ..... 1--------,􀀈 д􀀯авn!ннесnуwотеnей
j btnDown. add.ActionListener ( this) ; .. деистами дпя кнопок
// Добавить кнопки в панель содержимого
j frrn. add (jЬtnUp) ; ..... 1-------􀁺f- Добавnение кнопок
j f rm . а dd ( j Ьtn Down) ; .. • панеnь содержнмоrо
// Создать метку
jlab = new JLabel("Press а button.");
// Добавить метку во фрейм
jfrm.add(jlaЬ);
// Отобразить фрейм
jfrm.setVisiЫe(true);
// Обработать события кнопки
puЬlic void actionPerformed(ActionEvent ае) -4----Обработка событий кнопки
if (ае. getActionCommand () . equals ( "Up"))
jlab.setText("You pressed Up.");
-4---- Исnоnьзованне команды действия
дпя опредеnения нажатой кнопки
else
jlab.setText("You pressed down. ");
582 Java 8: руководство для начинающих. 6-е издание
puЫic static void main(String args[J) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЫe()
puЬlic void run() {
)
) ) ;
new ButtonDemo();
А Button ExampleWJ:@􀀭
Шt􀀄J
You pressed dowп.
Рис. 16.2. Результат выполнения программы Bu t tonDemo
Проанализируем, что нового появилось в этой программе. Прежде всего, теперь
программа импортирует два пакета - j ava. awt и j ava. awt. event. Пакет j ava. awt
необходим потому, что он содержит класс менеджера компоновки FlowLayout, а пакет
java. awt. event - потому, что в нем определены интерфейс ActionListener и класс
ActionEvent.
Далее в программе объявляется класс ButtonDemo, который реализует интерфейс
ActionListener. Это означает, что объекты типа ButtonDemo могут быть использованы
дпя получения событий действий. Затем объявляется ссылка на объект типа JLabel. Она
будет использована в методе actionPerformed () дпя отображения сведений о том, какая
именно кнопка была нажата.
Конструктор класса ButtonDemo начинается с создания контейнера j frm типа
JFrame. Затем в качестве менеджера компоновки дпя панели содержимого контейнера
j frm устанавливается FlowLayout, как показано ниже.
jfrm.setLayout(new FlowLayout());
Как уже отмечалось, по умолчанию на панели содержимого в качестве менеджера
компоновки используется BorderLayout, но дпя многих приложений лучше подходит
менеджер компоновки FlowLayout. Он размещает компоненты построчно: слева направо
и сверху вниз. После заполнения текущей строки менеджер компоновки переходит к
следующей. Такая компоновка предоставляет лишь ограниченный контроль над расположением
компонентов, но зато она проста в использовании. Следует, однако, иметь в
виду, что при изменении размеров контейнера расположение компонентов может измениться.
После установки размеров фрейма и определения операции, выполняемой при закрытии
окна, в конструкторе ButtonDemo () создаются две кнопки.
JButton jЬtnUp = new JButton("Up");
JButton jЬtnDown = new JButton("Down");
На первой кнопке отображается надпись Up (Отпуmена), на второй - Down (Нажата).
Далее экземпляр класса ButtonDemo, для ссьmки на который используется ключевое
слово this, добавляется в качестве слушателя действий для кнопок с помощью следующих
строк кода.
jbtnUp.addActionListener(this);
jbtnDown.addActionListener(this);
Глава 16. Введение в Swing 583
В результате выполнения этого кода объект, создающий кнопки, будет получать также
уведомления об их нажатии.
Всякий раз, когда кнопка нажимается, генерируется событие действия, о котором
зарегистрированные приемники уведомляются посредством вызова метода
actionPerformed (). Объект типа ActionEvent, представляющий событие кнопки, передается
этому методу в качестве параметра. В программе ButtonDemo это событие передается
следующей реализации метода actionPerformed ().
// Обработка событий кнопки
puЬlic void actionPerformed(ActionEvent ае)
if(ae.getActionCommand() .equals("Up"))
jlab.setText("You pressed Up.");
else
jlab.setText("You pressed down. ");
Событие передается с помощью параметра ае. В теле метода для получения команды
действия, которая соответствует кнопке, сгенерировавшей событие, вызывается метод
getActionCommand (). (Напомним: по умолчанию команда действия совпадает с текстом,
отображаемым на кнопке.) В зависимости от содержимого строки, представляющей
команду действия, устанавливается текст надписи на кнопке, указывающий на то,
какая именно кнопка была нажата.
Следует также иметь в виду, что, как отмечалось ранее, метод actionPerformed ()
вызывается в потоке диспетчеризации событий. Он должен возвращать управление как
можно быстрее, чтобы не замедлять работу приложения.
Работа с компонентом JТextField
К числу широко используемых компонентов Swing относится также компонент
JTextField, который дает пользователю возможность вводить и редактировать текстовую
строку. Компонент JTextField является подклассом, производным от абстрактного
класса JTextComponent, который выступает в роли суперкласса не только для компонента
JТextField, но и для всех текстовых компонентов вообще. В классе JТextField определен
ряд конструкторов. Здесь и далее будет использоваться следующий конструктор:
JTextField ( int столбцы)
где столбцы - ширина текстового поля, выраженная в столбцах. Важно, чтобы вы понимали,
что длина вводимой строки не ограничивается шириной поля, отображаемого
на экране, и параметр столбцы устанавливает лишь физический размер компонента на
экране.
Для завершения ввода текста в поле пользователь нажимает клавишу <Enter>, в результате
чего генерируется событие ActionEvent. В классе JТextField предоставляются
методы addActionListener () и removeActionListener (). Для обработки событий
действий необходимо реализовать метод actionPerformed (), объявленный в интерфейсе
ActionListener. Обработка событий текстового поля осуществляется аналогично обработке
событий кнопки, о которых шла речь ранее.
Как и в случае компонента JButton, с компонентом JTextField связывается конкретная
команда действия в виде строки. По умолчанию эта строка соответствует
584 Java 8: руководство для начинающих. 6-е издание
текущему содержимому текстового поля, хотя эта возможность используется редко.
Чаще всего вы будете сами задавать фиксированное значение команды действия с помощью
метода setActionCoппnand (), который объявляется следующим образом:
void setActionCommand(String команда)
Строка, передаваемая через параметр команда, становится новой командой действия,
но при этом текст в текстовом поле не меняется. Установленная строка команды
действия остается неизменной, независимо от того, какой именно текст вводится в поле
ввода текста. Как правило, к явной установке команды действия прибегают для того,
чтобы обеспечить распознавание текстового поля как источника, сгенерировавшего событие
действия. Поступать подобным образом приходится в тех случаях, когда фрейм
содержит несколько элементов управления, для которых определен общий обработчик
событий. Установив команду действия, вы получаете в свое распоряжение удобное средство
для различения компонентов. Если этого не сделать, могут возникнуть трудности
при распознавании источника события, так как пользователь может ввести в поле произвольный
текст, совпадающий с командой действия другого компонента.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как отмечалось выше, команду действия для поля ввода текста можно
явно установить с помощью метода setActionCo=and () . Можно ли воспользоваться
этим методом, чтобы установить команду действия для кнопки?
ОТВЕТ. Да, можно. По умолчанию команда действия для кнопки совпадает с текстом
надписи на кнопке. Но можно установить и другое ее значение, воспользовавшись
методом setActionCoПU11and () класса JВutton. Он выполняет те же
действия, что и одноименный метод класса JТextField.
Для того чтобы получить строку, отображаемую в текстовом поле, следует обратиться
к экземпляру класса JТextField и вызвать метод getText (). Объявление этого метода
приведено ниже.
String getText()
Задать текст для компонента JТextField можно с помощью метода setText ():
void setText(String текст)
где текст - это строка, которая будет помещена в текстовое поле.
Ниже приведен пример программы, демонстрирующий использование компонента
JTextField. В окне этой программы содержатся текстовое поле, кнопка и две метки.
Одна из меток подсказывает пользователю ввести текст в поле. Когда пользователь нажмет
клавишу <Enter> (при условии, что фокус ввода находится в поле ввода текста),
введенные данные будут извлечены и отображены на второй метке. На кнопке отображается
надпись Reverse (Обратить). После щелчка на кнопке содержимое текстового
поля преобразуется и порядок символов в нем изменяется на обратный. Результат выполнения
данной программы приведен на рис. 16.3.
// Использование текстового поля
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
Глава 16. Введение в Swing 585
class TFDemo implements ActionListener {
JTextField jtf;
JButton jbtnRev;
JLabel jlabPrompt, jlabContents;
TFDemo () {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("Use а Text Field");
// Задать объект FlowLayout для менеджера компоновки
jfrm.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrm.setSize (240, 120);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrrn.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// Создать текстовое поле
jtf = new JTextField(lO); .---- Соэданне текстового nonя wнрнной
10снмвоnов
// Установить команду действия для текстового поля
j tf. setActionComrnand ( "myTF") ; Заданне команды действня
дnя текстовоrо nonя
// Создать кнопку Reverse
JButton jЬtnRev = new JButton("Reverse");
// Добавить слушатели событий для
jtf.addActionListener(this); 4
jЬtnRev.addActionListener(this);
// Создать метки
текстового поля и кнопки
􀀯 Добавnенне cnywaтeneй действий
...4 .-----􀀰- дnя текстового nonя и кнопки
jlabPrornpt = new JLabel("Enter text: ");
jlabContents = new JLabel("");
// Добавить компоненты в панель содержимого
jfrm.add(jlabPrompt);
jfrm.add(jtf);
jfrm.add(jbtnRev);
jfrm.add(jlabContents);
// Отобразить фрейм
jfrm.setVisiЬle(true);
586 Java 8: руководство для начинающих. 6-е издание
/ / Обработать события действий Данный метод обрабатывает
puЫic void actionPerformed( ActionEvent ае) { ....- --событня кнопкн н текстового паяя
if(ae.getActionCommand() .equals("Reverse"))
// Была нажата кнопка Reverse
String orgStr jtf.getText();
String resStr = "";
// Обратить строку в текстовом поле
for(int i=orgStr.length()-1; i >=О; i--)
resStr += orgStr.charAt(i);
􀀥 Испояьзованне команды действня
дяя апредеяення компонента,
сrенернровавwеrо событие
// Сохранить обращенную строку в текстовом поле
jtf.setText(resStr);
else
// Клавиша <Enter> была нажата в тот момент, когда фокус
// ввода находился в текстовом поле
jlabContents.setText("You pressed ENTER. Text is: " +
jtf.getText());
puЫic static void main(String args[]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЬle()
puЬlic void run() {
)
)) ;
new TFDemo ();
_ UseaTeкtField @[®Э􀀃
Entertext: \тesting I
j Reverse
You pressed EtПER. Text is: Testing
Рис. 16.З. Результат выполнения программы TFDemo
Большая часть исходного кода приведенной выше программы вам уже знакома, но
некоторые его фрагменты нуждаются в пояснениях. Прежде всего обратите внимание на
то, что с текстовым полем связывается команда действия "myТF". Эту привязку осуществляет
следующая строка кода:
jtf.setActionCommand("myTF");
После выполнения этого кода строка команды действия всегда будет содержать значение
"myTF", независимо от того, какой именно текст введен в поле. Благодаря этому
исключаются ситуации, когда команда действия, связанная с текстовым полем, может
вступать в конфликт с командой действия, связанной с кнопкой Reverse. В методе
actionPerformed () установленная команда действия используется для распознавания
того компонента, который стал источником события. Если строка команды действия
Глава 16. Введение в Swing 587
содержит значение "Reverse", то это может означать только одно: событие наступило
в результате щелчка на кнопке Reverse. Иначе следует сделать вывод, что событие наступило
в результате нажатия пользователем клавиши <Enter> в тот момент, коrда фокус
ввода находился в текстовом поле.
И наконец, обратите внимание на следующую строку кода в теле метода action
Perforrned ()
jlabContents.setText("You pressed ENTER. Text is: " +
jtf.getText());
Как уже отмечалось, при нажатии клавиши <Enter> в тот момент, когда фокус ввода
находится в текстовом поле, генерируется событие ActionEvent, которое пересылается
всем зарегистрированным слушателям событий действий с помощью метода
actionPerforrned (). В программе TFDemo этот метод лишь вызывает метод getText (),
извлекая текст, содержащийся в компоненте jtf (текстовое поле). После этого текст
отображается с помощью метки, на которую ссылается переменная j labContents.
Создание флажков с помощью
компонента JCheckВox
Если обычные кнопки используются чаще друrих элементов пользовательского интерфейса,
то второе место по популярности безусловно занимают флажки. В Swing эти
элементы GUI реализуются с помощью объекта типа JCheckВox. Класс JCheckВox является
производным от классов AЬstractButton и JToggleButton. Следовательно, флажок
- это особая разновидность кнопки.
В классе JCheckВox определен ряд конструкторов. Один из них имеет следующий вид:
JCheckBox(String строка)
Этот конструктор создает флажок с пояснительной надписью в виде строки, передаваемой
через параметр строка.
При установке или сбросе флажка генерируется событие элемента. События элементов
представляются классом ItemEvent. Эти события обрабатываются классами, реализующие
интерфейс ItemListener. В этом интерфейсе определен только один метод,
i temStateChanged (), общая форма объявления которого приведена ниже:
void itemStateChanged(ItemEvent ie)
Метод получает событие в параметре ie.
Для того чтобы получить ссылку на элемент, состояние которого изменилось, следует
вызвать метод get Item () для объекта ItemEvent. Ниже приведена общая форма объявления
этого метода.
Object getitem()
Возвращаемая этим методом ссьUiка должна быть приведена к типу обрабатываемого
компонента, в данном случае - к типу JCheckВox.
Ассоциированный с флажком текст можно получить, вызвав метод getText (); чтобы
задать текст пояснительной надписи после создания флажка, следует вызвать метод
setText (). Эти методы действуют точно так же, как и одноименные методы рассмотренного
ранее класса JВutton.
588 Java 8: руководство для начинающих. 6-е издание
Самый простой способ определить состояние флажка - вызвать метод
isSelected () , который объявляется следующим образом:
boolean isSelected()
Этот метод возвращает значение true, если флажок установлен, иначе - значение
false.
Ниже приведен пример программы, демонстрирующий манипулирование флажками.
В программе создаются три флажка: Alpha, Beta и Gamma. Всякий раз, когда состояние
флажка изменяется, в окне программы появляются сведения о выполненном действии,
а также перечисляются те флажки, которые установлены в данный момент. Результат
выполнения данной программы приведен на рис. 16.4.
// Демонстрация использования флажков
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
class CBDemo implements ItemListener {
JLabel jlabSelected;
JLabel jlabChanged;
JCheckBox jcbAlpha;
JCheckBox jcbBeta;
JCheckBox jcbGamma;
CBDemo() {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("Demonstrate Check Boxes");
// Задать объект FlowLayout для менеджера компоновки
jfrm.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrm.setSize(280, 120);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// Создать пустые метки
jlabSelected = new JLabel("");
jlabChanged = new JLabel("");
// Создать флажки
jcbBeta = new JCheckBox("Beta"); LСоэдоннефnажкоа
jcbAlpha = new JCheckBox("Alpha");
:
jcbGamma = new JCheckBox("Gamma"); ..,. ______ .Г
// События, генерируемые флажками, обрабатываются
// одним методом itemStateChanged(),
// реализованным в классе CBDemo
jcbAlpha.additemListener(this);
jcbBeta.additemListener(this);
jcbGamma.additemListener(this);
Глава 16. Введение в Swing 589
// Добавить флажки и метки в панель содержимого
jfrrn.add(jcbAlpha);
jfrrn.add(jcbBeta);
jfrrn.add(jcbGarnrna);
jfrrn.add(jlabChanged);
jfrrn.add(jlabSelected);
// Отобразить фрейм
jfrrn.setVisiЫe(true);
// Обработчик для флажков
puЫic void itemStateChanged(IternEvent ie) {
String str = "";
.----06роботко событий фnожко
// Получить ссылку на флажок, с которым связано событие
JCheckBox сЬ = (JCheckBox) ie.getitern(); Поnученне ссыnкн нофnожок,
состояние котороrо нэменнnось
// Сообщить о том, состояние какого флажка изменилось
if ( сЬ. isSelected () ) Оnредеnенне тоrо, какое именно событие npoнэowno
jlabChanged.setText(cb.getText() + " was just selected.");
else
jlabChanged.setText(cb.getText() + " was just cleared.");
// Сообщить обо всех установленных флажках
if (jcbAlpha. isSelected ()) {
str += "Alpha ";
if(jcbBeta.isSelected())
str += "Beta ";
if(jcbGarnrna.isSelected())
str += "Garnrna";
jlabSelected.setText("Selected check boxes: " + str);
puЫic static void rnain(String args[]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЫe()
puЫic void run() {
}
} ) ;
new CBDerno();
l1 Demonstrate €heck Вохеs Ео3@􀀃
􀁃 Alpha О Веtа 􀁄 amm􀁅
Gamma was just selected.
Selected check Ьохеs: Alpha Gamma
Рис. 16.4. Результат выполнения программы CBDemo
590 Java 8: руководство для начинающих. 6-е издание
Наибольший интерес в рассматриваемом примере представляет метод i temSta te
Changed (), предназначенный для обработки событий элементов (в данном случае флажков).
Он выполняет две функции: во-первых, сообщает, установлен или сброшен флажок;
во-вторых, отображает список всех установленных флажков. Сначала определяется
ссылка на компонент, сгенерировавший событие ItemEvent. Это происходит в следующей
строке кода:
JCheckBox сЬ = (JCheckBox) ie.getitem();
Приведение к типу JCheckBox необходимо потому, что метод getltem () возвращает
ссылку на объект типа Obj ect. Далее метод i temSta teChanged () вызывает метод
isSelected () для объекта сЬ, чтобы определить текущее состояние флажка. Если метод
isSelected () возвращает значение true, значит, флажок установлен, а если false -
флажок сброшен. Затем с помощью метки j labChanged отображаются сведения о выполненном
действии.
И наконец, метод i temStateChanged () проверяет состояние каждого флажка и формирует
строку с именами установленных флажков. Эта строка отображается в окне программы
с помощью метки j labSelected.
Класс Jlist
Класс JList - это базовый класс Swing, обеспечивающий поддержку списков с возможностью
выбора в списке одного или нескольких элементов. Чаще всего в списках
содержатся строки, но можно создавать списки, элементами которых являются любые
отображаемые объекты. Сфера применимости класса JList настолько широка, что вам
несомненно уже приходилось с ними сталкиваться.
Ранее элементы JList предоставлялись в виде ссылок на объекты типа Object. Однако
уже в версии JDK 7 компонент JList стал обобщенным и теперь объявляется так:
class JList<E>
где Е обозначает тип элементов списка. Таким образом, теперь класс JList является
безопасным в отношении контроля типов.
Класс JList имеет несколько конструкторов. Далее мы будем использовать конструктор
следующего вида:
JList(E[] элементы)
Этот конструктор создает список JList, содержащий элементы в виде массива, указанного
с помощью параметра элементы.
Несмотря на то что с классом JList можно работать напрямую, в большинстве случаев
его помещают в оболочку класса JScrollPane, автоматически поддерживающего
прокрутку содержимого. Вот как выглядит конструктор этого класса:
JScrollPane(Component компонент)
где компонент - это конкретный компонент, нуждающийся в возможностях прокрутки
(в данном случае это компонент типа JList). Помещение компонента JList в контейнер
JScrollPane автоматически обеспечивает возможность прокрутки длинных списков.
Это не только упрощает построение графического пользовательского интерфейса,
но и позволяет варьировать количество элементов списка, не изменяя при этом размеры
самого компонента JList.
Глава 16. Введение в Swing 591
При выборе пользователем элемента компонент JList генерирует событие List
SelectionEvent. Это же событие генерируется и при отмене выбора элемента. Для его
обработки используется реализация интерфейса ListSelectionListener, входящего в
пакет j avax. swing. event. В этом слушателе событий определен только один метод:
void valueChanged(ListSelectionEvent le)
где le обозначает ссылку на объект, сгенерировавший событие. И хотя в классе List
SelectionEvent имеются собственные методы, позволяющие следить за состоянием
списка, вы будете часто использовать для этой цели непосредственно сам объект JList.
Класс ListSelectionEvent также входит в пакет javax. swing. event.
По умолчанию класс JList позволяет выбирать несколько диапазонов элементов в
списке, но это поведение можно изменить, вызвав метод setSelectionMode () , определенный
в классе JList:
void setSelectionMode(int режим)
где параметр режим задает режим выбора элементов. Значение этого параметра должно
совпадать с одной из приведенных ниже констант, определенных в интерфейсе
ListSelectionModel, входящем в пакет j avax. swing.
SINGLE SELECTION
SINGLE INTERVAL SELECTION
MULTIPLE INTERVAL SELECTION
По умолчанию устанавливается режим MULTIPLE _ INTERVAL _ SELECTION, позволяющий
выбирать несколько диапазонов элементов в списке. В режиме SINGLE _INTERVAL _
SELECTION разрешен выбор только одного диапазона элементов, в режиме SINGLE
SELECTION - только одного элемента. Очевидно, что выбор единственного элемента
возможен и в остальных двух режимах, предназначенных для группового выбора элементов.
Индекс первого выбранного элемента (в режиме SINGLE_SELECTION - это индекс
единственного выбранного элемента) можно получить, вызвав метод get
Selectedindex (), форма объявления которого представлена ниже.
int getSelectedindex()
Индексирование начинается с нуля. Поэтому, если выбран первый элемент, метод
вернет значение О. Если же ни один из элементов не выбран, возвращается значение -1.
Для получения массива, содержащего все выбранные элементы, следует вызвать метод
getSelectedindices ():
int[J getSelectedindices()
В возвращаемом массиве индексы упорядочены от меньшего к большему. Если возвращается
массив нулевой длины, то это означает, что ни один из элементов не выбран.
Ниже приведен пример программы, в которой демонстрируется использование простого
списка JList, содержащего имена. Всякий раз, когда пользователь выбирает имя
из списка, генерируется событие ListSelectionEvent, которое обрабатывается методом
valueChanged (), объявленным в интерфейсе ListSelectionListener. Этот метод
определяет индекс выбранного элемента и отображает соответствующее имя. Результат
выполнения программы приведен на рис. 16.5.
592 Java 8: руководство для начинающих. 6-е издание
// Демонстрация использования простого списка JList
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
class ListDemo implements ListSelectionListener {
JList<String> jlst;
JLabel jlab;
JScrollPane jscrlp;
// Создать массив имен
"Sasha", "Josselyn", "Randy", Этот массиа будет
String names[J = { "Sherry", "Jon", "Rachel",
􀁴
"Тот", "Mary", "Ken 11, отображат•ся • списке JList
"Andrew", "Matt", "Todd" };
ListDemo () {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("JList Demo");
// Задать объект FlowLayout для менеджера компоновки
jfrm.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrm.setSize(200, 160);
// Прекратить работу программу, если
// пользователь закрывает приложение
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// Создать объект JList
jlst = new JList<String>(names); 4---- Создание списка
// Задать режим выбора одиночных элементов
jlst.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); 􀁵
// Добавить список в панель с полосами прокрутки
jscrlp = new JScrollPane(jlst);
Перекn�очение • режим
аwбора однначнwх эпементоа
// Задать предпочтительные размеры прокручиваемой панели
jscrlp.setPreferredSize(new Dimension(120, 90));
// Создать метку для отображения результатов выбора
jlab = new JLabel("Please choose а name"};
// Добавить обработчик событий выбора элемента из списка
Помещение списка
а обоnочку
nракручнааемой
nонеnи
j lst. addListSelectionListener (this) ; Прасnуwиаанне собwтнй
аыборо эnементоа нз списка
// Добавить список и метку в панель содержимого
jfrm.add(jscrlp);
jfrm.add(jlab);
// Отобразить фрейм
jfrm.setVisiЫe{true);
Глава 16, Введение в Swing 593
Оброботко событий
------выбора эnемеитов
из списка
/! Обработать события выбора элементов из списка
puЫic void valueChanged{ListSelectionEvent le) {
// Получить индекс элемента, состояние выбора
/! которого было изменено Поnучение индекса
4-----------эnемента с измененным
состоянием выбора
int idx = jlst.getSelectedindex{);
// Отобразить результат выбора, если элемент был выбран
if { idx ! = -1)
jlab.setText{"Current selection: " + names[idx]);
else // Иначе еще раз предложить сделать выбор
jlab.setText{"Please choose а name");
puЫic static void main{String args[J) {
/! Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater{new RunnaЫe{)
puЫic void run{) {
}
} ) ;
new ListDemo{);
Current se!ecl!on: Rachel
Рис. 16.5. Результат выполнения программы ListDemo
Рассмотрим исходный код программы более подробно. Прежде всего обратите внимание
на объявление массива names в начале программы. Он инициализируется строками,
содержащими разные имена. В конструкторе ListDemo () массив names используется
для создания объекта j lst. Конструктор, которому в качестве параметра передается
массив, как это имеет место в данном случае, автоматически создает экземпляр класса
JList, содержащий элементы массива. Следовательно, формируемый список будет состоять
из имен, хранящихся в массиве names.
Далее устанавливается режим, допускающий выбор только одного элемента из списка.
Затем объект j lst помещается в контейнер JScrollPane, а для панели прокрутки
задаются предпочтительные размеры 120 х 90. Это делается ради компактности и удобства
использования данного компонента. Для задания предпочтительных размеров компонента
служит метод setPreferredSize (). Как правило, предпочтительные размеры
определяют фактические размеры компонента, но не следует забывать, что некоторыми
менеджерами компоновки подобные запросы на установку размеров компонентов могут
игнорироваться.
594 Java 8: руководство для начинающих. 6-е издание
Когда пользователь выбирает элемент или изменяет свой выбор, генерируется событие
выбора элемента. Для получения индекса выбранного элемента в обработчике
valueChanged () вызывается метод getSelectedindex (). Поскольку для списка был задан
режим, ограничивающий выбор только одним элементом, этот индекс однозначно
определяет выбранный элемент. Затем индекс используется для обращения к массиву
names и получения имени выбранного элемента. Обратите внимание на то, что в данной
программе проверяется, равен ли индекс значению -1. Вспомните, что это значение
возвращается в том случае, если не был выбран ни один элемент. Именно это происходит
в ситуациях, когда событие генерируется в результате отмены пользователем своего
выбора. Не забывайте: событие выбора элемента генерируется как при выборе элемента,
так и при отмене выбора.
Упражнение 16.1 Утилита сравнения файлов на основе Swing
[ .. 􀂃􀂄-􀂅􀂆-􀂇-􀂈􀂉.:-􀂊.􀂋-􀂌􀂍 .. .: Несмотря на то что вы ознакомились лишь с небольшой частью би-
блиотеки Swing, вы уже в состоянии создавать приложения, име-
ющие практическую ценность. В упражнении 10.1 была создана консольная утилита
сравнения файлов. Теперь нам предстоит снабдить ее пользовательским интерфейсом,
созданным на основе компонентов Swing. Это позволит значительно улучшить внешний
вид утилиты и сделать ее более удобной в использовании. Ниже показано, как выглядит
рабочее окно утилиты сравнения файлов, созданной на основе Swing.
j, Compare Files g! 8 ·1􀀃
Rrst file:
!sample.txl
Secondfile:
jsample2.txt
R1es are not the same.
В процессе работы над данным проектом вы сможете сами убедиться, насколько библиотека
Swing упрощает создание приложений с графическим пользовательским интерфейсом.
Поэтапное описание процесса создания программы приведено ниже.
1. Создайте файл SwingFC. java и введите приведенные ниже комментарии и операторы
import.
/*
Упражнение 16.1.
Утилита сравнения файлов на основе Swing.
*/
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
Глава 16. Введение в Swing 595
2. Создайте класс SwingFC, начав с приведенного ниже исходного кода.
class SwingFC implements ActionListener {
JTextField jtfFirst; // хранит имя первого файла
JTextField jtfSecond; // хранит имя второго файла
JButton jbtnComp; // кнопка запуска операции сравнения файлов
JLabel jlabFirst, jlabSecond; // метки, отображающие
// подсказки для пользователя
JLabel jlabResult; // метка для отображения результата
// сравнения и сообщений об ошибках
Имена сравниваемых файлов указываются в текстовых полях j t f F i r s t и
jtfSecond. Для того чтобы начать сравнение файлов, указанных в этих полях,
пользователь должен щелкнуть на кнопке jЬtnComp. Подсказки для пользователя
отображаются с помощью меток j labFirst и j labSecond. Результаты сравнения
и сообщения об ошибках отображаются с помощью метки j labResul t.
3. Создайте конструктор класса SwingFC.
SwingFC () {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("Compare files");
// Задать объект FlowLayout для менеджера компоновки
jfrm.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrm.setSize(200, 190);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// Создать поля для ввода имен файлов
jtfFirst = new JTextField(l4);
jtfSecond = new JTextField(l4);
// Задать команды действия для текстовых полей
jtfFirst.setActionCommand("fileA");
jtfSecond.setActionCommand("fileB");
// Создать кнопку Compare
JButton jЬtnComp = new JButton("Compare");
// Добавить слушатель событий для кнопки Compare
jЬtnComp.addActionListener(this);
// Создать метки
jlabFirst = new JLabel("First file: ");
jlabSecond new JLabel("Second file: ");
jlabResult = new JLabel("");
596 Java 8: руководство для начинающих. 6-е издание
// Добавить компоненты в панель содержимого
jfrm.add(jlabFirst);
jfrm.add(jtfFirst);
jfrm.add(jlabSecond);
jfrm.add(jtfSecond);
jfrm.add(jbtnComp);
jfrm.add(jlabResult);
// Отобразить фрейм
jfrm.setVisiЫe(true);
Большая часть исходного кода этого конструктора должна быть вам уже знакома.
Обратите лишь внимание на следующую особенность: слушатель событий действий
вводится только для кнопки jbtnCornpare, в то время как аналогичные слушатели
для текстовых полей не добавляются. Дело в том, что содержимое полей
ввода текста требуется только в тот момент, когда нажимается кнопка Compare
(Сравнить), а все остальное время необходимости в знании их содержимого не
возникает. Поэтому реагировать на события, связанные с текстовыми полями, нет
никакого смысла. Когда вы напишете хотя бы несколько реальных программ с
использованием библиотеки Swing, вы обнаружите, что подобная ситуация с текстовыми
полями является довольно распространенной.
4. Начните создавать обработчик событий actionPerforrned () , как показано ниже.
Этот метод будет вызываться после щелчка на кнопке Compare.
// Сравнить файлы после нажатия кнопки Compare
puЫic void actionPerformed(ActionEvent ае) {
int i=O, j=O;
// Сначала убедиться в том, что введены имена обоих файлов
if(jtfFirst.getтext() .equals("")) {
jlabResult.setText("First file name missing.");
return;
if(jtfSecond.getText() .equals(""))
jlabResult.setText("Second file name missing.");
return;
Здесь проверяется, ввел ли пользователь имена обоих файлов в соответствующих
текстовых полях. Если какое-то из этих полей осталось пустым, выводится соответствующее
сообщение и обработчик возвращает управление.
5. Завершите создание обработчика событий, введя приведенный ниже исходный
код, который открывает файлы и сравнивает их содержимое.
// Сравнить файлы, используя оператор try с ресурсами
try (FileinputStream fl new FileinputStream(jtfFirst.getText());
FileinputStream f2 = new FileinputStream(jtfSecond.getText()))
// Сравнить содержимое обоих файлов
do {
i fl.read();
j = f2.read();
}
}
if(i != j) break;
while(i != -1 && j != -1);
if(i != j)
Глава 16. Введение в Swing 597
jlabResult.setText("Files are not the same.");
else
jlabResult.setText("Files compare equal.");
catch(IOException ехс) {
jlabResult.setText("File Error");
6. И наконец, добавьте в класс SwingFC метод main () .
puЬlic static void main(String args[]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЫe()
puЫic void run() {
}
} ) ;
new SwingFC () ;
7. Ниже приведен полный исходный код утилиты сравнения файлов.
/*
Упражнение 16.1.
Утилита сравнения файлов на основе Swing.
*/
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
class SwingFC implements ActionListener (
JTextField jtfFirst; // хранит имя первого файла
JTextField jtfSecond; // хранит имя второго файла
JButton jbtnComp; // кнопка запуска операции сравнения файлов
JLabel jlabFirst, jlabSecond; // метки, отображающие
// подсказки для пользователя
JLabel jlabResult; // метка для отображения результата
// сравнения и сообщений об ошибках
SwingFC() {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("Compare files");
598 Java 8: руководство для начинающих. 6-е издание
// Задать объект FlowLayout для менеджера компоновки
jfrrn.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrrn.setSize(200, 190);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrrn.setDefaultCloseOperation(JFrarne.EXIT_ON_CLOSE);
// Создать поля для ввода имен файлов
jtfFirst = new JTextField(14);
jtfSecond = new JTextField(14);
// Задать команды действия для текстовых полей
jtfFirst.setActionCornrnand("fileA");
jtfSecond.setActionCornrnand("fileB");
// Создать кнопку Cornpare
JButton jЬtnCornp = new JButton("Cornpare");
// Добавить слушатель событий для кнопки Cornpare
jЬtnCornp.addActionListener(this);
// Создать метки
jlabFirst = new JLabel("First file: ");
jlabSecond new JLabel("Second file: ");
j labResult = new JLabel ( "") ;
// Добавить компоненты в панель содержимого
jfrrn.add(jlabFirst);
jfrrn.add(jtfFirst);
jfrrn.add(jlabSecond);
jfrrn.add(jtfSecond);
jfrrn.add(jЬtnCornp);
jfrrn.add(jlabResult);
// Отобразить фрейм
jfrrn.setVisiЫe(true);
// Сравнить файлы после щелчка на кнопке Cornpare
puЫic void actionPerforrned(ActionEvent ае) {
int i=O, j=O;
// Сначала убедиться в том, что введены имена обоих файлов
if(jtfFirst.getText() .equals("")) {
jlabResult.setText("First file narne rnissing.");
return;
if(jtfSecond.getText() .equals(""))
jlabResult.setText("Second file narne rnissing.");
return;
Глава 16. Введение в Swing 599
// Сравнить файлы, используя оператор try с ресурсами
try (FileiпputStream fl new FileinputStream(jtfFirst.getText());
FileinputStream f2 = new FileinputStream(jtfSecond.getText()))
)
)
// Сравнить содержимое обоих файлов
do {
i = f1. read () ;
j = f2.read();
if(i != j) break;
while(i != -1 && j != -1);
if(i != j)
jlabResult.setText("Files are not the same.");
else
j labResult. setText ( "Files compare equal. ") ;
catch(IOException ехс) {
jlabResult.setText("File Error");
puЬlic static void main(String args[]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЬle()
puЬlic void run() {
)
) ) ;
new SwingFC ();
Применение анонимных внутренних
классов для обработки событий
Программы из примеров, рассмотренных до сих пор, не отличались особой сложностью.
Такими же несложными были и используемые в них обработчики событий, в
качестве которых выступал основной класс приложения, реализующий интерфейс соответствующего
слушателя событий, а все события передавались для обработки экземпляру
этого класса. И хотя такой подход вполне пригоден для написания прикладных
программ с пользовательским интерфейсом, его нельзя рассматривать как единственно
возможный. В подобных программах могут применяться и другие способы обработки
событий, происходящих в пользовательском интерфейсе. Во-первых, для каждого события
можно реализовать слушатель в отдельном классе. Благодаря этому разнородные события
будут обрабатываться в разных классах. И во-вторых, слушатели событий можно
реализовать с помощью анонимных внутренних классов.
У анонимного внутреннего класса нет имени, а экземпляр такого класса получают
динамически по мере необходимости. Анонимные внутренние классы позволяют значительно
упростить создание обработчиков для некоторых видов событий. Допустим,
имеется компонент jЬtn типа JButton. Тогда слушатель событий кнопки может быть
реализован следующим образом.
600 Java 8: руководство для начинающих. 6-е издание
jbtn.addActionListener(new ActionListener() {
puЫic void actionPerformed(ActionEvent ае)
// обработка события
}
}) ;
В данном примере используется анонимный внутренний класс, реализующий интерфейс
ActionListener. Обратите внимание на синтаксис, используемый при создании
этого класса. Тело внутреннего класса начинается после символа {, следующего за
выражением new ActionListener () . Обратите также внимание на то, что вызов метода
addActionListener () завершается закрывающей скобкой и точкой с запятой, т.е. как
обычно. Такой синтаксис используется при создании анонимных внутренних классов,
предназначенных для обработки любых событий. Очевидно, что для разнородных событий
задаются разные слушатели и реализуются разные методы.
Преимущество анонимного внутреннего класса заключается, в частности, в том, что
компонент, вызывающий методы этого класса, заранее известен. Так, в предыдущем
примере не было никакой необходимости вызывать метод getActionCoпunand () , чтобы
выяснить, каким именно компонентом было сгенерировано событие, поскольку метод
actionPerformed () может быть вызван в подобной реализации только при наступлении
событий, сгенерированных компонентом j Ьtn. С реальным примером использования
анонимных внутренних классов вы ознакомитесь в следующем разделе при создании
Swing-aплeтa.
В случае событий, слушатели которых реализуют функциональный интерфейс,
обработка событий может быть выполнена с использованием лямбда-выражений.
Так, лямбда-выражения могут использоваться для обработки событий действий, поскольку
в интерфейсе ActionListener определен только один абстрактный метод -
actionPerformed (). Реализация интерфейса ActionListener с помощью лямбдавыражений
- это альтернатива явному объямению анонимного внутреннего класса, отличающаяся
большей компактностью. Например, для компонента jЬtn типа JВutton
слушатель событий может быть реализован следующим образом.
jbtn.addActionListener((ae) -> {
// обработка события
}
} ) ;
Как и в случае подхода, в котором используется анонимный внутренний класс, здесь
известен объект, генерирующий событие. В данном случае лямбда-выражение применяется
только к кнопке jЬtn.
Очевидно, что в ситуациях, когда событие может быть обработано с использованием
одиночного лямбда-выражения, в использовании блочных лямбд нет никакой необходимости.
Ниже в качестве примера предстамен обработчик событий действий для
кнопки Up в рассмотренной ранее программе ButtonDemo. В нем требуется только одиночное
лямбда-выражение.
jЬtnUp.addActionListener((ae) -> jlab.setText("You pressed Up"));
Заметьте, насколько короче стал код по сравнению с его первоначальным вариантом.
Он также короче того кода, который вы имели бы, если бы использовали анонимный
внутренний класс
Если говорить в общем, то лямбда-выражения могут использоваться для обработки
событий во всех случаях, когда слушатель объявляет функциональный интерфейс.
Глава 16. Введение в Swing 601
Например, ItemListener является функциональным интерфейсом. Разумеется, выбор
того, следует ли использовать традиционный подход, анонимные внутренние классы
или лямбда-выражения, определяется конкретной природой вашего приложения.
Создание аплета средствами Swing
Ранее рассматривались примеры программ Swing. Но компоненты Swing нередко
применяются и для создания аплетов. Swing-anлeты аналогичны аплетам, создаваемым
на основе библиотеки АWГ (см. главу 14), за исключением одного существенного отличия:
аплет Swing расширяет класс JApplet, производный от класса Applet, а не сам
этот класс. Таким образом, подкласс JApplet наследует все функциональные возможности
своего суперкласса Applet, но кроме того, в него добавлены средства поддержки
библиотеки Swing. Класс JApplet - это контейнер Swing верхнего уровня, который
включает в себя все разновидности описанных ранее панелей. Поэтому все компоненты
Swing-anлeтa добавляются в панель содержимого контейнера JApplet точно так же, как
в панель содержимого контейнера JFrame.
Для управления жизненным циклом аплетов Swing используются те же четыре метода,
что и ранее рассмотренные методы аплета АWТ: init (), st art (), stop () и
destroy () ( см. главу 15). Очевидно, что в переопределении нуждаются только те из них,
которые необходимы создаваемому аплету. Вообще говоря, операции рисования выполняются
в аплетах Swing и АWГ по-разному. Поэтому в Swing-aплeтax метод paint ()
обычно не требует переопределения.
Важная деталь: любое взаимодействие с пользователем в аплетах Swing должно осуществляться
в потоке диспетчеризации событий, о чем уже говорилось в этой главе. Это
требование является обязательным для всех программ Swing.
Ниже приведен пример аплета Swing. В нем используется та же функциональность,
что и в примере с кнопкой, но в данном случае программа реализована в виде аплета.
Для обработки событий в аплете используются анонимные внутренние классы. Вид результата
в окне средства просмотра аплетов appletviewer показан на рис. 16.6.
// Простой аплет Swing
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
/*
Для запуска аплета можно использовать следующий НТМL-код:
<object code="MySwingApplet" width= 200 height= BO>
</object>
*/
puЬlic class MySwingApplet extends JApplet {
JButton jbtnUp;
JButton jbtnDown;
JLabel jlab;
// Инициализировать аплет
____ дnnеты Swing доn*ны pocwиpinь
КIIOCC JApplet
602 Java 8: руководство для начинающих. 6-е издание
puЫic void ini t () {
try {
SwingUtilities.invokeAndWait(new RunnaЫe () {
puЫic void run() {
Испоnьэовонне методо
4-----invokeAndWait ()
дпя соэдоння GUI
makeGUI(); // инициализировать графический интерфейс
}
}) ;
catch(Exception ехс) {
System.out.println("Can't create because of "+ ехс);
// В этом аплете отсутствует необходимость переопределять
11 методы start (), stop () и destroy ()
// Установить и инициализировать графический интерфейс
private void makeGUI() {
// Задать менеджер компоновки FlowLayout для аплета
setLayout(new FlowLayout());
// Создать две кнопки
jbtnUp = new JButton("Up");
jbtnDown = new JButton("Down");
// Добавить слушатель событий кнопки Up
jbtnUp.add.ActionListener(new ActionListener()
puЫic void actionPerformed(ActionEvent ае)
jlab.setText("You pressed Up.");
}
} ) ;
// Добавить слушатель событий кнопки Down.
// Для обработки событий кнопки Down
// используется анонимный внутренний класс.
jbtnDown.addActionListener(new ActionListener()
puЫic void actionPerformed(ActionEvent ае) {
jlab.setText("You pressed down.");
}
} ) ;
// Добавить кнопки в панель содержимого
add(jЬtnUp);
add(jЬtnDown);
// Создать текстовую метку
jlab = new JLabel("Press а button.");
/! Добавить метку в панель содержимого
add(jlaЬ);
Испопьэовоние
ононимноrо внутреннего
кпосса дпя обработки
событий кнопок
Глава 16. Введение в Swing 603
ШI \oow􀀃 1
You pressed down.
Applet started.
Рис. 16.6. Результат выполнения аплета Swing
Относительно данного аплета можно сделать несколько важных замечаний. Во-первых,
класс MySwingApplet расширяет класс JApplet. Как ранее уже отмечалось, все
аплеты Swing расширяют класс JApplet, а не класс Applet. Во-вторых, в методе ini t ()
компоненты Swing инициализируются в отдельном потоке диспетчеризации событий,
в котором вызывается метод makeGUI (). Это достигается за счет использования метода
invokeAndWai t () вместо метода invokeLater (). Аплеты должны использовать метод
invokeAndWai t (), поскольку метод ini t () не возвращает управление до завершения
процесса инициализации. По существу, метод start () должен вызываться лишь по завершении
инициализации, когда графический пользовательский интерфейс уже будет
полностью создан.
В методе makeGUI () создаются две кнопки и метка, и с кнопками связываются слушатели
событий. Обратите внимание на то, что обработчики событий реализуются в
виде анонимных внутренних классов. Вы можете использовать данный пример реализации
обработчиков событий в качестве образца при разработке обработчиков других
событий. Одно из главных преимуществ такого подхода состоит в том, что объект, генерирующий
событие, заранее известен, поскольку именно в нем создается экземпляр
анонимного внутреннего класса. В связи с этим отпадает необходимость в получении
команды действия для того, чтобы определить, какая именно кнопка породила событие.
И наконец, компоненты добавляются на панель содержимого. Несмотря на простоту
данного примера, он демонстрирует общий подход к созданию любого аплета Swing с
графическим пользовательским интерфейсом.
1flJ
Вопросы и упражнения для сомопроверки
1. Компоненты АWТ являются тяжеловесными, а компоненты Swing - ___ _
2. Можно ли изменить стиль оформления компонента Swing? Если да, то какое
средство позволяет это сделать?
3. Какой контейнер верхнего уровня чаще всего используется в приложениях?
4. Контейнер верхнего уровня содержит несколько панелей. На какой из них размещаются
компоненты?
5. Как создать ссьmку, отображающую сообщение "Выберите элемент списка 11 ?
6. В каком потоке должно осуществляться любое взаимодействие с компонентами
графического пользовательского интерфейса?
604 Java 8: руководство для начинающих. 6-е издание
7. Какая команда действия связывается по умолчанию с компонентом JВutton? Как
изменить команду действия?
8. Какое событие генерируется после щелчка на кнопке?
9. Как создать текстовое поле шириной до 32 символов?
10. Можно ли задать команду действия для компонента JТextField? Если можно, то
как это сделать?
11. С помощью какого компонента Swing можно создать флажок? Какое событие генерируется
при установке или сбросе флажка?
12. Компонент JList отображает список элементов, которые может выбирать пользователь.
Верно или неверно?
13. Какое событие генерируется при выборе пользователем элемента из списка типа
JList или отмене выбора?
14. В каком методе задается режим выбора элементов списка JList? С помощью какого
метода можно получить индекс первого выбранного элемента?
15. Подкласс какого класса нужно создать при разработке аплета Swing?
16. Обычно при создании исходного пользовательского интерфейса в аплетах Swing
используется метод invokeAndWai t (). Верно или неверно?
17. Добавьте в утилиту сравнения файлов, созданную в упражнении 16.1, флажок со
следующей пояснительной надписью: Show position of mismatch (Показывать
позицию расхождения). Если этот флажок установлен, программа должна отображать
позицию, в которой обнаружено первое расхождение в содержимом сравниваемых
файлов.
18. Измените программу ListDemo таким образом, чтобы она допускала выбор нескольких
элементов списка.
19. Задание повышенной сложности. Преобразуйте класс Help, созданный в упражнении
4.1, в программу Swing с графическим пользовательским интерфейсом. Сведения
о ключевых словах (for, while, switch и т.д.) должны отображаться с помощью
компонента JList. При выборе пользователем элемента списка должно
выводиться описание синтаксиса выбранного ключевого слова. Для отображения
многострочноrо текста вместо метки можно использовать средства HTML. В этом
случае текст должен начинаться с дескриптора <html> и завершаться дескриптором
</html>. В итоге текст будет автоматически размечен в виде НТМL-документа.
Помимо прочих преимуществ, такая разметка текста позволяет создавать мноrострочные
метки. В качестве примера ниже приведена строка кода, в которой
создается метка, отображающая две текстовые строки: первой выводится строка
"Тор", а под ней - строка "Bottom".
JLabel jlabhtml = new JLabel("<html>Top<br>Bottom</html>");
Решение этого упражнения не приводится. Ведь уровень вашей подготовки уже
настолько высок, что вы в состоянии самостоятельно разрабатывать программы
на Java!
Глава 17
Введение в JavaFX
606 Java 8: руководство для начинающих. 6-е издание
В этой главе ...
􀃛 Основные понятия JavaFX: платформа, сцена, узел, граф сцены
ei> Жизненный цикл приложений JavaFX
h Создание каркаса аплета
􀃜 Общая форма приложения JavaFX
ft Запуск приложения JavaFX
􀃝 Создание компонента Label
11ь, Использование компонента Button
􀃞 Обработка событий
<t;; Использование компонента CheckBox
t,a Работа с компонентом ListView
􀃟 Создание компонента TextField
􀃠 Добавление эффектов
·􀃡 Применение преобразований
в стремительно развивающемся компьютерном мире постоянны лишь изменения, а
наука и искусство программирования непрерывно развиваются, осваивая все новые
рубежи. Поэтому нет ничего удивительного в том, что библиотеки Java, поддерживающие
графический интерфейс пользователя (GUI), также оказались вовлеченными в
этот процесс. Напомним, что в Java первой такой библиотекой была AWI Вслед за АWГ
была разработана библиотека Swing, которая намного превосходила по возможностям
свою предшественницу. Несмотря на успешность библиотеки Swing, создавать с ее помощью
всевозможные визуальные эффекты, столь востребованные во многих современных
приложениях, довольно затруднительно. Кроме того, изменения коснулись самих
концептуальных основ проектирования пользовательских интерфейсов, что заставляло
искать новые подходы к разработке GUI. Ответом разработчиков на запросы Jаvа-сообщества
стала библиотека JavaFX, представляющая собой GUl-фреймворк следующего
поколения. Данная глава содержит минимальный набор необходимых сведений, знание
которых позволит вам в кратчайшие сроки приступить к работе с этой новой мощной
системой.
Важно отметить, что развитие библиотеки JavaFX происходило в два этапа. Ранние
версии JavaFX базировались на языке сценариев JavaFX Script. Однако в более поздних
версиях, начиная с JavaFX 2.0, этот язык уже не поддерживается, и вместо него предлагается
новый программный интерфейс для создания JаvаFХ-приложений полностью
на языке Java. В JDK 7 (обновление 4) и более поздних версиях Java библиотека JavaFX
входит в стандартный комплект поставки. Последней версией библиотеки, включенной
в комплект JDK 8, является JavaFX 8. (При этом, чтобы положить начало согласованной
нумерации версий Java и JavaFX, номера версий JavaFX от 3 до 7 были пропущены.)
Далее обсуждается версия JavaFX 8 как самая последняя версия библиотеки JavaFX на
Глава 17. Введение в JavaFX 607
момент написания книги. Соответственно, в тех местах, rде термин JavaFX встречается
без конкретизации номера версии, под ним подразумевается версия JavaFX 8.
Прежде чем продолжить, следует дать ответ на один вопрос, который естественным
образом возникает в отношении JavaFX: предназначалась ли библиотека JavaFX для
того, чтобы заменить собой Swing? По сути, так оно и было. Однако некоторое время
Swing еще будет оставаться неотъемлемой частью программирования на языке Java. Это
обусловлено наличием больших объемов унаследованного кода с графическим интерфейсом
на основе Swing. Немаловажен и тот факт, что в настоящее время огромное количество
программистов, освоивших технологию Swing, продолжают использовать ее в
своих разработках. Тем не менее абсолютно очевидно, что будущее принадлежит JavaFX.
Иными словами, любой программист, пишущий программы на Java, должен владеть технологией
JavaFX.
ПРИМЕЧАНИЕ
В данной главе предполагается, что вы уже имеете представление о том, что такое графический
интерфейс пользователя и кок обрабатываются события (см. главы 15 и 16).
Базовые понятия JavaFX
Прежде чем мы приступим к созданию приложения JavaFX, вам необходимо ознакомиться
с основными понятиями и возможностями этой технологии. Несмотря на некоторое
сходство JavaFX с другими графическими интерфейсами Java, такими как АWГ
и Swing, между ними имеются существенные различия. Аналогично Swing, компоненты
JavaFX относятся к категории легковесных, а способы обработки событий просты и интуитивно
понятны. Но если говорить об общих принципах организации библиотеки и
взаимосвязи ее основных компонентов между собой, то JavaFX значительно отличается
как от Swing, так и от АWГ. Поэтому вам стоит внимательно изучить материал, изложенный
в следующих разделах.
Пакеты JavaFX
Библиотека JavaFX содержится в пакетах, имена которых начинаются с префикса
javafx. К моменту написания данной книги API библиотеки включал более 30 пакетов.
В качестве примера приведем имена следующих пакетов: javafx. application,
javafx. stage, javafx. scene и javafx. scene. layout. В этой главе нам понадобятся
всего лишь несколько пакетов JavaFX, однако вам стоит потратить некоторое время на
краткое ознакомление с остальными пакетами этой библиотеки, поскольку спектр ее
возможностей очень обширен.
Классы Stage и Scene
В качестве центральной метафоры, на основе которой создавалась библиотека
JavaFX, разработчики выбрали театральные подмостки (stage). Как и в любом реальном
театре, подмостки служат сценической площадкой, на которой разыгрываются сцены
(scenes). Образно говоря, подмостки, или театральная платформа, определяют пространственные
границы для сцен, которые, в свою очередь, формируются из других элементов.
Аналогично этому любое JаvаFХ-приложение содержит по крайней мере одну
608 Java 8: руководство для начинающих. 6-е издание
платформу и одну сцену. В JavaFX API эти элементы инкапсулируются классами Stage и
Scene. Чтобы создать JаvаFХ-приложение, вы должны добавить в объект Stage хотя бы
один объект Scene. Рассмотрим более детально, что собой представляют эти два класса.
Класс Stage - это контейнер верхнего уровня. Все приложения JavaFX автоматически
получают доступ к одному контейнеру класса Stage, называемому основной платформой
(primary stage). Основная платформа предоставляется исполняющей системой
при запуске приложения. Несмотря на возможность создания нескольких платформ, в
большинстве случаев одной платформы оказывается достаточно.
Как уже отмечалось, класс Scene - это контейнер для элементов, составляющих
сцену. Этими элементами могут быть кнопки и флажки, текст и графика. Для создания
сцены вы будете добавлять эти элементы в экземпляр класса Scene.
Узлы и графы сцены
Отдельные элементы сцены называют узлами (nodes). Например, узлом является
кнопка. В то же время узлы сами по себе могут состоять из групп узлов. Кроме того,
у любого узла могут быть дочерние узлы. Узел, имеющий дочерние узлы, называют родительским
узлом (parent node), или узлом ветвления (branch node). Узлы, не имеющие
дочерних узлов, являются оконечными и называются листьями (leaves). Совокупность
всех узлов сцены называется графом сцены (scene graph) и образует дерево (tree), т.е. иерархическую
структуру узлов.
Особую роль в графе сцены играет корневой узел, или корень (root). Им является узел
верхнего уровня, и это единственный узел в графе сцены, не имеющий родительского
узла. Таким образом, за исключением корневого узла, все остальные узлы имеют родителей
и являются непосредственными или косвенными потомками корневого узла.
Класс Node является базовым для всех типов узлов. Сушествуют также другие классы,
являющиеся прямыми или косвенными наследниками класса Node. В частности, таковыми
являются классы Parent, Group, Region и Control.
Панели компоновки
Библиотека JavaFX предоставляет нескольких панелей компоновки, с помощью которых
можно управлять процессом размещения элементов в сцене. Например, класс
FlowPane обеспечивает плавающую компоновку, а класс GridPane - табличную компоновку
элементов в виде строк и столбцов. Также доступен ряд других менеджеров компоновки,
например BorderPane (аналогичен компоновщику BorderLayout библиотеки
АWГ). Соответствующие классы находятся в пакете j avafx. scene. layout.
Класс Application и жизненный цикл приложения
Приложение JavaFX должно быть подклассом класса Application, находящегося
в пакете javafx.application. Таким образом, класс приложения должен расширять
класс Application. Класс Application определяет три метода, управляющих жизненным
циклом приложения: ini t () , start () и stop () , которые приложение может переопределить.
Формы их объявления представлены ниже в порядке вызова методов.
void init ()
abstract void start(Stage основная_платформа)
void stop ()
Глава 17. Введение в JavaFX 609
Метод init () вызывается в начале выполнения приложения. Он используется для
инициализации всех необходимых переменных. Однако, как будет показано далее, его
нельзя использовать для создания платформы или формирования сцены. Если никакая
инициализация не требуется, данный метод можно не переопределять, поскольку его
пустая версия предоставляется по умолчанию.
Метод start () вызывается после метода init (). Именно с него начинается работа
приложения, и его можно использовать для конструирования и установки параметров
сцены. Обратите внимание на то, что в качестве аргумента ему передается ссылка на
объект Stage. Этот объект и есть та самая основная платформа, которую предоставляет
исполняющая система. Заметьте также, что этот метод объявлен как абстрактный, и поэтому
должен переопределяться в приложении.
При прекращении работы приложения вызывается метод stop (). Именно в нем организуется
выполнение всех рутинных операций, связанных со сборкой мусора и освобождением
ресурсов, захваченных приложением. Если такие действия не требуются,
метод можно не переопределять, поскольку по умолчанию предоставляется его пустая
версия.
ЗапускприложенияJаvаFХ
Чтобы запустить автономное JаvаFХ-приложение, вы должны вызвать метод
launch (), определенный в интерфейсе Application. Этот метод имеет две формы объявления.
Ниже приведена та из них, которая используется в этой главе.
puЫic static void launch(String . .. аргументы)
Здесь параметр аргументы - список строк (возможно, пустой), обычно являющихся
аргументами командной строки. Вызов метода launch () приводит к загрузке приложения,
сопровождающейся последующими вызовами методов ini t () и start ().
Возврат из метода launch () происходит лишь тогда, когда приложение завершает работу.
Данная версия метода launch () загружает приложение в класс, который расширяет
класс Application и является точкой входа в приложение. Вторая форма метода
launch () позволяет указать в качестве точки входа класс, отличный от того, в котором
вызывается метод.
Прежде чем продолжить, необходимо сделать одно важное замечание: приложения,
упакованные с помощью средства javafxpackager (или эквивалентного ему средства
интегрированной среды разработки), не нуждаются в вызове метода launch () . Вместе с
тем его включение в приложение во многих случаях упрощает процессы тестирования и
отладки и позволяет использовать программу, не создавая JАR-файл. Поэтому в данной
главе вызов метода launch () всегда включается в приложение.
КаркасприложенияJаvаFХ
Все приложения JavaFX создаются на основе одного и того же базового каркаса. Поэтому,
прежде чем использовать другие возможности, полезно изучить, что собой представляет
этот каркас. Это позволит не только продемонстрировать общую структуру
JаvаFХ-приложения, но и показать, как запускается приложение и вызываются методы
жизненного цикла. Приложение будет выводить на консоль сообщения, подсказывающие,
когда именно вызывается тот или иной метод. Обратимся к приведенному ниже
коду.
61 О Java 8: руководство для начинающих. 6-е издание
// Каркас приложения JavaFX
irnport javafx.application.*;
irnport javafx.scene.*;
irnport javafx.stage.*;
irnport javafx.scene.layout.*;
puЫic class JavaFXSkel extends Application
puЫic static void rnain(String[] args) {
Systern.out.println("Зaпycк приложения JavaFX");
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод init()
puЫic void init{) {
Systern.out.println{"B теле метода init{)");
// Переопределить метод start()
puЫic void start{Stage rnyStage)
Systern.out.println{"B теле метода start{)");
// Установить заголовок окна приложения
rnyStage.setTitle("Kapкac приложения JavaFX");
// Создать корневой узел. В данном случае
// используется плавающая компоновка, но возможны
// и другие варианты.
FlowPane rootNode = new FlowPane {) ; Соэдание корневоrо уэnа
// Создать сцену
Scene rnyScene = new Scene{rootNode, 300, 200); -----Соэдание сценw
// Установить сцену на платформе
rnyStage.setScene{rnyScene) ; -----Установка сценw в окне
// Отобразить платформу вместе с ее сценой
rnyStage. show {) ; Оrображенне сценw
// Переопределить метод stop{).
puЫic void stop{) {
Systern.out.println{"B теле метода stop{)");
Глава 17. Введение в JavaFX 611
Конечно, это совсем небольшое приложение, но его можно скомпилировать и выполнить.
В итоге мы получаем пустое окно, однако при этом на консоль выводится следующий
результат.
Запуск приложения JavaFX
В теле метода init()
В теле метода start()
При закрытии окна в консоли отображается следующее сообщение:
В теле метода stop()
Конечно же, в реальной программе методы, управляющие жизненным циклом приложения,
никакой информации в выходной поток System. out обычно не выводят. Здесь
это сделано лишь для того, чтобы было ясно, когда именно происходит вызов каждого
метода. Кроме того, как ранее уже отмечалось, методы ini t () и stop () необходимо переопределять,
только если при запуске и остановке приложения должны выполняться
какие-то особые действия. В противном случае можно обойтись реализациями этих методов,
предлагаемыми по умолчанию классом Application.
Перейдем к подробному рассмотрению программы. Она начинается с импорта четырех
пакетов. Первым импортируется пакет javafx.application, в котором содержится
класс Application. В пакете javafx. scene находится класс Scene, а в пакете javafx.
stage - класс Stage. Пакет javafx. scene. layout предоставляет ряд панелей компоновки.
В программе используется панель FlowPane.
Далее создается класс приложения JavaFXSkel. Заметьте, что он расширяет класс
Application. Как уже отмечалось, Application - это класс, наследованием которого
создаются все приложения JavaFX. Класс JavaFXSkel содержит четыре метода. Первый
из них - метод main () - используется для загрузки приложения посредством вызова
метода launch (). Обратите внимание на то, что методу launch () передается параметр
args, принимаемый методом main (). Такой подход является обычным, однако методу
launch () можно передать другой набор параметров, в том числе пустой. Еще один
важный момент: метод launch () требуется только автономным приложениям; во всех
остальных случаях он не нужен. Однако в силу причин, приведенных выше, все программы
в этой главе включают как метод main (). так и метод launch ().
Когда запускается приложение, исполнительная среда JavaFX в первую очередь вызывает
метод ini t () . В данном случае этот метод просто выводит на консоль некоторое
сообщение исключительно для того, чтобы сделать пример более наглядным, но обычно
в нем выполняются все необходимые действия по инициализации приложения. Разумеется,
если инициализация не требуется, то в переопределении метода ini t () нет никакой
необходимости, поскольку по умолчанию всегда предоставляется его пустая реализация.
Следует еще раз подчеркнуть, что метод ini t () не может быть использован для
создания основной платформы или сцены GUI. Эти элементы должны конструироваться
и отображаться методом start () .
Когда метод ini t () заканчивает свою работу, вызывается метод start () . Именно в
этом методе создается начальная сцена и устанавливается основное окно приложения.
Проанализируем этот метод строка за строкой. Прежде всего обратите внимание на передаваемый
ему параметр типа Stage. При вызове метода start () этот параметр получает
ссылку на основную платформу приложения. Именно этот контейнер будет содержать
сцену, используемую приложением.
612 Java 8: руководство для начинающих. 6-е издание
После вывода на консоль сообщения, у ведомляющего о начале работы метода
start (), вызывается метод setTi tle (), устанавливающий заголовок окна:
myStage.setTitle("Kapкac приложения JavaFX");
Поступать так вовсе необязательно, но в случае автономных приложений такая практика
является общепринятой. Этот заголовок становится именем основного окна приложения.
На следующем этапе создается корневой узел сцены. Корневой узел является единственным
узлом графа сцены, не имеющим родительского узла. В данном случае корневой
узел - это объект типа FlowPane, но существуют и друтие классы, которые могут
служить таким узлом.
FlowPane rootNode = new FlowPane();
Как уже отмечалось, панель FlowPane использует плавающую компоновку. Этот тип
компоновки характеризуется тем, что элементы последовательно располагаются в строках
с автоматическим переходом на следующую строку, если для размещения очередного
элемента в текущей строке не хватает места. (Следовательно, здесь мы имеем дело с
тем же типом компоновки, что и в случае класса FlowLayout, входящего в библиотеки
АWГ и Swing.) В данном примере элементы компонуются построчно в горизонтальном
направлении, однако также возможна компоновка по вертикальным столбцам. И хотя в
данном приложении этого не требуется, существует возможность задания других видов
компоновки, например, компоновка элементов в горизонтальном или вертикальном направлении
с указанием зазора между соседними элементами или их выравнивания.
В следующей строке кода корневой узел используется для создания объекта сцены:
Scene myScene = new Scene(rootNode, 300, 200);
Класс Scene имеет несколько конструкторов. Мы используем конструктор, который
создает сцену с заданным корневым узлом и заданными значениями ширины и высоты:
Scene(Parent корень, douЫe ширина, douЫe высота)
Заметьте, что параметр корень имеет тип Parent. Этот класс является производным
от класса Node и инкапсулирует узлы, у которых имеются дочерние узлы. Также обратите
внимание на то, что для значений ширины и высоты задан тип douЫe. В случае
необходимости это позволяет передавать методу нецелочисленные значения. В данном
примере корневым является узел типа rootNode, а значения ширины и высоты составляют
соответственно 300 и 200.
В следующей строке программы объект myScene устанавливается в качестве сцены
для платформы myStage:
myStage.setScene(myScene);
где setScene () - метод, определенный в классе Stage, который настраивает параметры
сцены в соответствии с переданным ему аргументом.
В тех случаях, когда сцена в дальнейшем не используется, два предьщущих вызова
могут быть объединены в один:
myStage.setScene(new Scene(rootNode, 300, 200));
В последующих примерах преимущество будет отдаваться именно этой форме вызова
методов ввиду ее компактности.
Глава 17. Введение в JavaFX 613
Последняя строка метода start () отображает платформу и сцену:
myStage.show();
По существу, метод show () отображает окно, совместно создаваемое платформой и
сценой.
При закрытии приложения его окно удаляется с экрана, и исполнительная система
JavaFX вызывает метод stop (). В данном случае этот метод выводит сообщение на консоль,
тем самым подтверждая факт своего вызова. Однако в реальных приложениях он,
как правило, не выводит никакой информации. Кроме того, если выполнять какие-либо
специальные действия при прекращении работы приложения не требуется, то отпадает
и необходимость в переопределении метода stop () , поскольку его пустая реализация
предоставляется по умолчанию.
Компиляция и выполнение программы JavaFX
Одним из преимуществ технологии JavaFX является то, что одна и та же программа
способна выполняться в различных средах выполнения. Например, программа JavaFX
может выполняться в виде автономного настольного приложения, в среде веб-браузера
или в виде приложения Web Start. В то же время в некоторых случаях могут потребоваться
различные дополнительные файлы, например файл HTML или JNLP (Java Network
Launch Protocol).
Вообще говоря, любая программа JavaFX компилируется подобно любой другой программе.
Вместе с тем в зависимости от целевой среды выполнения может потребоваться
выполнение некоторых дополнительных шагов. Поэтому во многих случаях самым
простым способом является компиляция приложения JavaFX в какой-либо интегрированной
среде разработки (lntegrated Development Environment - IDE), обеспечивающей
полную поддержку программирования в рамках технологии JavaFX. Если вам нужно
просто скомпилировать и протестировать JаvаFХ-приложения, представленные в данной
главе, то это можно легко сделать средствами командной строки. Для этого достаточно
скомпилировать и выполнить приложение, как это обычно делается с помощью
команд javac и java. В результате вы получите настольное приложение, выполняющееся
в настольной системе.
Поток выполнения приложения
В предыдущем обсуждении уже отмечалось, что метод ini t () не может быть использован
для конструирования платформы или сцены. Эти элементы нельзя создавать
и в конструкторе приложения. Причина в том, что и платформа, и сцена должна
конструироваться в потоке приложения. При этом конструктор приложения и метод
ini t () вызываются в основном потоке, который также называют стартовым потоком.
Вот почему их нельзя использовать для вызова конструкторов платформы и сцены. Вместо
этого для создания начального графического интерфейса должен вызываться метод
start (), как было сделано в примере, поскольку он вызывается в потоке приложения.
Кроме того, из потока приложения должны выполняться и любые изменения текущего
состояния GUI. К счастью, в JavaFX события передаются программе через
поток приложения. Поэтому для взаимодействия с графическим интерфейсом могут
использоваться обработчики событий. Метод stop () также вызывается в потоке приложения.
614 Java 8: руководство для начинающих, 6-е издание
Простой элемент управления
JavaFX: компонент LaЬel
Основными составляющими большинства пользовательских интерфейсов являются
элементы управления, поскольку через них пользователь может взаимодействовать
с приложением. Как и следовало ожидать, JavaFX предлагает богатый ассортимент элементов
управления. Простейшим из них является метка, поскольку она просто отображает
текстовое сообщение или графический элемент. Для наших целей метки удобны
тем, что они просты в использовании и хорошо подходят для демонстрации методов построения
графов сцены.
В JavaFX метка представляется экземпляром класса Label, находящегося в пакете
javafx. scene. control. Класс Label наследует свойства и методы от нескольких классов,
включая классы Labeled и Control. Класс Labeled определяет ряд возможностей,
общих для всех элементов с метками (т.е. тех, которые могут содержать текст), а класс
Control - возможности, свойственные всем элементам управления.
Ниже мы будем использовать следующий конструктор класса Label:
Label(String строка);
Отображаемая строка задается параметром строка.
Созданную метку (или любой другой элемент управления) необходимо добавить к
содержимому сцены, что означает добавление ее в граф. С этой целью следует прежде
всего вызвать метод getChildren () для корневого узла графа сцены. Возврашаемое значение
представляет собой список дочерних узлов типа ObservaЬleList<Node>. Класс
ObservaЬleList находится в пакете javafx. collections и наследует класс j ava. util.
List, являющийся частью библиотеки Java Collections Framework. Класс List определяет
коллекцию, представляющую список объектов. Обсуждение класса List и библиотеки
Collections Framework выходит за рамки данной книги, однако класс ObservaЫeList
позволяет легко добавлять дочерние узлы. Это достигается вызовом метода add () для
списка дочерних узлов, возвращенного методом getChildren (), с передачей ссылки на
добавляемый узел, каковым в данном случае является метка.
Следуюшая программа материализует предмет предыдущего обсуждения в виде простого
приложения JavaFX, отображающего метку.
// Демонстрация использования меток JavaFX
import javafx.application.*;
import javafx.scene.*;
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
puЫic class JavaFXLabelDemo extends Application
puЫic static void main(String[] args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод start()
puЫic void start(Stage myStage)
Глава 17. Введение в JavaFX 615
// Задать заголовок окна приложения
myStage.setTitle("Use а JavaFX label.");
// Использовать FlowPane для корневого узла
FlowPane rootNode = new FlowPane();
// Создать сцену
Scene myScene = new Scene(rootNode, 300, 200);
// Установить сцену на платформе
myStage.setScene(myScene);
􀀛------------ Соэдание метки
// Создать метку
Label myLabel = new Label("JavaFX is а powerful GUI");
// Добавить метку в граф сцены
rootNode.getChildren() .add(myLabel);
// Отобразить платформу и ее сцену
myStage.show();
СПРОСИМ У ЭКСПЕРТА
-----Добовnение метки в rроф сцены
ВОПРОС. Вы рассказали о том, как добавить узел в граф сцены. Существуют ли
способы удаления узлов из графа?
ОТВЕТ. Конечно. Чтобы удалить узел из графа сцены, следует вызвать метод
remove () для объекта ObservaЬleList. Например, вызов
rootNode.getChildren() .remove(myLabel);
удаляет объект myLabel из сцены. Вообще говоря, класс ObservaЬleList обеспечивает
поддержку широкого ряда методов для управления списками. Вот
лишь два примера. Чтобы определить, является ли список пустым, следует вызвать
метод isEmpty (). Также можно определить количество узлов в списке,
вызвав метод size (). Вам будет полезно самостоятельно исследовать возможности
класса ObservaЬleList в процессе изучения JavaFX.
Результат выполнения программы представлен на приведенном ниже рисунке.
616 Java 8: руководство для начинающих. 6-е издание
В этой программе особого внимания заслуживает следующая строка:
rootNode.getChildren() .add(myLabel);
Этот код добавляет метку в список узлов, по отношению которых узел rootNode является
родительским. При желании эту строку можно бьmо бы разделить на отдельные
вызовы, но чаще всего она будет встречаться вам именно в том виде, в каком приведена
выше.
Прежде чем продолжить, следует подчеркнуть, что класс ObservaЬleList предоставляет
метод addAll () , позволяющий добавить сразу два и более дочерних узла в граф
сцены с помощью одного вызова. Пример этого вам будет вскоре предоставлен.
Использование кнопок и событий
Программа, приведенная в предыдущем разделе, позволила предоставить простой
пример использования элемента управления JavaFX и построения графа сцены, однако
в ней не было продемонстрировано, как обрабатывать события. Обработка событий
играет важную роль, поскольку большинство элементов управления GUI генерируют
события, которые обрабатываются вашей программой. Например, когда вы используете
кнопки, флажки или списки, все они генерируют события. Обработка событий в JavaFX
во многом напоминает обработку событий в Swing, о которой шла речь в предыдущей
главе, но выполняется гораздо проще. Одним из наиболее часто используемых элементов
управления является кнопка, и поэтому ее события приходится обрабатывать чаще
других. Следовательно, использование кнопки для знакомства с обработкой событий
в JavaFX будет весьма полезно. В связи с этим обработка событий и свойства кнопок
JavaFX рассматриваются совместно.
Основные сведения о событиях
Базовым классом событий JavaFX является класс Event, находящийся в пакете
javafx.event. Класс Event наследует класс java.util.eventObject, а это означает,
что события JavaFX разделяют общую функциональность с другими событиями Java.
Для класса Event определено несколько подклассов, из которых мы далее будем использовать
только класс ActionEvent. Этот класс инкапсулирует события действий, генерируемые
кнопкой.
Вообще говоря, используемый для обработки событий JavaFX подход в целом основан
на модели делегатов. Чтобы обработать событие, вы должны сначала зарегистрировать
обработчик, выступающий в качестве слушателя события. При наступлении
какого-либо события вызывается соответствующий слушатель. Слушатель должен отреагировать
на событие и после этого вернуть управление. В этом отношении управление
событиями JavaFX осуществляется во многом так же, как и событиями Swing.
Обработка событий требует реализации интерфейса EventHandler, который также
находится в пакете j avafx. event. Форма объявления этого обобщенного интерфейса
выглядит так:
Interface EventHandler<T extends Event>
где т определяет тип обрабатываемого события. Данный интерфейс определяет один метод,
handle ( ) , который принимает объект события в качестве параметра:
void handle (Т объект_события)
Глава 17. Введение в JavaFX 617
В данном случае объек т_ события - это сгенерированное событие. Обычно обработчики
событий реализуются посредством использования анонимных внутренних
классов или лямбда-выражений, но для этого могут использоваться и независимые
классы, если такое решение больше подходит для конкретного приложения (например,
в тех случаях, когда один и тот же обработчик должен обрабатывать события, поступающие
от разных источников).
Элемент управления Button
В JavaFX кнопка представлена классом Button, который находится в пакете javafx.
scene. control. Список классов, которые наследует класс Button, довольно внушителен
и включает такие классы, как ButtonBase, Labeled, Region, Control, Parent и
Node. Если вы обратитесь к разделам документации API, относящимся к классу Button,
то убедитесь в том, что большая часть его функциональности унаследована от базовых
классов. Кроме того, он предлагает широкий ряд возможностей выбора. Однако мы будем
использовать его форму, предоставляемую по умолчанию. Кнопки могут содержать
текст, графику или и то и другое одновременно. В этом примере мы будем использовать
текстовые кнопки.
Форма используемого нами конструктора класса Button приведена ниже.
Button (String строка)
В данном случае строка - это текст, отображаемый на кнопке.
После щелчка на кнопке генерируется событие ActionEvent. Класс ActionEvent находится
в пакете j ava fx. event. Регистрация слушателя этого события осуществляется
посредством вызова метода setOnAction () для кнопки. Общая форма объявления этого
метода выглядит так:
final void setOnAction(EventHandler<ActionEvent> обработчик)
где обработчик - это обработчик, подлежащий регистрации. Как уже упоминалось,
вы будете часто использовать анонимные внутренние классы для обработчиков. Метод
setOnAction () устанавливает свойство OnAction, в котором хранится ссылка на обработчика.
Как и при обработке любого другого события Java, обработчик событий кнопки
должен как можно быстрее отреагировать на событие и после этого немедленно возвратить
управление. Если выполнение обработчика занимает слишком много времени,
это будет заметно замедлять работу приложения. Для выполнения длительных операций
вы должны использовать отдельные потоки выполнения.
Демонстрация обработки событий кнопки
В приведенной ниже программе демонстрируется обработка событий и использование
компонента Button. Программа отображает две кнопки, Up и Down, и метку. Всякий
раз, когда нажимается кнопка, метка отображает текст, указывающий на то, какая
из кнопок была нажата. Таким образом, по своей функциональности эта программа аналогична
программе, демонстрирующей использование компонента JButton, которую
мы рассмотрели в предыдущей главе. Возможно, вам будет интересно провести самостоятельный
сравнительный анализ этих программ.
!/ Демонстрация обработки событий JavaFX для кнопок
import javafx.application.*;
import javafx.scene.*;
618 Java 8: руководство для начинающих. 6-е издание
irnport javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
irnport javafx.event.*;
irnport javafx.geornetry.*;
puЫic class JavaFXEventDerno extends Application {
Label response;
puЬlic static void rnain(String[] args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод start()
puЫic void start(Stage rnyStage)
// Задать заголовок окна приложения
rnyStage.setTitle("Use JavaFX Buttons and Events.");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального
// зазоров составляет 10.
FlowPane rootNode = new FlowPane(lO, 10);
// Центрировать элементы управления на сцене
rootNode.setAlignrnent(Pos.CENTER);
// Создать сцену
Scene rnyScene = new Scene(rootNode, 300, 100);
// Установить сцену на платформе
rnyStage.setScene(rnyScene);
// Создать метку
response = new Label("Push а Button");
// Создать две кнопки
Button btnUp = new Button("Up"); 􀁮
Button ЬtnDown = new Button("Down"); 􀀝Созданиедаухкнопок
// Обработать события действий для кнопки Up
ЬtnUp.setOnAction(new EventHandler<ActionEvent>()
puЬlic void handle(ActionEvent ае) {
response.setText("You pressed Up.");
}
}) ;
// Обработать события действий для кнопки Down
ЬtnDown.setOnAction(new EventHandler<ActionEvent>()
Соэдание обработчиков
соб ДПА ыКтНиОйП дОКе йствий
Глава 17. Введение в JavaFX 619
puЫic void handle(ActionEvent ае)
response.setText("You pressed Down.");
}
} ) ;
// Добавить метку и кнопки в граф сцены
rootNode.getChildren() .addAll(btnUp, btnDown, response);
// Отобразить платформу и ее сцену
myStage.show();
Результат выполнения программы представлен на приведенном ниже рисунке.
г.:l Г Dow;;; You pressed Up. 􀀃'=
Проанализируем некоторые показательные места данной программы. Прежде всего
обратите внимание на следующие строки.
Button ЬtnUp = new Button("Up");
Button ЬtnDown = new Button("Down");
Этот код создает две текстовые кнопки. На первой из них отображается строка Up, на
второй - Down.
После этого для каждой из кнопок устанавливается обработчик событий действий.
Вот как выглядит соответствующий код для кнопки Up.
// Обработать события действий для кнопки Up
ЬtnUp.setOnAction(new EventHandler<ActionEvent>()
puЬlic void handle(ActionEvent ае) {
response.setText("You pressed Up.");
}
} ) ;
Как ранее уже было сказано, кнопки реагируют на события типа ActionEvent. Чтобы
зарегистрировать обработчик этих событий, следует вызвать метод setOnAction ()
для соответствующей кнопки. Интерфейс EventHandler реализуется с использованием
анонимного внутреннего класса. (Вспомните, что в классе EventHandler определен
только метод handle () .) В теле метода handle () задается текст, который будет отображаться
меткой response и тем самым индицировать нажатие кнопки Up. Это делается
посредством вызова метода setText () для метки. Точно так же обрабатываются события
кнопки Down.
После установки обработчиков событий метка и обе кнопки добавляются в граф с
помощью метода addAll ( ) :
rootNode.getChildren() .addAll(ЬtnUp, ЬtnDown, response);
620 Java 8: руководство для начинающих, 6-е издание
Метод addAll () добавляет переданный ему список узлов в вызывающий родительский
узел. Разумеется, для добавления этих узлов можно было бы использовать три отдельных
вызова метода add (), но в данной ситуации было удобнее использовать метод
addAll ().
Можно отметить еще два интересных момента, имеющих отношение к отображению
элементов управления в окне. Во-первых, корневой узел создается следующим оператором:
FlowPane rootNode = new FlowPane(lO, 10);
где конструктору объекта типа FlowPane передаются два значения, устанавливающие
величину горизонтального и вертикального зазоров, которые будут оставлены вокруг
элементов при их размещении на сцене. Если не указать эти значения, то два соседних
элемента (например, две кнопки) разместятся на сцене вплотную друг к другу. В таком
случае элементы сольются на экране, и их будет трудно различать, что сделает пользовательский
интерфейс весьма неудобным. Задание зазоров позволяет избавиться от этого
недостатка.
Во-вторых, заслуживает внимания следующая строка кода, устанавливающая способ
выравнивания элементов управления при их компоновке в панели FlowPane:
rootNode.setAlignment(Pos.CENTER);
Здесь элементы выравниваются по центру. Это достигается за счет вызова метода
setAlignment () для панели FlowPane. Значение Pos. CENTER указывает на то, что центрирование
осуществляется как по вертикали, так и по горизонтали. Возможны и другие
способы выравнивания. Pos - это перечисление, содержащее список констант выравнивания.
Оно находится в пакете j avafx. geometry.
Прежде чем продолжить, следует сделать еще одно замечание. В предыдущей программе
для обработки событий кнопки используется анонимный внутренний класс.
Но в связи с тем, что интерфейс EventHandler определяет только один абстрактный метод,
handle () , вместо этого можно передать методу setOnAction () лямбда-выражение.
В качестве примера ниже приведен модифицированный вариант обработчика событий
для кнопки Up, в котором используется лямбда-выражение.
btnUp.setOnAction( (ае) ->
response.setText("You pressed Up.")
) ;
Как видите, лямбда-выражение более компактно по сравнению с анонимным внутренним
классом. (Вы будете использовать лямбда-выражение, видоизменяя эту программу
в процессе выполнения упражнения 10, приведенноrо в конце главы.)
Три других элемента управления JavaFX
В JavaFX определен богатый набор элементов управления, которые содержатся в пакете
javafx. scene. control. С двумя из них вы уже знакомы: это компоненты Label
и Button. На очереди следующие три: CheckBox, ListView и TextField. Как говорят
сами их названия, они поддерживают флажок, список и текстовое поле. Все вместе они
образуют довольно представительный набор элементов управления JavaFX. Они также
позволяют продемонстрировать некоторые распространенные методики. Как только вы
разберетесь с простыми элементами, вы сможете самостоятельно изучить все остальные
элементы управления.
Глава 17. Введение вJavaFX 621
Функциональность описанных ниже элементов управления аналогична функциональности
элементов управления Swing, которым была посвящена предьщущая глава.
В процессе проработки данного раздела вам будет интересно сравнить способы реализации
элементов управления в библиотеках JavaFX и Swing.
КомпонентСhесkВох
В JavaFX функциональность флажка инкапсулирует класс CheckBox. Данный класс
является непосредственным суперклассом по отношению к классу ButtonBase. Таким
образом, он является особым типом кнопки. Учитывая широкое использование флажков,
можно не сомневаться, что они вам уже знакомы, однако флажки JavaFX немного
сложнее, чем кажутся на первый взгляд. Это обусловлено тем, что класс CheckВox поддерживает
три состояния. Как можно было ожидать, два из них - это состояния "установлен"
и "снят", которые соответствуют поведению по умолчанию. Третье состояние
называется недетерминированным (или неопределенным). Обычно оно используется для
индикации того, что состояние флажка не было установлено или оно не имеет значения
в данной конкретной ситуации. Чтобы это состояние можно было использовать, его
надо активизировать явным образом. Соответствующая процедура продемонстрирована
в упражнении 17.l. А пока мы сосредоточимся на традиционном поведении флажка.
Далее мы будем использовать конструктор класса CheckBox следующего вида:
CheckBox(String строка)
Этот конструктор создает флажок с пояснительной надписью, текст которой задается
параметром строка. Как и в случае других разновидностей кнопок, при выборе флажка
CheckBox он генерирует событие действия.
Использование флажков продемонстрировано в приведенной ниже программе. Программа
отображает четыре флажка, представляющих различные типы компьютеров,
которые обозначены как Smartphone, ТаЫеt, Notebook и Desktop. Всякий раз, когда
изменяется состояние флажка, генерируется событие действия. Обработка события заключается
в отображении состояния флажка (установлен он или снят), а также списка
установленных флажков.
// Демонстрация использования флажков
import javafx.application.*;
import javafx.scene.*;
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.event.*;
import javafx.geometry.*;
puЫic class CheckboxDemo extends Application {
CheckBox cbSmartphone;
CheckBox сЬТаЫеt;
CheckBox cbNotebook;
CheckBox cbDesktop;
Label response;
Label selected;
622 Java 8: руководство для начинающих. 6-е издание
String computers;
puЫic static void main(String[J args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод start()
puЫic void start(Stage myStage)
// Задать заголовок окна приложения
myStage.setTitle("Demonstrate Check Boxes");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального
// зазоров составляет 10.
FlowPane rootNode = new FlowPane(Orientation.VERTICAL, 10, 10);
// Центрировать элементы управления на сцене
rootNode.setAlignment(Pos.CENTER);
// Создать сцену
Scene myScene = new Scene(rootNode, 230, 200);
// Установить сцену на платформе
myStage.setScene(myScene);
Label heading = new Label("What Computers Do You Own?");
// Создать метку. извещающую об изменении состояния флажка
response = new Label("");
// Создать метку, извещающую о выборе любого флажка
selected = new Label("");
// Создать флажки
cbSmartphone = new CheckBox("Smartphone"); сЬТаЫеt = new CheckBox (" ТаЫеt"); l
1----- Создание фnажкоа
cbNotebook = new CheckBox("Notebook");
cbDesktop = new CheckBox("Desktop"); ..,.,.1-----􀂀
// Обработка событий действий для флажков
cbSmartphone.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
if(cbSmartphone.isSelected())
response.setText("Smartphone was just selected.");
else
}
}) ;
response.setтext("Smartphone was just cleared.");
showAll ();
Глава 17. Введение в JavaFX 623
cbTaЫet.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
if(cbTaЫet.isSelected())
response.setText("TaЫet was just selected.");
else
}
}} ;
response.setтext("TaЬlet was just cleared.");
showAll ();
cbNotebook.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
if(cbNotebook.isSelected())
response.setтext("Notebook was just selected.");
else
}
} ) ;
response.setText("Notebook was just cleared.");
showAll ();
cbDesktop.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
if(cbDesktop.isSelected())
response.setText("Desktop was just selected.");
else
}
} ) ;
response.setText("Desktop was just cleared.");
showAll();
// Добавить элементы управления в граф сцены
rootNode.getChildren(). addAll(heading, cbSmartphone,􀁼
сЬТаЫеt, cbNotebook, cbDesktop, response, selected);
// Отобразить платформу и ее сцену
myStage.show();
showAll ();
// Обновить и отобразить варианты выбора
void showAll() {
computers = "";
Обра􀁽тка
собwтни
фnажкоа
if ( cbSmartphone. isSelected () ) computers = "Smartpho
J
n "; Испоnьэоаание
if ( сЬТаЫеt. isSelected () ) computers += "ТаЫеt "; метода
if(cbNotebook.isSelected()) computers += "Notebook "; isSelected()
if (cbDesktop. isSelected ()) computers += "Desktop"; дnя опредеnения
selected.s etText (" Computers selected: " + computers) ; состояния фnожков
624 Java 8: руководство для начинающих. 6-е издание
Результат выполнения программы представлен на приведенном ниже рисунке.
What Computers Оо You Own?
0 Smartphone
ь?)ТаЫеt
Q Notebool:
· О Deslctop
Т аЫеt was just selected
Computers selected: Smartphone Tablet
В работе этой программы нет ничего сложного. Всякий раз, когда изменяется состояние
флажка, генерируется событие ActionEvent. Сначала обработчики событий
сообщают о том, установлен флажок или снят. С этой целью для источника события вызывается
метод isSelected (). Возвращаемому значению true соответствует установка
флажка, значению false - снятие. После этого вызывается метод showAll (), который
выводит список всех установленных флажков.
В этой программе можно отметить еще один интересный момент. Обратите внимание
на то, что в ней используется вертикальная компоновка:
FlowPane rootNode = new FlowPane(Orientation.VERTICAL, 10, 10);
По умолчанию компоненты размещаются в панели FlowPane по горизонтали. Для
создания панели с вертикальной компоновкой следует передать конструктору значение
Orientation. VERTICAL в качестве первого аргумента.
Упражнение 17.1 Использование неоnределенноrо состояния
компонента CheckВox
\"'ёh􀀚-􀀛k·b;􀀜·D􀀚􀀝􀀞··_-j·􀀟·;􀀠···: Как уже отмечалось, по умолчанию компонент CheckВox реа-
: ................................................. , лизует два состояния, соответствующие установленному и сня-
тому флажку. Но он поддерживает и третье, неопределенное, состояние, которое можно
использовать для индикации того, что состояние флажка еще не устанавливалось или же
что эта возможность в данной ситуации неприменима. Неопределенное состояние флажка
необходимо активизировать явным образом, оно не предоставляется по умолчанию.
Кроме того, обработчик событий флажка должен обрабатывать и неопределенное состояние.
Рассмотрим проект, который проиллюстрирует этот процесс. Суть проекта состоит
в том, что в предьщущую программу CheckBoxDemo в компонент CheckBox, соответствующий
смартфону, добавляется поддержка неопределенного состояния. Поэтапное
описание процесса создания модифицированного варианта программы приведено ниже.
1. Чтобы активизировать неопределенное состояние флажка, необходимо вызвать
метод setAllowindeterminate ():
final void setAllowindeterminate(boolean режим)
Если значение параметра режим равно true, активизируется неопределенное
состояние. В противном случае оно деактивизируется. Когда неопределенное
Глава 17. Введение в JavaFX 625
состояние активизировано, пользователь может переводить компонент в одно из
трех состояний: состояние установленного или снятого флажка и неопределенное
состояние. Следовательно, чтобы активизировать неопределенное состояние для
флажка Smartphone, необходимо добавить следующую строку кода:
cbSrnartphone.setAllowindeterrninate(true);
2. Чтобы определить, находится ли флажок в неопределенном состоянии, вызывается
метод isindeterminate ():
final boolean isindeterrninate()
Эrот метод возвращает значение true, если флажок находится в неопределенном
состоянии, и значение false в противном случае. Обработчик событий флажка
теперь должен тестировать и неопределенное состояние.
cbSrnartphone.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
if(cbSrnartphone.isindeterrninate())
response.setтext("Srnartphone state is indeterrninate.");
else if(cbSrnartphone.isSelected())
response.setText("Srnartphone was just selected.");
}
} ) ;
else
response.setText("Srnartphone was just cleared.");
showAll ();
3. Внеся указанные изменения, скомпилируйте и выполните программу. Теперь,
как показано на приведенном ниже рисунке, вы сможете устанавливать флажок
Smartphone в неопределенное состояние.
2,1 NoteЬoo!c
[] Desktop
Smartphone state is 1ndeterminate.
Компонент ListView
Другой распространенный компонент - список, функциональность которого в
JavaFX инкапсулирует класс ListView. Класс ListView может отображать список элементов,
предоставляя возможность выбора одного или нескольких из них. Полезным
свойством списка ListView является автоматическое добавление полос прокрутки, если
626 Java 8: руководство для начинающих. 6-е издание
количество элементов списка таково, что не все они могут быть одновременно отображены
в поле списка. Эта способность списков ListView обеспечивать эффективное использование
дефицитного экранного пространства сделала его весьма популярным на
фоне остальных элементов управления, предоставляющих возможности выбора.
Класс ListView - обобщенный и имеет следующую форму объявления:
class ListView<T>
где т обозначает тип элементов, хранящихся в списке. Чаще всего это элементы типа
String, однако допускаются и другие типы.
Далее мы будем использовать следующий вариант конструктора ListView:
ListView(ObservaЫeList<T> список)
Список элементов, подлежащих отображению, задается параметром список.
Он представляет собой объект типа ObservaЬleList. Как уже отмечалось, класс
ObservaЬleList поддерживает список объектов. По умолчанию класс ListView обеспечивает
отображение только одного выбираемого элемента списка в каждый момент
времени. Также предусмотрен режим группового выбора, однако мы будем использовать
установленный по умолчанию режим выбора одиночных элементов ..
Вероятно, простейшим способом создания объекта ObservaЬleList для списка
ListView является использование метода observaЫeArrayList (), работающего
по принципу фабрики объектов, который определен как статический метод в классе
FXCollections (находится в пакете javafx.collections). Мы будем использовать следующую
версию этого метода:
static <Е> ObservaЫeList<E> observaЫeArrayList(E ... элементы)
В данном случае Е обозначает тип элементов, которые передаются посредством параметра
элементы.
Компонент ListView предлагает заданные по умолчанию значения ширины и высоты
списка, однако в некоторых случаях желательно установить другие предпочтительные
значения, которые лучше соответствуют вашим потребностям. Одним из способов
установки этих значений является вызов методов setPrefHeight () и setPrefWidth ().
final void setPrefHeight(douЫe высота)
final void setPrefWidth(douЫe высота)
Возможно и другое решение, позволяющее задать одновременно оба размера с помощью
вызова метода setPrefSize ():
void setPrefSize(douЫe ширина, douЫe высота)
Список ListView можно использовать двояким образом. Во-первых, вы можете игнорировать
события, генерируемые списком, ограничиваясь получением выбранного
элемента списка, когда это понадобится программе. Во-вторых, можете вести мониторинг
изменений, происходящих в списке, зарегистрировав обработчик событий. Это
позволит реагировать на каждую смену выбора элемента списка. Именно такой подход
используется далее.
Слушатель событий смены выбранного элемента списка поддерживается интерфейсом
ChangeListener, который находится в пакете j ava fx. bean. va l ue. Интерфейс
ChangeListener определяет только один метод, changed () :
void changed(ObservaЫeValue<? extends Т> changed, Т oldVal,
Т newVal)
Глава 17. Введение в JavaFX 627
rде changed - экземпляр класса ObservaЬleValue<T>, инкапсулирующий объект,
за изменениями состояния которого можно наблюдать. Через параметры oldVa 1 и
newVal методу передаются прежнее и новое значения соответственно. Таким образом,
в данном случае в newVa 1 хранится ссылка на только что выбранный элемент списка.
Чтобы прослушивать события, прежде всего необходимо получить модель выбора,
используемую компонентом ListView. Это можно сделать, вызвав для списка метод
getSelectionModel():
final MultipleSelectionModel<T> getSelectionModel{)
Данный метод возвращает ссылку на модель. Класс MultipleSelectionМodel определяет
модель, используемую при групповом выборе, и наследует класс SelectionМodel.
Однако групповой выбор разрешен в списке ListView только в том случае, если режим
группового выбора активизирован.
Используя модель, возвращенную методом getSelectionМodel (), вы сможете получить
ссылку на свойство выбранного элемента, которое определяет, что именно должно
происходить, когда выбирается элемент списка. Для этого следует вызвать метод
selecteditemProperty():
final ReadOnlyObjectProperty<T> selecteditemProperty{)
Добавление слушателя событий изменений в это свойство осуществляется посредством
вызова метода addListener () для возвращенного свойства. Метод addListener ()
имеет следующую форму объявления:
void addListener{ChangeListener<? super Т> слушатель)
В данном случае т обозначает тип свойства.
Следующий пример реализует на практике то, о чем мы только что говорили. В нем
создается список типов компьютеров, обеспечивающий возможность выбора нужного
элемента. При выборе какого-либо элемента отображается соответствующий пояснительный
текст.
// Демонстрация использования списков
import javafx.application.*;
import javafx.scene.*;
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.geometry.*;
import javafx.beans.value.*;
import javafx.collections.*;
puЫic class ListViewDemo extends Application {
Label response;
puЫic static void main{String(] args) {
// Запустить приложение JavaFX, вызвав метод launch{)
launch{args);
628 Java 8: руководство для начинающих. 6-е издание
// Переопределить метод start()
puЫic void start(Stage myStage)
// Задать заголовок окна приложения
myStage.setTitle("ListView Demo");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального
// зазоров составляет 10.
FlowPane rootNode = new FlowPane(lO, 10);
// Центрировать элементы управления на сцене
rootNode.setAlignment(Pos.CENTER);
// Создать сцену
Scene myScene = new Scene(rootNode, 200, 120);
// Установить сцену на платформе
myStage.setScene(myScene);
// Создать метку
response = new Label("Select Computer Туре");
// Создать объект типа ObservaЫeList для списка
ObservaЫeList<String> computerTypes =
FXCollections.observaЫeArrayList("Smartphone",
"ТаЫеt", "Notebook", "Desktop" );
/ / Создать список Соэданне сnнска, отображающеrо
ListView<String> lvComputers = / эnементw computerTypes
new ListView<String>(computerTypes);
// Задать предпочтительные значения высоты и ширины
lvComputers.setPrefSize(lOO, 70);
// Получить модель выбора для списка
MultipleSelectionModel<String> lvSelModel
lvComputers.getSelectionModel();
// Использовать слушатель для реагирования на изменения
// выделения внутри списка.
1 vSelModel. selecteditemProperty () . addListener ( .----Обработка собwтнй сменw
new ChangeListener<String> () вwборо эnемента
puЫic void changed(ObservaЬleValue<? extends String> changed,
String oldVal, String newVal) {
}
} ) ;
// Отобразить выбор
response.setтext("Computer selected is " + newVal);
Глава 17. Введение в JavaFX 629
// Добавить метку и список в граф сцены
rootNode.getChildren() .addAll(lvComputers, response);
// Отобразить платформу и ее сцену
myStage.show();
Результат выполнения программы представлен на приведенном ниже рисунке.
Computer seJ&ted is Smartphone
Обратите внимание на вертикальную полосу прокрутки, позволяющую просмотреть
все элементы списка. Как уже отмечалось, полоса прокрутки автоматически добавляется
в тех случаях, когда не все элементы списка могут быть отображены одновременно. Это
делает список ListView чрезвычайно удобным.
Особого внимания заслуживает способ конструирования списка ListView в этой
программе. Сначала создается объект ObservaЬleList.
ObservaЬleList<String> computerTypes =
FXCollections. observaЫeArrayList ( "Smartphone", "ТаЫеt", "Notebook",
"Desktop" );
В данном случае для создания списка строк используется метод observaЫe
ArrayList (). После этого объект ObservaЬleList используется для инициализации
списка ListView:
ListView<String> lvComputers = new ListView<String>(computerTypes);
Затем в программе устанавливаются предпочтительные значения ширины и высоты
элемента управления.
Обратите внимание на способ получения модели выбора для списка lvComputers.
MultipleSelectionModel<String> lvSelModel =
lvComputers.getSelectionModel();
Как уже отмечалось, ListView использует MultipleSelectionModel, даже если разрешен
только режим выбора одиночных элементов. Поэтому далее для модели вызывается
метод SelecteditemProperty () и регистрируется слушатель событий.
lvSelModel.selecteditemProperty() .addListener(
new ChangeListener<String>() {
puЫic void changed(ObservaЬleValue<? extends String> changed,
String oldVal, String newVal) {
)
)) ;
// Отобразить выбор
response.setText("Computer selected is " + newVal);
630 Java 8: руководство для начинающих. 6-е издание
Вам будет интересно узнать, что тот же самый базовый механизм, который используется
для прослушивания и обработки событий изменений, применим к любому элементу
управления, генерирующему такие события.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Как разрешить одновременный выбор нескольких элементов в списках
ListView?
ОТВЕТ. Чтобы в списке ListView можно было выбирать сразу несколько элементов,
необходимо установить режим группового выбора. Это делается посредством
вызова метода setSelectionMode () для модели ListView. Общая форма
объявления данного метода представлена ниже.
final void setSelectionMode(SelectionMode режим)
Здесь параметр режим может принимать одно из двух значений: Selection
Mode. MULTIPLE и SelectionMode. SINGLE. Режиму группового выбора соответствует
значение SelectionМode. МULTIPLE.
Одним из способов получения списка выбранных элементов является вызов метода
getSelecteditems для модели выбора. Вот общая форма объявления этого
метода:
ObservaЬleList<T> getSelectedltems()
Метод возвращает выбранные элементы в виде списка типа ObservaЫeList.
Для поэлементного просмотра возвращенного списка можно воспользоваться
циклом for-each или for.
KoмnoнeнтTextField
Несмотря на очевидную полезность компонентов Button, CheckBox и ListView,
все они реализуют средства, обеспечивающие возможность выбора из списка заранее
определенных параметров или действий. Однако иногда желательно, чтобы пользователь
имел возможность самостоятельно вводить строку по собственному усмотрению.
В JavaFX предусмотрено несколько текстовых элементов управления, обеспечивающих
этот тип ввода. К их числу относится компонент тextField, предназначенный для ввода
однострочного текста. Такая возможность оказывается удобной при вводе имен, идентификаторов,
адресов и т.п. Как и все текстовые элементы управления, класс TextField
наследует класс TextinputControl, который определяет значительную часть его функциональности.
В классе TextField определены два конструктора. Один из них является конструктором
по умолчанию и создает пустое текстовое поле стандартного размера. Второй позволяет
задать начальное содержимое текстового поля. Далее мы будем использовать
конструктор, заданный по умолчанию.
В некоторых случаях можно ограничиться использованием стандартного размера
текстового поля, заданного по умолчанию, однако часто возникает необходимость
Глава 17. Введение в JavaFX 631
устанавливать размер поля по собственному усмотрению. Это делается посредством вызова
метода setPrefColumnCount (), имеющего следующую общую форму объявления:
final void setPrefColumnCount(int столбцы)
Параметр столбцы позволяет устанавливать размер компонента TextField.
Содержимое текстового поля можно задать, вызвав метод setText (). Для получения
текущего содержимого можно вызвать метод getText (). Кроме этих двух основных
операций, компонент TextField поддерживает ряд других возможностей, таких как
вырезание, вставка и присоединение текста, которые вам будет полезно изучить самостоятельно.
Также предоставляется возможность выделения части текста программными
средствами.
Одна из наиболее интересных особенностей компонента TextField состоит в том,
что он позволяет предоставлять текст-подсказку, который будет отображаться в текстовом
поле до тех пор, пока пользователь не начнет вводить какое-либо значение. Это делается
с помощью метода setPromptText (), синтаксис объявления которого приведен
ниже:
final void setPromptText(String строка)
где параметр строка - это строка, отображаемая в текстовом поле, когда никакой другой
текст еще не введен. На экране эта строка отображается с пониженной интенсивностью
(затенена).
Если пользователь нажимает клавишу <Enter> в то время, когда фокус ввода находится
в поле компонента TextField, генерируется событие действия. В одних случаях
обработка этих событий может быть полезной, тогда как в других программе требуется
всего лишь получить введенный текст, не обрабатывая события. Следующая программа
демонстрирует оба подхода. В программе создается текстовое поле, запрашиваюшее
ввод имени. Если в то время, когда фокус ввода находится в поле ввода, пользователь
нажмет клавишу <Enter> или щелкнет на кнопке Get Name, строка будет передана программе,
которая выводит соответствующий текст. Обратите внимание на использование
в программе текстовой подсказки.
// Демонстрация использования текстовых полей
import javafx.application.*;
import javafx.scene.*;
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.event.*;
import javafx.geometry.*;
puЫic class TextFieldDemo extends Application {
TextField tf;
Label response;
puЬlic static void main(String[] args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
632 Java 8: руководство для начинающих. 6-е издание
// Переопределить метод start()
puЬlic void start(Stage myStage)
// Задать заголовок окна приложения
myStage.setTitle("Demonstrate а TextField");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального зазоров
// составляет 10.
FlowPane rootNode = new FlowPane(lO, 10);
// Центрировать элементы управления на сцене
rootNode.setAlignrnent(Pos.CENTER);
// Создать сцену
Scene myScene = new Scene(rootNode, 230, 140);
// Установить сцену на платформе
myStage.setScene(myScene);
// Создать метку, извещающую о состоянии выбранного флажка
response = new Label("Enter Narne: ");
// Создать кнопку, управляющую получением текста
Button ЬtnGetText = new Button("Get Narne");
// Создать текстовое поле
tf = new TextField(); 4-----Соэданне текс:rовоrо nonя
// Задать подсказку
tf.setPrornptText("Enter а narne."); ------ Зодонне текс:rа nодскаэкн,
отображаемой в текс:rовом none
// Задать предпочтительное количество столбцов
tf. setPrefColurnnCount ( 15) ; Задонне коnнчес:rва с:rоnбцов в текс:rовам none
// Использовать лямбда-выражение, обрабатывающее события действий
// для текстового поля. События действий генерируются при нажатии
// клавиши <ENTER> в то время, когда фокус ввода находится в
// текстовом поле. В данном случае обработка события
// заключается в получении и отображении текста.
tf.setOnAction( (ае) -> response.setText("Enter pressed. Narne is: " +
tf. getText () ) ) ; '-----------------Обработка собwтнй
/ / Использовать лямбда-выражение для получения текста из действий дnя
// текстового поля при нажатии кнопки
ЬtnGetText.setOnAction((ae) ->
response.setText("Button pressed. Narne is: " +
tf. getText () ) ) ;
// Использовать разделитель для лучшей организации вывода
Separator separator = new Separator();
separator.setPrefWidth(180);
текс:rоваrо nonя
Глава 17. Введение в JavaFX 633
// Добавить элементы управления в граф сцены
rootNode.getChildren() .addAll(tf, btnGetText, separator, response);
// Отобразить платформу и ее сцену
myStage.show();
Результат выполнения программы представлен на приведенном ниже рисунке.
--- ----------
! Jonathan
/ GetName}
Button pressed. Name is: Jonathan
Обратите внимание на использование лямбда-выражений в обработчиках событий.
Каждый из обработчиков включает единственный вызов метода. Поэтому все они являются
идеальными кандидатами Д11Я использования лямбда-выражений.
СПРОСИМ У ЭКСПЕРТА
ВОПРОС. Какие еще текстовые элементы управления поддерживаются в JavaFX?
ОТВЕТ. К числу других текстовых элементов управления относятся компоненты
TextArea, который поддерживает ввод многострочного текста, и PasswordField,
предназначенный Д11Я ввода паролей. Возможно, вас заинтересует
также компонент HTMLEditor.
Введение в эффекты и преобразования
Главное преимущество библиотеки JavaFX - предоставление возможности детально
контролировать внешний вид элементов управления (и вообще любых узлов графа сцены)
за счет применения к ним эффектов и преобразований. Как эффекты, так и преобразования
способны придать графическому интерфейсу вашего приложения изысканный
современный вид, на который рассчитывают пользователи. Как вы увидите далее, легкость
использования этих средств библиотеки JavaFX является одной из самых сильных
ее сторон. Тема эффектов и преобразований слишком обширна, чтобы мы могли рассмотреть
ее более подробно, однако даже краткого введения в нее вам будет достаточно
Д11Я того, чтобы понять всю ценность предоставляемых этими средствами преимуществ.
634 Java 8: руководство для начинающих. 6-е издание
Эффекты
Эффекты поддерживаются абстрактным классом Effect и его конкретными подклассами,
которые все находятся в пакете javafx. scene. effect. С помощью эффектов
вы можете придать узлу графа сцены внешний вид, в точности соответствующий вашим
предпочтениям. Библиотека предоставляет ряд встроенных эффектов, часть которых
приведена в следующей таблице.
Bloom Увеличивает яркость более ярких частей узла
BoxBlur Размывает изображение узла
DropShadow Отображает тени, отбрасываемые узлами
Glow Создает эффект свечения
InnerShadow Отображает тень внутри узла
Lighting Создает эффекты теней при наличии светового источника
Reflection Создает эффекты отражения
Эти и другие эффекты просты в использовании и применимы к любому узлу, включая
элементы управления. Разумеется, в зависимости от особенностей элементов управления,
пригодность некоторых эффектов для них может различаться.
Чтобы установить эффект для узла, следует вызвать метод setEffect (), определяемый
классом Node:
final void setEffect(Effect эффект)
где параметр эффект - это применяемый эффект. Для указания отсутствия эффекта
передается значение null. Таким образом, для добавления эффекта в узел необходимо
сначала создать экземпляр эффекта, а затем передать его методу setEffect () . После
этого эффект будет использоваться каждый раз при визуализации узла (при условии, что
данный эффект поддерживается средой выполнения). Возможности этих средств будут
продемонстрированы на примере двух эффектов: Reflection и BoxBlur. Однако сама
процедура в основном не зависит от того, какой эффект выбран.
Эффект BoxBlur размывает изображение узла, к которому он применен. Он называется
так потому, что используемая при этом техника размытия основана на настройке
пикселей, ограниченных прямоугольной областью. Степень размытия можно контролировать.
Чтобы использовать эффект размытия изображения, необходимо создать экземпляр
BoxBlur, Класс BoxBlur определяет два конструктора. Мы будем использовать
конструктор следующего вида:
BoxBlur(douЫe ширина, douЫe высота, int итерации)
где параметры ширина и высота определяют размеры прямоугольной области, в пределах
которой будут размываться пиксели. Каждый из этих параметров может принимать
значения в диапазоне 0-255, включая граничные значения. Как правило, эти значения
выбираются в нижней части указанного диапазона. Параметр итерации определяет
кратность применения эффекта, и его величина должна выбираться в пределах от О до
3, включая граничные значения. Также поддерживается конструктор по умолчанию, которому
соответствуют следующие значения параметров: ширина и высота - 5. О, итерации
- l.
Глава 17. Введение в JavaFX 635
Ширину и высоту прямоугольной области д;1я уже созданного экземпляра BoxBlur
можно изменить с помощью методов setWidth () и setHeight ().
final void setWidth(douЫe ширина)
final void Height(douЫe высота)
Количество итераций можно изменить с помощью метода setiterations ():
final void setiterations(douЫe итерации)
Использование этих трех методов позволяет изменить параметры эффекта размытия
во время выполнения программы.
Эффект Reflection позволяет получить отражение узла, д;1я которого он вызывается,
по вертикали. Особенно часто этот эффект применяется к текстовым объектам,
таким как метки. Компонент Reflection позволяет контролировать внешний вид отраженного
узла. Например, он предоставляет возможность раздельного управления прозрачностью
изображения исходного узла и его отражения. Кроме того, вы можете задать
расстояние между узлом и его отражением, а также отражать лишь часть исходного узла.
Для создания отражения с заданными свойствами используется следующий конструктор:
Reflection(douЫe смещение, douЫe доля,
douЫe непрозрачность_верх, douЫe непрозрачность_низ)
где параметр смещение определяет расстояние между нижней частью изображения и
его отражением. Предусмотрена возможность отображать лишь часть отраженного узла;
этим управляет параметр доля, значения которого должны находиться в пределах от О
до 1. О. Степенью непрозрачности оригинала и отражения управляют параметры непрозрачность_
верх и непрозрачность_низ, значения которых должны находиться
в пределах от О до 1. О. Также предоставляется конструктор по умолчанию, который
устанавливает следующие значения параметров: смещение - О, доля - О. 75, непрозрачность_
верх - О. 5 и непрозрачность_ низ - О.
Значения параметров могут быть изменены во время выполнения программы. Для
изменения параметров непрозрачности предназначены методы setTopOpaci ty () и
setBottomOpacity().
final void setTopOpacity(douЫe непрозрачность)
final void setBottomOpacity(douЫe непрозрачность)
Значение смешения можно изменить посредством вызова метода setTopOffset ():
final void setTopOffset(douЫe смещение)
Задать, какая доля отражения должна отображаться на экране, можно с помощью
метода setFraction ():
final void setFraction(douЫe доля)
Перечисленные методы позволяют изменить свойства отражения в процессе выполнения
программы.
Преобразования
Преобразования поддерживаются абстрактным классом Transform, который находится
в пакете javafx. scene. transform. В число его подклассов входят классы Rotate,
Scale, Shear и Translate. Имя каждого класса указывает на его назначение. (У класса
Transform имеется еше и пятый подкласс - Affine, но обычно вам будет достаточно
636 Java 8: руководство для начинающих, 6-е издание
использовать первые четыре подкласса.) К узлу могут быть применены одновременно
несколько преобразований. Например, можно повернуть узел и одновременно масштабировать
его. Преобразования поддерживаются классом Node.
Одним из способов добавления преобразования в узел является его включение в список
преобразований, поддерживаемых узлом. Этот список можно получить с помощью
метода getTransforms), определяемого классом Node. Вот общая форма объявления
этого метода:
final ObservaЫeList<Transform> getTransforms()
Данный метод возвращает ссылку на список преобразований. Чтобы добавить преобразование,
достаточно включить его в этот список, вызвав метод add () . Список можно
очистить, вызвав метод clear (). Для удаления конкретного элемента списка можно вызвать
метод remove ( ) .
В некоторых случаях преобразование можно задать непосредственно, установив одно
из свойств класса Node. Например, можно задать угол поворота узла вокруг его центра,
вызвав метод setRotate (), с передачей ему желаемого значения угла в качестве параметра.
Для масштабирования узла используются методы setScaleX () и setScaleY (),
а для его переноса - метод setTranslateX () и setTranslateY (). (Преобразования с
использованием Z-координаты также могут поддерживаться платформой.) Однако использование
списков преобразований обеспечивает большую гибкость, и именно такого
подхода мы далее будем придерживаться.
Для демонстрационного примера выбраны классы Rotate и Scale. (Другие классы
преобразований используются аналогичным образом.) Преобразование Rotate осуществляет
поворот узла на заданный утол вокруг заданной точки. Эти значения могут быть
установлены при создании экземпляра Rotate. Вот синтаксис объявления одного из
конструкторов класса Rotate:
Rotate(douЫe угол, douЫe х, douЫe у)
где параметр угол определяет угол поворота в градусах. Координаты центра поворота,
называемого опорной точкой, определяются параметрами х и у.
Можно использовать конструктор по умолчанию, а затем установить параметры поворота
уже после создания объекта Rotate, что и сделано в демонстрационной программе,
представленной в следующем разделе. Для этого используются методы setAngle (),
setPivotX () и setPivotY ().
final void setAngle(douЫe угол)
final void setPivotX(douЫe х)
final void setPivotY(douЫe у)
Как уже отмечалось, параметр угол определяет величину угла поворота в градусах, а
координаты центра поворота определяются параметрами х и у. С помощью указанных
методов вы можете повернуть узел в процессе выполнения программы. Это позволяет
создавать очень броские эффекты.
Преобразование Scale масштабирует узел в соответствии с заданным коэффициентом
масштабирования. Это позволяет изменить размеры узла. Класс Scale определяет
несколько конструкторов. Мы будем использовать конструктор следующего вида:
Scale(douЫe коэффициент_ширина, douЫe коэффициент_высота)
где параметр коэффициент_ширина определяет коэффициент масштабирования для
ширины узла, а параметр коэффициент_высота - значение коэффициента, применяе-
Глава 17. Введение в JavaFX 637
мое к высоте узла. После создания экземпляра класса Scale значения этих параметров
могут быть изменены с помощью методов setX () и setY ().
final void setX(douЫe коэффициент_ширина)
final void setY(douЫe коэффициент_высота)
С помощью указанных методов вы можете изменить размеры элемента управления
во время выполнения программы, что может быть использовано для примечения внимания
пользователя.
Демонстрация эффектов и преобразований
Ниже приведена программа, в которой демонстрируется использование эффектов и
преобразований. В программе создаются три кнопки и метка. Кнопки имеют названия
Rotate, Scale и Blur. При нажатии кнопки к ней применяется соответствующий эффект
или преобразование. В частности, нажатиям кнопок соответствуют следующие действия:
Rotate - поворот кнопки на 15 градусов; Scale - изменение размеров кнопки;
Blur - нарастающее размытие кнопки. Эффект отражения иллюстрируется с помощью
метки. Исследовав текст программы, вы увидите, как просто выполняется настройка
внешнего вида графического интерфейса приложения. Вам будет интересно самостоятельно
поэкспериментировать с программой, использовав в ней другие преобразования
и эффекты и применяя их к другим типам узлов, а не только к кнопкам.
// Демонстрация поворота, масштабирования, отражения и размытия
// элемента управления
import javafx.application.*;
import javafx.scene.*;
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.event.*;
import javafx.geometry.*;
import javafx.scene.transform.*;
import javafx.scene.effect.*;
import javafx.scene.paint.*;
puЫic class EffectsAndTransformsDemo extends Application {
douЫe angle = О.О;
douЫe scaleFactor = 0.4;
douЫe ЫurVal = 1.0;
// Создать начальные объекты преобразований и эффектов
Reflection reflection = new Reflection(); 4
J- BoxBlur Ыur = new BoxBlur ( 1. О, 1. О, 1) ; Созданне эффектов
Rotate rotate = new Rotate (); н преобразований
Scale scale = new Scale(scaleFactor, scaleFactor);
// Создать кнопки
Button btnRotate = new Button("Rotate");
Button btnBlur = new Button("Blur off");
Button btnScale = new Button("Scale");
638 Java 8: руководство для начинающих. 6-е издание
Label reflect = new Label("Reflection Adds Visual Sparkle");
puЫic static void main(String[] args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод start()
puЫic void start(Stage myStage)
// Задать заголовок окна приложения
myStage.setTitle("Effects and Transforms Demo");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального зазоров
// составляет 20.
FlowPane rootNode = new FlowPane(20, 20);
// Центрировать элементы управления на сцене
rootNode.setAlignment(Pos.CENTER);
// Создать сцену
Scene myScene = new Scene(rootNode, 300, 120);
// Установить сцену на платформе
myStage.setScene(myScene);
// Добавить поворот в список преобразований для кнопки Rotate
ЬtnRotate. getTransforms () . add ( rotate) ; Добааnение преобразования
поворота в кнопку btnRotate
// Добавить масштабирование в список
// для кнопки Scale
ЬtnScale.getTransforms() .add(scale);
преобразований
-----Добавnение преоброзоаания
масштабирования а кнопку btnScale
// Задать эффект отражения для метки Reflection
reflection.setTopOpacity(0.7);
reflection.setBottomOpacity(0.3);
reflect. setEffect ( reflection) ; Задание отражения дnя метки Reflect
// Обработать события действий для кнопки Rotate
ЬtnRotate.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
)
)) ;
// При каждом нажатии кнопки она поворачивается
// на 30 градусов вокруг центра
angle += 15.О;
rotate.setAngle(angle);
rotate.setPivotX(ЬtnRotate.getWidth()/2);
rotate.setPivotY(ЬtnRotate.getHeight()/2);
Глава 17. Введение в JavaFX 639
// Обработать события действий для кнопки Scale
btnScale.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
}
}) ;
// При каждом нажатии кнопки изменяются ее размеры
scaleFactor += 0.1;
if(scaleFactor > 2.0) scaleFactor = 0.4;
scale.setX(scaleFactor);
scale.setY(scaleFactor);
// Обработать события действий для кнопки Blur
btnBlur.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
)
) ) ;
// При каждом нажатии кнопки Blur изменяется
// степень размытия ее изображения
if(ЫurVal == 10.0) (
ЫurVal = 1.0;
ЬtnBlur. setEffect (null); 4----Удаnение эффекта размытия кнопки
ЬtnBlur. setText ( "Blur off"); ЬtnВlur
else {
ЫurVal++;
ЬtnBlur.setEffect(Ыur);
btnBlur.setText("Blur on");
Ыur.setWidth(ЬlurVal);
Ыur.setHeight(ЫurVal);
4---- Размытие кнопки Blur
// Добавить метку и кнопки в граф сцены
rootNode.getChildren().
addAll(ЬtnRotate, ЬtnScale, ЬtnBlur, reflect);
// Отобразить платформу и ее сцену
myStage.show();
Результат выполнения программы представлен на приведенном ниже рисунке.
Reflection Adds Visual Sparlde
l!􀀩f<ЦIO!J \,'Qq? 1\1< "" ?Ь"'!"-6
Завершая обсуждение темы эффектов и преобразований, следует отметить, что некоторые
из них выглядят особенно выигрышно, когда применяются к текстовым уз.лам.
640 Java 8: руководство дпя начинающих. 6-е издание
Класс Text javafx. scene. text создает узел, состоящий из текста. Поскольку текст в
данном случае является узлом, им можно легко манипулировать как целым, применяя к
нему всевозможные эффекты и преобразования.
Что дальше
Примите поздравления! Если вы прочитали и проработали материал всех 17 глав
книги, то можете смело считать себя Jаvа-программистом. Конечно, вам предстоит узнать
еще немало о самом языке Java, его библиотеках и подсистемах, но вы уже владеете
достаточным запасом базовых знаний, который послужит вам надежным фундаментом
для приобретения дополнительных знаний и опыта.
В дальнейшем вам, вероятнее всего, придется самостоятельно изучить следующие
темы.
fil JavaFX и Swing. Обе эти технологии играют важную роль в современном Jаvа-про-
граммировании.
"" Обработка событий.
tI Классы Java, обеспечивающие работу в сети.
􀂰 Служебные классы Java, в особенности из библиотеки Collections Framework, которые
упрощают решение очень многих задач программирования.
1;,. Программный интерфейс Concurrent API, позволяющий повысить надежность и
производительность многопоточных приложений.
􀂱 Технология JavaBeans, предназначенная для создания программных Jаvа-компонентов.
® Машинно-ориентированные методы.
:i'i Сервлеты. Если вам придется участвовать в создании сложных веб-приложений,
то вы вряд ли сможете обойтись без знаний и навыков разработки сервлетов.
Сервлеты играют на стороне сервера ту же роль, что и аплеты на стороне клиента,
которым чаще всего является браузер.
Для дальнейшего изучения Java рекомендуется книга Java 8. Полное руководство, 9-е
издание (Ид "Вильяме", 2015 r.).
В ней вы наЙдете подробные сведения о языке программирования Java и его основных
библиотеках, а также сотни примеров программ, демонстрирующих возможности
языка Java.
':ft
Вопросы и упражнения ДJ1Я самопроверки
1. Назовите имя пакета верхнего уровня библиотеки JavaFX.
2. Двумя центральными понятиями в JavaFX являются понятия платформы и сцены.
Какие классы их инкапсулируют?
3. Граф сцены состоит из------------------
4. Базовым классом для всех узлов служит класс _______ _
5. Какой класс должны расширять все приложения JavaFX?
Глава 17. Введение в JavaFX 641
6. Какие три метода управляют жизненным циклом приложения JavaFX?
7. В каком из методов, управляющих жизненным циклом, возможно создание платформы
приложения?
8. Метод launch () вызывается для запуска автономного приложения JavaFX. Верно
или неверно?
9. Назовите имена классов JavaFX, которые поддерживают метку и кнопку.
10. Одним из способов прекращения работы автономного приложения JavaFX является
вызов метода Patform. exit (). Класс Platform находится в пакете j avafx.
Application. При вызове метода exit () работа программы немедленно прекращается.
Учитывая это, измените программу JavaFXEventDemo, представленную в
данной главе, таким образом, чтобы она отображала две кнопки: Run и Exit. При
нажатии кнопки Run программа должна отобразить соответствующее сообщение
в метке. При нажатии кнопки Exit приложение должно завершить свою работу.
В обработчиках событий используйте лямбда-выражения.
11. Какой элемент управления JavaFX реализует флажок?
12. Класс ListView - это элемент управления, который отображает список файлов,
находящихся в некотором каталоге локальной файловой системы. Верно или неверно?
13. Преобразуйте Swing-nporpaммy для сравнения файлов из упражнения 16.1 в приложение
JavaFX. При этом воспользуйтесь предоставляемой в JavaFX возможностью
запускать события действий для кнопки программными средствами. Это
делается путем вызова метода fire () для экземпляра кнопки. К примеру, если
имеется экземпляр класса Button, который вы назвали myButton, то для запуска
событий необходимо использовать вызов myButton. fire (). Воспользуйтесь этим
при реализации обработчиков событий для текстовых полей, в которых хранятся
имена сравниваемых файлов. В тех случаях, когда пользователь нажимает клавишу
<Enter> и при этом фокус ввода находится в одном из указанных текстовых
полей, запускайте событие действия для кнопки Compare. После этого код обработчика
событий для кнопки Compare должен выполнить сравнение файлов.
14. Видоизмените программу EffectsAndTransformsDemo таким образом, чтобы размытие
изображения применялось также к кнопке Rotate. Задайте для ширины и
высоты области размытия значение 5, а для счетчика итераций - значение 2.
15. Самостоятельно поэкспериментируйте с другими эффектами и преобразованиями.
Например, попытайтесь использовать эффект Glow и преобразование
Translate.
16. Непрерывно углубляйте свои знания в области Java. Для этого было бы неплохо
начать с изучения основных пакетов Java, таких как j ava. lang, j ava. util и
j ava. net. Напишите примеры программ, демонстрирующих использование различных
классов и интерфейсов. В общем, для того чтобы стать великим Jаvа-программистом,
не существует лучшего способа, чем написать как можно больше
программ на Java.

Приложение А
Ответы на вопросы
и решения упражнении
для самопроверки
644 Java 8: руководство для начинающих. 6-е издание
Глава 1. Основы Java
1. Что такое байт-код и почему он так важен для интернет-программирования на
языке Java?
Байт-код - это высокооптимизированный набор инструкций, выполняемых под
управлением виртуальной машины Java. Использование байт-кода помогает улучшить
характеристики переносимости и безопасности программ на Java.
2. Каковы три ключевых принципа объектно-ориентированного программирования?
Инкапсуляция, полиморфизм и наследование.
3. С чего начинается выполнение программы на Java?
Выполнение программы на Java начинается с метода main () .
4. Что такое переменная?
Переменная - это именованная область памяти. Содержимое переменной может
изменяться в процессе выполнения программы.
5. Какое из перечисленных ниже имен переменных недопустимо?
count
$count
count27
67count
Недопустимо имя переменной 67count (пункт Г). Имя переменной не должно
начинаться с цифры.
6. Как создаются однострочный и многострочный комментарии?
Однострочные комментарии должны начинаться с символов // . В этом случае
комментариями считаются эти и все последующие символы до конца строки.
Многострочные комментарии должны начинаться символами/* и заканчиваться
символами */.
7. Как выглядит общая форма условного оператора i f? Как выглядит общая форма
цикла for?
Общая форма оператора if выглядит следующим образом:
if (условие) оператор;
Общая форма цикла for имеет следующий вид:
fоr(инициализация; условие; итерация) оператор;
8. Как создать блок кода?
Блок кода должен начинаться с символа { и заканчиваться символом } .
9. Сила тяжести на Луне составляет около 17% земной. Напишите программу, которая
вычислила бы ваш вес на Луне.
/*
Вычисление веса на Луне.
Присвоить этому файлу имя Moon.java.
*/
class Moon {
puЬlic static void main(String args[]) {
Приложение А Ответы на вопросы и решения упражнений ... 645
douЫe earthweight; //вес на Земле
douЫe rnoonweight; //вес на Луне
earthweight = 165; // значение веса на Земле в фунтах
rnoonweight = earthweight * 0.17;
Systern.out.println(earthweight +
" земных фунтов эквивалентны " +
rnoonweight + " лунных фунтов.");
10. Видоизмените программу, созданную в упражнении 1.2, таким образом, чтобы
она выводила таблицу преобразования дюймов в метры. Выведите значения длины
до 12 футов через каждый дюйм. После каждых 12 дюймов выведите пустую
строку. (Один метр приблизительно равен 39,37 дюйма.)
/*
Эта программа отображает таблицу преобразования дюймов в метры.
Присвойте этому файлу имя InchToMeterTaЫe.java.
*/
class InchToMeterTaЬle {
puЫic static void rnain(String args[]) {
douЫe inches, rneters;
int counter;
counter = О;
for(inches = 1; inches <= 144; inches++) {
rneters = inches / 39.37; // преобразовать в метры
Systern.out.println(inches + " дюймов равно " +
rneters + " метров.");
counter++;
// Каждая 12-я выводимая строка должна быть пустой
if(counter == 12) {
Systern.out.println();
counter = О; !/ сбросить счетчик строк
11. Если при вводе кода программы вы допустите опечатку, то какого рода сообщение
об ошибке получите?
Сообщение о синтаксической ошибке.
12. Имеет ли значение, с какой именно позиции в строке начинается инструкция?
Не имеет. В Java допускается произвольное форматирование исходного кода.
646 Java 8: руководство для начинающих. 6-е издание
Глава 2. Введение в типы данных
и операции над ними
1. Почему в Java строго определены диапазоны допустимых значений и области действия
простых типов?
Диапазоны допустимых значений и области действия простых типов строго определены
в Java для того, чтобы обеспечить переносимость программ с одной платформы
на другую.
2. Что собой представляет символьный тип в Java и чем он отличается от символьного
типа в ряде других языков программирования?
Символьный тип задается ключевым словом char. В Java для представления символов
используется кодировка Unicode, в не ASCII, как во многих других языках
программирования.
3. Переменная типа boolean может иметь любое значение, поскольку любое ненулевое
значение интерпретируется как истинное. Верно или неверно?
Неверно. Переменная типа boolean может принимать лишь одно из двух значений:
true или false.
4. Допустим, результат выполнения программы выглядит следующим образом.
One
Two
Three
Напишите строку кода с вызовом метода println () , где этот результат выводится
в виде одной строки.
System.out.println("One\nTwo\nThree");
5. Какая ошибка допущена в следующем фрагменте кода?
for(i = О; i < 10; i++) {
int sum;
sum = sum + i;
System.out.println("Sum is: " + sum);
В этом фрагменте кода имеются две грубые ошибки. Во-первых, переменная swn
создается на каждом шаге цикла for, а следовательно, в промежутке между последовательными
итерациями предыдущее значение подсчитываемой суммы не
будет сохраняться в этой переменной. И во-вторых, переменная swn недоступна
за пределами кодового блока, в котором она объявлена. Поэтому ссылка на нее
при вызове метода println () недопустима.
6. Поясните различие между префиксной и постфиксной формами записи операции
инкремента.
Если оператор инкремента предшествует операнду, исполняющая система Java
выполнит операцию до извлечения значения операнда и использования его в
остальной части выражения. Если же оператор инкремента следует за операндом,
исполняющая система сначала извлечет значение операнда и лишь затем инкрементирует
сам операнд.
7. Покажите, каким образом укороченная логическая операция И может предотвратить
деление на нуль.
if ( (Ь ! = О) && (val / Ы ) ...
Приложение А Ответы на вопросы и решения упражнений... 647
8. До какого типа повышаются типы byte и short при вычислении выражений?
В выражениях типы byte и short повышаются до типа int.
9. Когда возникает потребность в явном приведении типов?
Явное приведение типов требуется при выполнении преобразований между несовместимыми
типами, а также в случае преобразований, сужающих диапазон допустимых
значений.
10. Напишите программу, которая находила бы простые числа в пределах от 2 до 100.
// Нахождение простых чисел в пределах от 2 до 100
class Prime {
puЬlic static void main(String args[]) {
int i, j;
boolean isprime;
for(i=2; i < 100; i++) {
isprime = true;
// проверить, делится ли число без остатка
for (j=2; j <= i/j; j++)
// если число делится без остатка, значит, оно не простое
if((i%j) == О) isprime = false;
if (isprime)
System.out.println(i + " - простое число.");
11. Оказывают ли избыточные скобки влияние на эффективность выполнения программ?
Нет, не оказывают.
12. Определяет ли блок кода область действия переменных?
Да, определяет.
Глава 3. Управляющие операторы
1. Напишите программу, которая получает символы , введенные с клавиатуры, до
тех пор, пока не встретится точка. Предусмотрите в программе счетчик пробелов.
Сведения о количестве пробелов должны выводиться в конце программы.
// Подсчет пробелов
class Spaces {
puЫic static void main(String args[])
throws java.io.IOException {
char ch;
int spaces = О;
System.out.println("Для остановки введите символ точки.");
do {
ch (char) System.in.read();
648 Java 8: руководство для начинающих. 6-е издание
if ( ch == ' ') spaces++;
while(ch != '. ');
System.out.println("Пpoбeлoв: " + spaces);
2. Каков общий синтаксис многоступенчатой конструкции if-else-if?
if (условие)
оператор;
else if (условие)
оператор;
else if (условие)
оператор;
else
оператор;
3. Допустим, имеется следующий фрагмент кода.
if(x < 10)
if(y > 100) {
i f ( ! done) х z;
else у= z;
else System.out.println("error"); // что если?
С каким из операторов if связан последний оператор else?
Последний оператор else соответствует ближайшему оператору if того же уровня,
т.е. if (у > 100).
4. Напишите цикл for, в котором перебирались бы значения от 1000 до О с шагом
-2.
for(int i = 1000; i >= О; i -= 2) // ...
5. Корректен ли следующий фрагмент кода?
for(int i = О; i < num; i++)
sum += i;
count = i;
Нет, не корректен. Переменная i недоступна за пределами цикла for, в котором
она объявлена.
6. Какие действия выполняет оператор break? Опишите оба варианта этого оператора.
Оператор brea k без метки вызывает немедленное завершение текущего цикла
или выражения switch. Оператор break с меткой передает управление в конец
помеченного блока.
7. Какое сообщение будет выведено после выполнения оператора break в приведенном
ниже фрагменте кода?
for(i = О; i < 10; i++) {
while(running) {
Приложение А Ответы на вопросы и решения упражнений... 649
if(x<y) break;
// . . .
System.out.println("Пocлe while");
System.out.println("Пocлe for");
После выполнения оператора break будет выведено сообщение "После while".
8. Что будет выведено на экран в результате выполнения следующего фрагмента
кода?
for (int i = О; i<lO; i++) {
System.out.print(i + " ");
if((i%2) == О) continue;
System.out.println();
На экране появится следующий результат.
О 1
2 3
4 5
6 7
8 9
9. Итерационное выражение для цикла for не обязательно должно изменять переменную
цикла на фиксированную величину. Эта переменная может принимать
произвольные значения. Напишите проrрамму, использующую цикл for для вывода
членов геометрической проrрессии 1, 2, 4, 8, 16, 32 и т.д.
/* Использование цикла for для формирования
геометрической прогрессии 1, 2, 4, 8, 16, 32 и т.д.
*/
class Progress {
puЫic static void main(String args[])
for(int i = 1; i < 100; i += i)
System.out.print{i + " ");
10. Коды ASCII символов нижнего регистра отличаются от кодов соответствующих
символов верхнего регистра на величину 32. Следовательно, для преобразования
строчной буквы в прописную нужно уменьшить ее код на 32. Используйте это обстоятельство
для написания проrраммы, осуществляющей получение символов с
клавиатуры . При выводе результатов данная программа должна преобразовывать
строчные буквы в прописные, а прописные - в строчные. Остальные символы не
должны изменяться. Работа проrраммы должна завершаться после того, как пользователь
введет с клавиатуры точку. И наконец, сделайте так, чтобы проrрамма
отображала число символов, для которых бьт изменен регистр.
// Смена регистра символов
class CaseChg {
puЬlic static void main(String args[J)
650 Java 8: руководство для начинающих. 6-е издание
throws java.io.IOException
char ch;
int changes = О;
Systern.out.println("Для остановки введите символ точки.");
do {
ch = (char) Systern.in.read();
if(ch >= 'а' & ch <= 'z') {
ch -= 32;
changes++;
Systern.out.println(ch);
else if (ch >= 'А' & ch <= 'z') {
ch += 32;
changes++;
Systern.out.println(ch);
while(ch != '. ');
Systern.out.println("Измeнeниe регистра: " + changes);
11. Что такое бесконечный цикл?
Бесконечным называется цикл, выполнение которого никогда не прекращается.
12. Должна ли метка, используемая вместе с оператором brea k, быть определена в
блоке кода, содержащем этот оператор?
Да,должна.
Глава 4. Введение в классы, объекты и методы
1. Чем отличается класс от объекта?
Класс - это абстрактное логическое описание формы и поведения объекта, тогда
как объект - это вещественный экземпляр класса.
2. Как определяется класс?
Класс определяется с помощью ключевого слова class. В операторе class указываются
код и данные, составляющие класс.
3. Чью собственную копию содержит каждый объект?
Каждый объект класса содержит собственную копию переменных экземпляра
этого класса.
4. Покажите, как объявить объект counter класса MyCounter, используя два отдельных
оператора.
MyCounter counter;
counter = new MyCounter();
5. Как должен быть объявлен метод myMeth () , принимающий два параметра, а и Ь,
типа int и возвращающий значение типа douЫe?
douЫe rnyMeth (int а, int Ь) { // ••.
Приложение А Ответы на вопросы и решения упражнений... 651
6. Как должно завершаться выполнение метода, возвращающего некоторое значение?
Для завершения метода служит оператор return. Он же передает возвращаемое
значение вызывающей части программы.
7. Каким должно быть имя конструктора?
Имя конструктора должно совпадать с именем класса.
8. Какие действия выполняет оператор new?
Оператор new выделяет память для объекта и выполняет его инициализацию, используя
конструктор.
9. Что такое "сборка мусора" и какие действия она выполняет? Когда вызывается
метод finalize ()?
Сборка мусора - это механизм удаления неиспользуемых объектов для повторного
использования освобождаемой памяти. Метод finalize () вызывается для
объекта непосредственно перед его удалением из памяти.
10. Что означает ключевое слово this?
Ключевое слово this означает ссылку на объект, для которого вызывается метод.
Эта ссылка автоматически передается методу.
11. Может ли конструктор иметь один или несколько параметров?
Да, может.
12. Если метод не возвращает значения, то как следует объявить тип этого метода?
13. Как void.
Глава 5. Дополнительные сведения
о типах данных и операциях
1. Покажите два способа объявления одномерного массива, состоящего из 12 элементов
типа douЬle.
douЫe х[] = new douЫe[l2];
douЬle[] х = new douЫe[l2];
2. Покажите, как инициализировать одномерный массив целочисленными значениями
от 1 до 5.
int х[] = { 1, 2, 3, 4, 5 };
3. Напишите программу, в которой массив используется для нахождения среднего
арифметического десяти значений типа douЫe. Используйте любые десять чисел.
// Среднее арифметическое 10 значений типа douЫe
class Avg {
puЫic static void main(String args[]) {
douЫe nums[] = { 1.1, 2.2, 3.3, 4.4, 5.5,
6.6, 7.7, 8.8, 9.9, 10.1 };
douЫe sum = О;
for(int i=O; i < nums.length; i++)
sum += nums[i];
652 Java 8: руководство для начинающих. 6-е издание
Systern.out.println("Cpeднee значение: " + surn / nurns.length);
4. Измените программу, созданную в упражнении 5.1, таким образом, чтобы она сортировала
массив строк. Продемонстрируйте ее работоспособность.
// Демонстрация пузырьковой сортировки строк
class StrBubЫe {
puЫic static void rnain(String args[J) {
String strs[J = {
int а, Ь;
String t;
int size;
"this", 11 is 11
, "а", "test 11
,
"of", "а", "string", "sort"
};
size = strs.length; // количество сортируемых элементов
// Отобразить исходный массив
Systern.out.print("Иcxoдный массив:");
for(int i=O; i < size; i++)
Systern.out.print(" " + strs[i]);
Systern.out.println();
// Пузырьковая сортировка строк
for(a= l; а < size; а++)
for(b=size-1; Ь >= а; Ь--) {
// поменять элементы местами при нарушении
// порядка их следования
if(strs[b-1].cornpareTo(strs[b]) > О) {
t = strs[b-1];
strs[b-1] = strs[b];
strs[b] = t;
// Отобразить отсортированный массив
Systern.out.print("Oтcopтиpoвaнный массив:");
for(int i=O; i < size; i++)
Systern.out.print(" " + strs[i]);
Systern.out.println();
5. В чем состоит разница между методами indexOf () и lastindexOf () класса
String?
Метод indexOf () находит первое вхождение указанной подстроки, а метод
lastindexOf () - ее последнее вхождение в текущей строке.
6. Все строки являются объектами типа String. Покажите, как вызываются методы
length () и charAt () для строкового литерала "Мне нравится Java ".
Юtк ни странно, приведенный ниже вызов метода length () вполне допустим.
Systern.out.println("Mнe нравится Java".length());
Приложение А Ответы на вопросы и решения упражнений... 653
В результате этого вызова на экран выводится значение 17. Аналогичным образом
вызывается и метод charAt ().
7. Расширьте класс Encode таким образом, чтобы в качестве ключа шифрования использовалась
строка из восьми символов.
// Улучшенный вариант программы шифрования сообщений
// с помощью операции поразрядного исключающего ИЛИ
class Encode {
puЫic static void main(String args[])
String msg = "This is а test";
String encmsg = "";
String decmsg = "";
String key = "abcdefgi";
int j;
System.out.print("Иcxoднoe сообщение: ");
System.out.println(msg);
// зашифровать сообщение
j = О;
for(int i=O; i < msg.length(); i++) {
encmsg = encmsg + (char) (msg.charAt(i) л key.charAt(j));
j++;
if (j==8) j = О;
System.out.print("Зaшифpoвaннoe сообщение: ");
System.out.println(encmsg);
// дешифровать сообщение
j = О;
for(int i=O; i < msg.length(); i++) {
decmsg = decmsg + (char) (encmsg.charAt(i) л key.charAt(j));
j++;
if (j==8) j = О;
System.out.print("Дeшифpoвaннoe сообщение: ");
System.out.println(decmsg);
8. Можно ли применять поразрядные операции к значениям типа douЫe?
Нет, нельзя.
9. Перепишите приведенную ниже последовательность операторов, воспользовавшись
оператором?.
if(x < О) у= 10;
else у= 20;
Ответ:
у= х <О? 10 20;
654 Java 8: руководство дnя начинающих. 6-е издание
10. В приведенном ниже фрагменте кода содержится знак &. Какой операции он соответствует:
поразрядной ЮIИ логической? Обоснуйте свой ответ.
boolean а, Ь;
/ / . . .
if(a &b) ...
Это логическая операция, поскольку оба операнда относятся к типу boolean.
11. Является ли ошибкой превышение верхней границы массива?
Да.
Является ли ошибкой использование отрицательных значений для доступа к элементам
массива?
Да. Значения индексов массива начинаются с нуля.
12. Как обозначается операция сдвига вправо без знака?
>>>
13. Перепишите рассмотренный ранее в этой главе класс MinМax таким образом, чтобы
в нем использовалась разновидность for-each цикла for.
// Нахождение минимального и максимального значений в массиве
class MinMax {
puЫic static void rnain(String args[]) {
int nurns[J = new int[lOJ;
int rnin, rnax;
nurns[O]
nurns (1)
nurns[2]
nurns[3]
nurns[4]
nurns[SJ
nurns[6)
nurns[7]
nurns[8]
nurns [9]
99;
-10;
100123;
18;
-978;
5623;
463;
-9;
287;
49;
rnin = rnax = nurns[OJ;
for(int v : nurns) {
if(v < min) rnin v;
if(v > rnax) rnax v;
Systern.out.println("rnin и max: " + min + " " + rnax);
14. В упражнении 5.1 была реализована пузырьковая сортировка. Можно ли в программе
из этого примера заменить обычный цикл for его разновидностью foreach?
Если нельзя, то почему?
Циклы for, выполняющие сортировку в классе ВuЬЫе, нельзя преобразовать в
вариант for-each. Что касается внешнего цикла, то текущее значение его переменной
используется во внутреннем цикле. А что касается внутреннего цикла, то
для перестановки неупорядоченных элементов требуются операции присваивания
значений элементам массива, что недопустимо в варианте for-each.
Приложение А Ответы на вопросы и решения упражнений... 655
15. Можно ли управлять оператором switch с помощью объектов типа String?
Можно, начиная с версии JDK 7.
Глава 6. Дополнительные сведения
о методах и классах
1. Предположим, имеется следующий фрагмент кода.
class Х {
private int count;
Исходя из этого, допустим ли следующий код?
class У {
puЫic static void main(String args[]) {
Х оЬ = new Х ( ) ;
ob.count = 10;.
Нет. Закрытый (private) член недоступен за пределами своего класса.
2. Модификатор доступа должен объявлению члена класса.
предшествовать
3. Помимо очереди, в программах часто используется структура данных, которая
называется стеком. Обращение к стеку осуществляется по принципу "первым
пришел - последним обслужен". Стек можно сравнить со стопкой тарелок, стоящих
на столе. Последней берется тарелка, поставленная на стол первой. Создайте
класс Stack, реализующий стек для хранения символов. Используйте методы
push () и рор () для манипулирования содержимым стека. Пользователь класса
Stack должен иметь возможность задавать размер стека при его создании. Все
члены класса Stack, кроме методов push () и рор (), должны быть объявлены
как pri vate. (Подсказка: в качестве исходной заготовки можете воспользоваться
классом Queue, изменив в нем лишь способ доступа к данным.)
// Класс, реализующий стек для хранения символов
class Stack {
private char stck[J; // массив для хранения элементов стека
private int tos; // вершина стека
// Создать пустой стек заданного размера
Stack(int size) {
stck = new char[size]; // выделить память для стека
tos = О;
// Создать один стек из другого стека
Stack(Stack оЬ)
tos = ob.tos;
stck = new char[ob.stck.length];
// скопировать элементы
for(int i=O; i < tos; i++)
stck[i] = ob.stck[i];
656 Java 8: руководство для начинающих, 6-е издание
// Создать стек с начальными значениями
Stack(char a[J) {
stck = new char[a.length];
for(int i = О; i < a.length; i++) (
push(a[i]);
// Поместить символы в стек
void push(char ch) {
if(tos==stck.length)
System.out.println(" -- Стек заполнен");
return;
stck[tos] ch;
tos++;
// Извлечь символы из стека
char рор() (
if ( tos==O) (
System.out.println(" -- Стек пуст");
return (char) О;
tos--;
return stck[tos];
// Демонстрация использования класса Stack
class SDemo (
puЫic static void main(String args[]) {
// создать пустой стек на 10 элементов
Stack stkl = new Stack(lO);
char name[] = {'Т', 'о', 'm'};
// создать стек из массива
Stack stk2 = new Stack(name);
char ch;
int i;
// поместить символы в стек stkl
for(i=O; i < 10; i++)
stkl.push((char) ('А' + i));
// создать один стек из другого стека
Stack stkЗ = new Stack(stkl);
Приложение А Ответы на вопросы и решения упражнений... 657
// отобразить стеки
System.out.print("Coдepжимoe stkl: ");
for (i=O; i < 10; i++) {
ch = stkl.pop();
System.out.print(ch);
System.out.println("\n");
System.out.print("Coдepжимoe stk2: ");
for (i=O; i < З; i++) {
ch = stk2.pop();
System.out.print(ch);
System.out.println("\n");
System.out.print("Coдepжимoe stkЗ: ");
for (i=O; i < 10; i++) {
ch = stkЗ.pop();
System.out.print(ch);
Ниже приведен результат выполнения данной программы.
Содержимое stkl: JIHGFEDCBA
Содержимое stk2: moT
Содержимое stkЗ: JIHGFEDCBA
4. Предположим, имеется следующий класс.
class Test
int а;
Test(int i) { а = i; }
Напишите метод swap () , реализующий обмен содержимым между двумя объектами
типа Test, на которые ссылаются две переменные данного типа.
void swap(Test оЫ, Test оЬ2) {
int t;
t = оЫ.а;
оЫ.а оЬ2.а;
оЬ2.а = t;
5. Правильно ли написан следующий фрагмент кода?
class Х {
int meth(int а, int Ь) ( ••. }
String meth(int а, int Ь) { ...
Нет, неправильно. Перегружаемые методы могут возвращать значения разного
типа, но это не играет никакой роли при разрешении ссылок на перегруженные
версии. Перегружаемые методы должны иметь разные списки параметров.
658 Java 8: руководство мя начинающих. 6-е издание
6. Напишите рекурсивный метод, отображающий символы, составляющие строку, в
обратном порядке.
// Отображение символов строки в обратном порядке
// с ПОМОЩЬЮ рекурсии
class Backwards {
String str;
Backwards (String s) {
str = s;
void backward(int idx) {
if(idx != str.length()-1) backward(idx+l);
System.out.print(str.charAt(idx));
class BWDemo {
puЫic static void main(String args[])
Backwards s = new Backwards("This is а test");
s.backward(O);
7. Допустим, все объекты класса должны совместно использовать одну и ту же переменную.
Как объявить такую переменную?
Переменная, предназначенная для совместного использования, должна быть объявлена
как static.
8. Для чего может понадобиться статический блок?
Статический блок служит для выполнения любых инициализирующих действий в
классе до создания конкретных объектов.
9. Что такое внутренний класс?
Внутренний класс - это нестатический вложенный класс.
10. Допустим, требуется член класса, к которому могут обращаться только другие
члены этого же класса. Какой модификатор доступа следует использовать в его
объявлении?
Модификатор доступа private.
11. Имя метода и список его параметров вместе составляют ______ метода.
сигнатуру
12. Если методу передается значение типа int, то в этом случае используется переда-
ча параметра по _____ _
значению
13. Создайте метод sum () , принимающий список аргументов переменной длины и
предназначенный для суммирования передаваемых ему значений типа int. Метод
должен возвращать результат суммирования. Продемонстрируйте работу этого
метода.
Приложение А Ответы на вопросы и решения упражнений... 659
Существует множество вариантов решения данной задачи. Ниже представлен
ОДИН ИЗ НИХ.
class Sumrt {
int sum(int ... n)
int result = О;
for(int i = О; i < n.length; i++)
result += n[i];
return result;
class SumDemo {
puЫic static void main(String args[]) {
Sumit siObj = new Sumit();
int total = siObj.sum(l, 2, З);
System.out.println("Cyммa: " + total);
total = siObj.sum(l, 2, 3, 4, 5);
System.out.println("Cyммa: " + total};
14. Можно ли перегружать методы с переменным количеством аргументов?
Да, можно.
15. Приведите пример вызова переrруженноrо метода с переменным количеством аргументов,
демонстрирующий возникновение неоднозначности.
Ниже приведен один из вариантов переrружаемоrо метода с переменным числом
аргументов, при вызове которого проявляется неоднозначность.
douЫe myMeth(douЫe ... v ) { // ...
douЫe myMeth(douЫe d, douЫe ... v) { // ...
Если попытаться вызвать метод myМeth ( ) с одним аргументом следующим образом:
myMeth(l.1);
то компилятор не сможет определить, какой именно метод вызывается.
Глава 7. Наследование
1. Имеет ли суперкласс доступ к членам подкласса? Имеет ли подкласс доступ к
членам суперкласса?
Нет, не имеет. Суперклассу ничеrо не известно о существовании подклассов.
Подклассы действительно могут обращаться ко всем членам суперкласса, кроме
тех, которые объявлены как закрытые (private).
2. Создайте подкласс Circle, производный от класса TwoDShape. В нем должен
быть определен метод area () , вычисляющий площадь круга, а также конструктор
с ключевым словом super для инициализации членов, унаследованных от класса
TwoDShape.
660 Java 8: руководство для начинающих. 6-е издание
// Подкласс, производный от класса TwoDShape, для окружностей
class Circle extends TwoDShape {
// Конструктор по умолчанию
Circle () {
super();
// Конструктор класса Circle
Circle(douЫe х) {
super(x, "circle"); // вызвать конструктор суперкласса
// Создать новый объект из имеющегося объекта
Circle (Circle оЬ) {
super(ob); // передать объект конструктору класса TwoDShape
douЫe area () {
return (getWidth() / 2) * (getWidth() / 2) * 3.1416;
3. Как предотвратить обращение к членам суперкласса из подкласса?
Чтобы предотвратить доступ к членам суперкласса из подкласса, эти члены следует
объявить как закрытые (private).
4. Опишите назначение и два варианта использования ключевого слова super.
Ключевое слово super используется в двух случаях. Во-первых, с его помощью
вызывается конструктор суперкласса. В этом случае общая форма вызова имеет
следующий вид:
suреr(список_параметров);
И во-вторых, это ключевое слово обеспечивает доступ к членам суперкласса.
Ниже приведена общая форма такого доступа.
suреr. член
_
класса
5. Допустим, имеется следующая иерархия классов.
class Alpha { ...
class Beta extends Alpha
Class Gamma extends Beta
В каком порядке вызываются конструкторы этих классов при создании объекта
класса Gamma?
Конструкторы всегда вызываются в порядке наследования. Таким образом, при
создании экземпляра класса Gamma будет сначала вызван конструктор Alpha, затем
Beta и наконец Gamma.
6. Переменная ссылки на суперкласс может указывать на объект подкласса. Объясните,
почему это важно и как это связано с переопределением методов?
Когда переопределяемый метод вызывается по ссылке на суперкласс, его вариант
определяется по типу объекта, на который делается ссылка.
Приложение А Ответы на вопросы и решения упражнений... 661
7. Что такое абстрактный класс?
Абстрактным называется такой класс, который содержит хотя бы один абстрактный
метод.
8. Как предотвратить переопределение метода? И как предотвратить наследование
класса?
Для того чтобы метод нельзя было переопределить, его нужно объявить как
final. А для того чтобы предотвратить наследование от класса, его следует объявить
как final.
9. Объясните, каким образом механизмы наследования, переопределения методов и
абстрактные классы используются для поддержки полиморфизма.
Наследование, переопределение методов и абстрактные классы поддерживают
полиморфизм и позволяют создать обобщенную структуру, реализуемую различными
классами. Так, абстрактный класс определяет согласованный интерфейс,
общий для всех реализующих его классов. Такой подход соответствует принципу
"один интерфейс - множество методов".
10. Какой класс является суперклассом всех остальных классов?
Класс Obj ect.
11. Класс, который содержит хотя бы один абстрактный метод, должен быть объявлен
абстрактным. Верно или не верно?
Верно.
12. Какое ключевое слово следует использовать для создания именованной константы?
Ключевое слово final.
Глава 8. Пакеты и интерфейсы
1. Используя код, созданный в упражнении 8.1, поместите в пакет qpack интерфейс
ICharQ и все три реализующих его класса. Оставив класс IQDemo в пакете, используемом
по умолчанию, покажите, как импортировать и использовать классы
из пакета qpack.
Для того чтобы включить интерфейс ICharQ и реализующие его классы в пакет
qpack, следует поместить каждый из них в отдельный файл, объявить все классы,
реализующие данный интерфейс, как puЫic, а в начале каждого файла ввести
следующий оператор:
package qpack;
После этого можно использовать пакет qpack, добавив в интерфейс IQDemo следующий
оператор import:
import qpack.*;
2. Что такое пространство имен? Почему так важна возможность его разделения на
отдельные области в Java?
Пространство имен - это область объявлений. Разделяя пространство имен на
отдельные области, можно предотвратить конфликты имен.
3. Содержимое пакетов хранится в _______
каталоrах
662 Java 8: руководство для начинающих, 6-е издание
4. В чем отличие доступа, определяемого ключевым словом protected, от доступа
по умолчанию?
Член класса с доступом типа protected может быть использован в пределах текущего
пакета, а также в подклассах данного класса, относящихся к любому пакету.
Член класса с доступом по умолчанию может быть использован только в пределах
текущего пакета.
5. Допустим, классы, содержащиеся в одном пакете, требуется использовать в другом
пакете. Какими двумя способами можно этого добиться?
Для того чтобы воспользоваться членом пакета, нужно указать его полное имя
или же импортировать этот член с помощью оператора import.
6. "Один интерфейс - множество методов" - таков главный принцип Java. Какое
языковое средство лучше всего демонстрирует этот принцип?
Этот принцип объектно-ориентированного программирования лучше всего демонстрирует
интерфейс.
7. Сколько классов могут реализовать один и тот же интерфейс? Сколько интерфейсов
может реализовать класс?
Один интерфейс может быть реализован любым количеством классов. Класс может
реализовать произвольное число интерфейсов.
8. Может ли один интерфейс наследовать другой интерфейс?
Да, может. Механизм наследования распространяется и на интерфейсы.
9. Создайте интерфейс для класса Vehicle, рассмотренного в главе 7, назвав его
IVehicle.
interface IVehicle {
// Вернуть дальность поездки транспортного средства
int range();
// Вычислить объем топлива, требующегося
// для прохождения заданного пути
douЫe fuelneeded(int miles);
// Методы доступа к переменным экземпляра
int getPassengers();
void setPassengers(int р);
int getFuelcap();
void setFuelcap(int f);
int getMpg();
void setMpg(int m);
10. Переменные, объявленные в интерфейсе, неявно принимают модификаторы
static и final. Какие преимущества это дает?
Переменные, объявленные в интерфейсе, могут использоваться в качестве именованных
констант, общих для всех файлов программы. Доступ к ним обеспечивается
путем импорта того интерфейса, в котором они объявлены.
11. Пакет по сути является контейнером для классов. Верно или не верно?
Верно.
Приложение А Ответы на вопросы и решения упражнений... 663
12. Какой стандартный пакет автоматически импортируется в любую программу на
Java?
Пакет j ava. lang.
13. Какое ключевое слово используется для объявления в интерфейсе метода по
умолчанию?
Это слово default.
14. Возможно ли, начиная с JDK 8, определение статического метода интерфейса?
Да.
15. Предположим, что интерфейс ICharQ, представленный в упражнении 8.1, получил
широкое распространение в течение нескольких лет. В какой-то момент вы решили
добавить в него метод reset () , который будет использоваться для сброса очереди
в ее исходное пустое состояние. Как это можно осушествить, не нарушая работоспособности
сушествующего кода, в случае использования комплекта JDK 8?
Для этого необходимо использовать метод по умолчанию. Вы не можете знать,
как сбрасывать каждую реализацию очереди, поэтому стандартная реализация
метода reset () должна сообщать об ошибке, указывающей на отсутствие реализации.
(Лучше всего генерировать исключение; см. следующую главу.) К счастью,
поскольку отсутствует сушествующий код, предполагающий наличие у интерфейса
ICharQ метода reset (), в сушествующем коде подобная ошибка не возникнет
и его работоспособность не будет нарушена.
16. Как можно вызвать статический метод интерфейса?
Статический метод вызывается с указанием имени интерфейса, после которого
ставится разделитель-точка.
Глава 9. Обработка исключений
1. Какой класс находится на вершине иерархии исключений?
На вершине иерархии исключений находится класс ThrowaЫe.
2. Объясните вкратце, как используются ключевые слова try и catch?
Ключевые слова try и catch используются совместно. Операторы программы, в
которых вы хотите отслеживать исключения, помещаются в блок try. Перехват и
обработка исключений осушествляются в блоке catch.
З. Какая ошибка допущена в приведенном ниже фрагменте кода?
// . . .
vals (18] = 10;
catch (ArrayindexOutOfBoundsException ехс) {
// обработать ошибку
Блоку catch не предшествует блок try.
4. Что произойдет, если исключение не будет перехвачено?
Если исключение не будет перехвачено, произойдет аварийное завершение программы.
5. Какая ошибка допушена в приведенном ниже фрагменте кода?
class А extends Exception { ...
class В extends А { ...
664 Java 8: руководство для начинающих. 6-е издание
// . . .
try {
/ / . . .
catch (А ехс) { . . . }
catch (В ехс) { . . . }
В данном фрагменте кода оператор catch для суперкласса предшествует оператору
catch для подкласса. А поскольку оператор catch для суперкласса будет перехватывать
также исключения, относящиеся к подклассу, то в программе окажется
код, которому никогда не будет передано управление.
6. Может ли внутренний блок catch повторно генерировать исключение, которое
будет обработано во внешнем блоке catch?
Да, исключения могут генерироваться повторно.
7. Блок finally - последний фрагмент кода, выполняемый перед завершением
программы. Верно или неверно? Обоснуйте свой ответ.
Неверно. Блок finally выполняется по завершении блока try.
8. Исключения какого типа необходимо явно объявлять с помощью оператора
throws, включаемого в объявление метода?
С помошьiо оператора t h r o w s объявляются все исключения, кроме
RuntimeException и Error.
9. Какая ошибка допущена в приведенном ниже фрагменте кода?
class MyClass { // ...
// . . .
throw new MyClass{);
Класс MyClass не является производным от класса ThrowaЫe. С помощью оператора
throw могут генерироваться лишь те исключения, которые являются подклассами,
производными от ThrowaЫe.
10. Отвечая на вопрос 3 упражнения для самопроверки по материалу главы 6, вы
создали класс Stack. Добавьте в него пользовательские исключения, чтобы программа
нужным образом реагировала на попытки поместить элемент в заполненный
стек или извлечь элемент из пустого стека.
// Исключение, возникающее при переполнении стека
class StackFullException extends Exception {
int size;
StackFullException ( int s) { size s; }
puЫic String toString() {
return "\nСтек заполнен. Максимальный размер стека: " +
size;
// Исключение, возникающее при обращении к пустому стеку
class StackEmptyException extends Exception {
Приложение А Ответы на вопросы и решения упражнений... 665
puЫic String toString()
return "\nСтек пуст.";
// Класс, реализующий стек для хранения символов
class Stack {
private char stck[); // массив для хранения элементов стека
private int tos; // вершина стека
// Создать пустой стек заданного размера
Stack (int size) {
stck = new char[size); // выделить память для стека
tos = О;
// Создать один стек из другого стека
Stack(Stack оЬ)
tos = ob.tos;
stck = new char[ob.stck.length);
// скопировать элементы
for(int i=O; i < tos; i++)
stck[i) = ob.stck[i);
// Создать стек с начальными значениями
Stack ( char а [) ) {
stck = new char[a.length];
for(int i = О; i < a.length; i++) {
try {
push(a(i]);
catch(StackFullException ехс)
System.out.println(exc);
// Поместить символы в стек
void push(char ch) throws StackFullException
if(tos==stck.length)
throw new StackFullException(stck.length);
stck[tos) ch;
tos++;
// Извлечь символы из стека
char рор() throws StackEmptyException
if(tos==O)
throw new StackEmptyException();
666 Java 8: руководство для начинающих. 6-е издание
tos--;
return stck[tos];
11. Назовите три причины, по которым могут генерироваться исключения.
Исключение может быть сгенерировано в результате ошибки в виртуальной машине
Java, ошибки в программе или явным образом с помощью оператора throw.
12. Назовите два непосредственных подкласса класса ThrowaЫe.
Классы Error и Exception
13. Что такое групповой перехват исключений?
Групповым называется такой перехват, который позволяет перехватывать два и
более исключения одним оператором catch.
14. Следует ли перехватывать в программе исключения типа Error?
Нет, не следует.
Глава 1 О. Ввод-вывод данных
1. Для чего в Java определены как байтовые, так и символьные потоки?
Первоначально в Java были определены только байтовые потоки. Они особенно
удобны для ввода-вывода двоичных данных и поддерживают произвольный доступ
в файлах. Символьные потоки оптимизированы для использования кодировки
Unicode.
2. Как известно, консольные операции ввода-вывода осуществляются в текстовом
виде. Почему же в Java для этой цели используются байтовые потоки?
Стандартные потоки ввода-вывода System. in, System. out и System. err были
определены в Java до введения символьных потоков.
3. Как открыть файл для чтения байтов?
Ниже приведен один из способов открытия файла для ввода данных типа byte.
FileinputStream fin = new FileinputStream("test");
4. Как открыть файл для чтения символов?
Ниже приведен один из способов открытия файла для ввода символов.
FileReader fr = new FileReader("test");
5. Как открыть файл для выполнения операций ввода-вывода с произвольным доступом?
Ниже приведен один из способов открытия файла для выполнения операций ввода-
вывода с произвольным доступом.
randfile = new RandomAccessFile("test", "rw");
6. Как преобразовать числовую строку "123. 23" в ее двоичный эквивалент?
Для того чтобы преобразовать числовую строку в ее двоичный эквивалент, следует
воспользоваться одним из методов синтаксического разбора, определенных в
классах оболочек типов, например Integer или DouЫe.
Приложение А. Ответы на вопросы и решения упражнений... 667
7. Напишите программу для копирования текстовых файлов. Видоизмените ее таким
образом, чтобы все пробелы заменялись дефисами. Используйте при написании
программы классы, представляющие байтовые потоки, а также традиционный
способ закрытия файла явным вызовом метода close () .
/* Копирование текстового файла с заменой пробелов дефисами.
В этой версии программы используются байтовые потоки.
Для того чтобы воспользоваться этой программой, укажите
в командной строке имена исходного и целевого файлов. Например:
java Hyphen source target
*/
import java.io.*;
class Hyphen {
puЫic static void main(String args[])
{
int i;
FileinputStream fin = null;
FileOutputStream fout = null;
// Сначала проверить, указаны ли имена обоих файлов
if (args. length ! =2 ) {
System.out.println("Иcпoльзoвaниe: Hyphen откуда куда");
return;
// Скопировать файл и заменить в нем пробелы дефисами
try {
fin = new FileinputStream(args[O]);
fout = new FileOutputStream(args[l]);
do {
i = fin.read();
// преобразовать пробел в дефис
if((char)i == ' ') i = '-';
if(i != -1) fout.write(i);
while(i != -1);
catch(IOException ехс) {
System.out.println("Oшибкa ввода-вывода: " + ехс);
finally {
try {
if(fin != null) fin.close();
catch(IOException ехс) {
System.out.println("Oшибкa при закрытии входного файла.");
try
if(fin != null) fout.close();
668 Java 8: руководство для начинающих. 6-е издание
catch(IOException ехс) {
System.out.println("Omибкa при закрытии выходного файла.");
8. Перепишите программу, созданную в предыдущем пункте, таким образом, чтобы
в ней использовались классы, представляющие символьные потоки. На этот раз
воспользуйтесь оператором try с ресурсами для автоматического закрытия файла.
/* Копирование текстового файла с заменой пробелов дефисами.
*/
В этой версии программы используются символьные потоки.
Для того чтобы воспользоваться этой программой, укажите
в командной строке имена исходного и целевого файлов. Например:
java Hyphen2 source target
Для компиляции этого кода требуется JDK 7
или более поздняя версия данного комплекта.
import java.io.*;
class Hyphen2 {
puЫic static void main(String args[])
throws IOException
int i;
// Сначала проверить, указаны ли имена обоих файлов
if (args. length ! =2 ) {
System.out.println("Иcпoльзoвaниe: CopyFile откуда куда");
return;
// Скопировать файл и заменить в нем пробелы дефисами,
// используя оператор try с ресурсами
try (FileReader fin new FileReader(args[O]);
FileWriter fout = new FileWriter(args[l]))
do {
i = fin.read();
// преобразовать пробел в дефис
if((char}i == ' ') i = '-';
if(i != -1) fout.write(i);
while ( i 1 = -1} ;
catch(IOException ехс} {
System.out.println("Omибкa ввода-вывода: " + ехс};
Приложение А Ответы на вопросы и решения упражнений... 669
9. К какому типу относится поток System. in?
К типу InputStream.
10. Какое значение возвращает метод read () из класса InputStream по достижении
конца потока?
Значение -1.
11. Поток какого типа используется для чтения двоичных данных?
Поток типа DatainputStream.
12. Классы Reader и Wri ter находятся на вершине иерархии классов ____ _
символьного ввода-вывода
13. Оператор try с ресурсами служит для-----------автоматического
управления ресурсами
14. Справедливо ли следующее утверждение: "Если для закрытия файла используется
традиционный способ, то это лучше всего делать в блоке finally"?
Справедливо.
Глава 11. Многопоточное программирование
1. Каким образом имеющиеся в Java средства многопоточного программирования
обеспечивают создание более эффективных программ?
Средства мноrопоточноrо программирования дают возможность использовать периоды
простоя, возникающие практически в любой программе. Когда операции
в одном потоке по каким-то причинам не выполняются, выполняются другие потоки.
В многоядерных системах два и более потока могут исполняться одновременно.
2. Для поддержки мноrопоточного программирования в Java предусмотрены класс
_____ и интерфейс _____ _
Для поддержки мноrопоточного программирования в Java предусмотрены класс
Тhread и интерфейс RunnaЬle.
3. В каких случаях при создании выполняемого объекта следует отдать предпочтение
расширению класса Thread, а не реализации интерфейса RunnaЫe?
Подклассы, производные от класса Thread, целесообразно создавать в тех случаях,
когда, помимо метода run () , требуется переопределить другие методы данного
класса.
4. Покажите, как с помощью метода j oin () можно организовать ожидание завершения
потокового объекта MyThrd.
MyThrd. j oin ()
5. Покажите, как установить приоритет потока MyThrd на три уровня выше нормального.
MyThrd.setPriority(Thread.NORМ_PRIORITY+З);
670 Java 8: руководство для начинающих. 6-е издание
6. Что произоЙДет, если в объявлении метода указать ключевое слово synchronized?
Если указать ключевое слово synchronized в объявлении метода, то в каждый
момент времени этот метод будет вызываться только в одном потоке для любого
заданного объекта его класса.
7. Методы wait () и notify () предназначены для обеспечения ___ _
взаимодействия потоков
8. Внесите в класс TickTock изменения для организации настоящего отчета времени.
Первую половину секунды должен занимать вывод на экран слова "Tick", а
вторую - вывод слова "Tock". Таким образом, сообщение "Tick-Tock" должно
соответствовать одной секунде отсчитываемого времени. (Время переключения
контекстов можно не учитывать.)
Для организации отчета времени достаточно ввести в классе TickTock вызовы
метода sleep () , как показано ниже.
// Вариант класса TickTock, в который введены вызовы
// метода sleep() для организации отсчета времени.
class TickTock {
String state; // содержит состояние часов
synchronized void tick(boolean running)
if(!running) { // остановить часы
state = "ticked";
notify(); // уведомить ожидающие потоки
return;
System.out.print("Tick ");
// ожидать полсекунды
try {
Thread.sleep(500);
catch(InterruptedException ехс) {
System.out.println("Bыпoлнeниe потока прервано");
state = "ticked"; // установить текущее состояние после такта "тик"
notify(); // разрешить выполнение метода tock()
try {
while(!state.equals("tocked"))
wait(); // ожидать завершения метода tock()
catch(InterruptedException ехс) {
System.out.println("Bыпoлнeниe потока прервано");
Приложение А Ответы на вопросы и решения упражнений... 671
synchronized void tock(boolean running)
if(!running) { // остановить часы
state = "tocked";
notify(); // уведомить ожидающие потоки
return;
System.out.println("Tock");
// ожидать полсекунды
try {
Thread.sleep(SOO);
catch(InterruptedException ехс) {
System.out.println("Bыпoлнeниe потока прервано");
state = "tocked"; // установить текущее состояние после такта "так"
notify(); // разрешить выполнение метода tick()
try {
while(!state.equals("ticked"))
wait(); // ожидать завершения метода tick()
catch(InterruptedException ехс) {
System. out .println ( "Вьuюлнение потока прервано");
9. Почему в новых программах на Java не следует применять методы suspend () ,
resW11e () и stop ()?
Методы suspend (), resume () и stop () не рекомендуется применять, поскольку
они могут стать причиной серьезных осложнений при выполнении программы.
10. С помощью какого метода из класса Thread можно получить имя потока?
С помощью метода getName () .
11. Какое значение возвращает метод isAlive ()?
Метод возвращает значение true, если вызывающий поток исполняется, или значение
false, если выполнение потока завершено.
Глава 12. Перечисления, автоупаковка,
статический импорт и аннотации
1. Константы перечислимого типа иногда называют самотипизированными. Что это
означает?
Часть "само" в термине самотипизированный означает тип перечисления, в котором
определена константа. Следовательно, константа перечислимого типа является
объектом того перечисления, в которое она входит.
2. Какой класс автоматически наследуют перечисления?
Все перечисления наследуют класс EnW11.
672 Java 8: руководство для начинающих. 6-е издание
3. Напишите для приведенного ниже перечисления программу, в которой метод
values () используется для отображения списка констант и их значений.
enum Tools {
SCREWDRIVER, WRENCH, НАММЕR, PLIERS
Это задание имеет следующее решение.
enum Tools {
SCREWDRIVER, WRENCH, НАММЕR, PLIERS
class ShowEnum {
puЫic static void main(String args[J) {
for(Tools d : Tools.values())
System.out.print(d + " имеет порядковое значение " +
d.ordinal() + '\n');
4. Созданную в упражнении 12.1 программу, имитирующую автоматизированный
светофор, можно усовершенствовать, внеся ряд простых изменений, позволяющих
выгодно воспользоваться возможностями перечислений. В исходной версии
этой программы продолжительность отображения каждого цвета светофора регулировалась
в классе TrafficLightSimulator, причем значения задержек были
жестко запрограммированы в методе run ( ) . Измените исходный код программы
таким образом, чтобы продолжительность отображения каждого цвета светофора
задавалась константами перечислимого типа TrafficLightColor. Для этого вам
понадобятся конструктор, переменная экземпляра, объявленная как pri vate, и
метод getDelay (). Подумайте о том, как еще можно улучшить данную программу.
(Подсказка: попробуйте отказаться от оператора swi tch и воспользоваться порядковыми
значениями каждого цвета для переключения светофора.)
Усовершенствованная версия программы, имитирующей работу светофора, приведена
ниже. В нее внесены два существенных изменения. Во-первых, величина
задержки переключения связана теперь со значением перечислимого типа,
что улучшает структуру кода. И во-вторых, в методе run () удалось обойтись без
оператора switch. Вместо этого методу sleep () теперь передается вызов tlc.
getDelay (), благодаря чему автоматически устанавливается задержка, соответствующая
текущему цвету светофора.
// Усовершенствованная версия программы, имитирующей
// работу светофора. Значения задержки теперь хранятся
// в классе TrafficLightColor.
// Перечисление цветов светофора
enum TrafficLightColor {
RED(l2000), GREEN(lOOOO), YELLOW(2000);
private int delay;
TrafficLightColor(int d) {
delay = d;
Приложение А Ответы на вопросы и решения упражнений... 673
int getDelay() { return delay; }
// Имитация автоматизированного светофора
class TrafficLightSimulator implements RunnaЫe
private Thread thrd; // поток для имитации светофора
private TrafficLightColor tlc; // текущее значение цвета
boolean stop = false; // для остановки имитации установить в true
boolean changed = false; // true, если светофор переключился
TrafficLightSimulator(TrafficLightColor init) {
tlc = init;
thrd = new Thread(this);
thrd.start();
TrafficLightSimulator()
tlc = TrafficLightColor.RED;
thrd = new Thread(this);
thrd.start();
// Запуск имитации автоматизированного светофора.
puЫic void run() {
while ( ! stop) {
// По сравнению с предьщущей версией программы
// код значительно упростился!
try {
Thread.sleep(tlc.getDelay());
catch(InterruptedException ехс)
System.out.println(exc);
changeColor();
// Переключить цвет светофора
synchronized void changeColor()
switch(tlc) {
case RED:
tlc = TrafficLightColor.GREEN;
break;
case YELLOW:
tlc = TrafficLightColor.RED;
break;
case GREEN:
tlc = TrafficLightColor.YELLOW;
changed true;
67 4 Java 8: руководство для начинающих. 6-е издание
notify(); // уведомить о переключении цвета светофора
// Ожидание переключения цвета светофора
synchronized void waitForChange() {
try {
while ( ! changed)
wait(); // ожидать переключения цвета светофора
changed = false;
catch(InterruptedException ехс) {
System.out.println(exc);
// Возврат текущего цвета
TrafficLightColor getColor()
return tlc;
// Прекращение имитации светофора
void cancel () {
stop = true;
class TrafficLightDemo {
puЫic static void main(String args[J) {
TrafficLightSimulator tl =
new TrafficLightSimulator(TrafficLightColor.GREEN);
for (int i=O; i < 9; i++) {
System.out.println(tl.getColor());
tl.waitForChange{);
tl.cancel();
5. Что такое упаковка и распаковка? В каких случаях выполняется автоупаковка и
автораспаковка?
Упаковка означает сохранение значения простого типа в объекте оболочки, а
распаковка - извлечение значения из объекта оболочки. Автоупаковка означает
автоматическую упаковку значения без явного создания объекта, тогда как при
автораспаковке значение простого типа автоматически извлекается из объекта
оболочки без явного вызова соответствующего метода, например intValue ().
6. Измените следующий фрагмент кода таким образом, чтобы в нем выполнялась
автоупаковка:
Short val = new Short(l23);
Это задание имеет следующее решение:
Short val = 123;
Приложение А Ответы на вопросы и решения упражнений... 675
7. Объясните, что такое статический импорт?
Статический импорт означает размещение статических членов класса или интерфейса
в глобальном пространстве имен. Это позволяет использовать статические
члены без указания имени соответствующего класса или интерфейса.
8. Какие действия выполняет приведенный ниже оператор?
import static java.lang.Integer.parseint;
Этот оператор помещает в глобальное пространство имен метод parseint () класса
оболочки типа Integer.
9. Следует ли использовать статический импорт применительно к конкретным ситуациям
или желательно импортировать статические члены всех классов?
Статический импорт уместен только в отдельных случаях. Если доступным окажется
слишком много статических членов, это может привести к конфликтам
имен и нарушению структуры кода.
10. Синтаксис аннотации основывается на ______ _
интерфейсе
11. Какая аннотация называется маркерной?
Маркерной называют аннотацию, не принимающую аргументов.
12. Справедливо ли следующее утверждение: "Аннотации применимы только к методам"?
Нет. Аннотировать можно любое объявление.
Глава 13. Обобщения
1. Обобщения очень важны, поскольку они позволяют создавать код, который:
а) обеспечивает безопасность типов;
6) пригоден для повторного использования;
в) отличается высокой надежностью;
r) обладает всеми перечисленными выше свойствами.
Ответ: r) код обладает всеми перечисленными выше свойствами.
2. Можно ли указывать простой тип в качестве аргумента типа?
Нет, нельзя. В качестве аргументов типа можно указывать только типы объектов.
3. Как объявить класс FlightSched с двумя параметрами типа?
Это задание имеет следующее решение:
class FlightSched<T, V> {
4. Измените ваш ответ на вопрос 3 таким образом, чтобы второй параметр типа обозначал
подкласс, производный от класса Thread.
Это задание имеет следующее решение:
class FlightSched<T, V extends Thread>
5. Внесите изменения в класс FlightSched таким образом, чтобы второй параметр
типа стал подклассом первого параметра типа.
Это задание имеет следующее решение:
class FlightSched<T, V extends Т> {
676 Java 8: руководство дпя начинающих. 6-е издание
6. Что обозначает знак ? в обобщениях?
Знак ? обозначает метасимвольный аргумент, который соответствует любому допустимому
типу.
7. Может ли шаблон аргумента быть ограниченным?
Да. Шаблон аргумента может ограничиваться как сверху, так и снизу.
8. У обобщенного метода MyGen ( } имеется один параметр типа, определяющий тип
передаваемого ему аргумента. Этот метод возвращает также объект, тип которого
соответствует параметру типа. Как должен быть объявлен метод MyGen (}?
Это задание имеет следующее решение:
<Т> т MyGen(T О) { // •••
9. Допустим, обобщенный интерфейс объявлен так:
interface IGenIF<T, V extends Т> { // ...
Напишите объявление класса MyClass, который реализует интерфейс IGenlF.
Это задание имеет следующее решение:
class MyClass<T, V extends Т> implements IGenIF<T, V> { // ...
10. Допустим, имеется обобщенный класс Counter<T>. Как создать объект его базового
типа?
Для того чтобы получить базовый тип из обобщенного класса Counter<T>, достаточно
указать его имя, не обозначая тип:
Counter х = new Counter;
11. Существуют ли параметры типа на стадии выполнения программы?
Нет. Все параметры типа удаляются на стадии компиляции и заменяются соответствующими
приводимыми типами. Этот процесс называется очисткой.
12. Видоизмените ответ на вопрос 10 в упражнении для самопроверки из главы 9 таким
образом, чтобы сделать класс обобщенным. Для этого создайте интерфейс
стека IGenStack, объявив в нем обобщенные методы push (} и рор (} .
// Обобщенный стек
interface IGenStack<T>
void push(T obj) throws StackFullException;
Т рор() throws StackEmptyException;
// Исключение, возникающее при переполнении стека
class StackFullException extends Exception {
int size;
StackFullException (int s) { size s; }
puЫic String toString () {
return "\nСтек заполнен. Максимальный размер стека: " +
size;
Приложение А Ответы на вопросы и решения упражнений... 677
// Исключение, возникающее при обращении к пустому стеку
class StackEmptyException extends Exception {
puЫic String toString()
return "\nСтек пуст";
// Класс, реализующий стек для хранения символов
class GenStack<T> implements IGenStack<T> {
private Т stck[J; // массив для хранения элементов стека
private int tos; // вершина стека
// Создать пустой стек заданного размера
GenStack(T[] stckArray}
stck = stckArray;
tos = О;
// Создать один стек из другого стека
GenStack(T[J stckArray, GenStack<T> оЬ)
tos = ob.tos;
stck = stckArray;
try {
if(stck.length < ob.stck.length)
throw new StackFullException(stck.length);
catch(StackFullException ехс}
System.out.println(exc);
// Скопировать элементы
for(int i=O; i < tos; i++}
stck[i] = ob.stck[i];
// Создать стек с начальными значениями
GenStack(T[J stckArray, T[J а) {
stck = stckArray;
for(int i = О; i < a.length; i++} (
try {
push(a[i]};
catch(StackFullException ехс}
System.out.println(exc};
// Поместить объекты в стек
678 Java 8: руководство для начинающих, 6-е издание
puЫic void push(T obj) throws StackFullException
if(tos==stck.length)
throw new StackFullException(stck.length);
stck[tos] obj;
tos++;
// Извлечь объекты из стека
puЫic Т рор() throws StackEmptyException
if {tos==O)
throw new StackEmptyException{);
tos--;
return stck[tos];
// Демонстрация использования класса GenStack
class GenStackDemo {
puЬlic static void main {String args (]) {
// Создать пустой стек на 10 элементов типа Integer
Integer iStore(] = new Integer(lO];
GenStack<Integer> stkl = new GenStack<Integer>{iStore);
// Создать стек из массива
String name [] = { "One", "Two", "Three"};
String strStore[J = new String(З];
GenStack<String> stk2 =
new GenStack<String>{strStore, name);
String str;
int n;
try
// Поместить ряд значений в стек stkl
for{int i=O; i < 10; i++)
stkl.push{i);
catch{StackFullException ехс) {
System.out.println{exc);
// Создать один стек из другого стека
String strStore2[] = new String[З];
GenStack<String> stkЗ =
new GenStack<String>(strStore2, stk2);
try
// отобразить стеки
System.out.print{"Coдepжимoe stkl: ");
for (int i=O; i < 10; i++) {
n = stkl.pop{);
Приложение А Ответы на вопросы и решения упражнений... 679
System.out.print(n + " ");
System.out.println("\n");
System.out.print("Coдepжимoe stk2: ");
for (int i=O; i < З; i++) {
str = stk2.pop();
System.out.print(str + " ");
System.out.println("\n");
System.out.print("Coдepжимoe stkЗ: ");
for (int i=O; i < 3; i++) {
str = stkЗ.pop();
System.out.print(str + " ");
catch(StackEmptyException ехс) {
System.out.println(exc);
System.out.println();
13. Что означает пара угловых скобок ( < > )?
Угловые скобки обозначают пустой список аргументов типа.
14. Как упростить приведенную ниже строку кода в версии JDK 7?
MyClass<DouЫe,String> obj = new MyClass<DouЬle,String>(l.l,"Hi");
Эту строку кода можно упростить, используя ромбовидный оператор следующим
образом:
MyClass<DouЫe,String> obj = new MyClass<>(l.l,"Hi");
Глава 14. Лямбда-выражения и ссылки на методы
1. Что такое лямбда-оператор?
Это оператор->.
2. Что такое функциональный интерфейс?
Функциональный интерфейс - это интерфейс, который имеет один и только
один абстрактный метод.
3. Какая связь существует между функциональными интерфейсами и лямбда-выражениями?
Лямбда-выражение предоставляет реализацию абстрактного метода, определяемого
функциональным интерфейсом. Функциональный интерфейс определяет
целевой тип.
680 Java 8: руководство для начинающих. 6-е издание
4. Назовите два общих типа лямбда-выражений.
Двумя общими типами лямбда-выражений являются выражения-лямбды и блочные
лямбда-выражения. Выражение-лямбда (лямбда) определяет одиночное выражение,
значение которого возвращается лямбдой. Блочное лямбда-выражение
содержит блок кода. Его значение определяется оператором return.
5. Составьте лямбда-выражение, которое возвращает значение t rue, если число
принадлежит диапазону чисел 10-20, включая граничные значения.
(n) -> (n > 9 && n < 21)
6. Создайте функциональный интерфейс, способный поддерживать лямбда-выражение,
предложенное в п.5. Вызовите интерфейс MyTest и его абстрактный метод
testing ().
interface MyTest
boolean testing(int n);
}
7. Создайте блочное лямбда-выражение для вычисления факториала целого числа.
Продемонстрируйте его использование. В качестве функционального интерфейса
используйте интерфейс NwnericFunc, который рассматривался в этой главе.
interface NumericFunc
int func(int n);
class FactorialLamЬdaDemo {
puЫic static void main(String args[])
{
// Это блочное выражение вычисляет факториал
// целочисленного значения
NumericFunc factorial = (n) -> {
} ;
int result = 1;
for(int i=l; i <= n; i++)
result = i * result;
return result;
System.out.println("Фaктopиaл 3 равен " + factorial.func(З});
System.out.println("Фaктopиaл 5 равен " + factorial.func(5}};
System.out.println("Фaктopиaл 9 равен " + factorial.func(9));
8. Создайте обобщенный функциональный интерфейс MyFunc<T>. Вызовите его
абстрактный метод func () . Метод func ( ) должен принимать параметр типа т
и возвращать ссылку типа т. (Таким образом, интерфейс MyFunc должен представлять
собой обобщенную версию интерфейса NwnericFunc, который рассматривался
в этой главе.) Продемонстрируйте его использование, переработав свое
решение для п. 7 таким образом, чтобы вместо интерфейса NumericFunc в нем
использовался интерфейс MyFunc<T>.
Приложение А Ответы на вопросы и решения упражнений ... 681
interface MyFunc<T>
Т func (Т n);
class FactorialLamЬdaDemo {
puЬlic static void main(String args[J)
{
// Это блочное лямбда-выражение вычисляет факториал
// целочисленного значения
MyFunc<Integer> factorial = (n) -> {
};
int result = l;
for(int i=l; i <= п; i++)
result = i * result;
return result;
System.out.println("Фaктopиaл 3 равен " + factorial.func(З));
Systern.out.println("Фaктopиaл 5 равен " + factorial.func(5));
Systern.out.println("Фaктopиaл 9 равен " + factorial.func(9));
9. Используя программу, созданную в упражнении 14.1, создайте лямбда-выражение,
которое удаляет все пробелы из заданной строки и возвращает результат.
Продемонстрируйте работу этого метода, передав его методу changeStr () .
StringFunc remove = (str) -> {
} ;
String result = "";
for(int i = О; i < str.length(); i++)
if(str.charAt(i} != ' ') result += str.charAt(i);
return result;
Вот пример его использования:
outStr = changeStr(remove, inStr);
10. Можно ли использовать в лямбда-выражении локальную переменную? Если это
так, то какие при этом существуют ограничения?
Можно, но переменная должна иметь тип final.
11. Справедливо ли следующее утверждение: "Если лямбда-выражение может генерировать
проверяемое исключение, то абстрактный метод функционального интерфейса
должен содержать оператор throws, в котором указано данное исключение"?
Это так.
12. Что такое ссылка на метод?
Ссылка на метод - это способ обращения к методу без его вызова.
13. При вычислении ссылки на метод создается экземпляр ---------предоставляемого
целевым контекстом.
функциональноrо интерфейса
682 Java 8: руководство для начинающих. 6-е издание
14. Предположим, имеется класс MyClass, содержащий статический метод
myStaticMethod (). Продемонстрируйте, каким образом можно указать ссьmку на
метод mySta ticMethod ().
rnyClass::rnyStaticMethod
15. Предположим, имеется к ласс MyCla ss, содержащий объектный метод
myinst Method (), и относящийся к этому классу объект mcObj. Продемонстрируйте,
каким образом можно создать ссьmку на метод myinst Method (), ассоциированный
с объектом mcObj.
rncObj::myinstMethod
16. В программе M e t o dRefDemo2 добавьте в класс Myin tNum новый метод
hasCommonFactor (). Этот метод должен возвращать true, если его аргумент
типа int и значение, которое хранится в вызывающем объекте MyintNum, имеют
по крайней мере один общий делитель. Продемонстрируйте работу метода
hasCommonFactor () , используя ссьmку на метод.
Ниже приведено объявление класса MyintNum, в который добавлен метод
hasCommonFactor ()
class MyintNurn {
private int v;
MyintNurn(int х) { v = х;
int getNurn () { return v;
// Вернуть true, если n является делителем v
boolean isFactor(int n)
return (v % n) == О;
boolean hasCornmonFactor(int n) {
for(int i=2; i < v/i; i++)
if ( ( ( v % i ) == О) & & ( ( n % i)
return false;
О) ) return true;
Ниже приведен пример использования этого класса посредством ссьmки на метод.
ip = rnyNurn::hasCornmonFactor;
result = ip.test(9);
if(result) Systern.out.println("Oбщий делитель найден.");
17. Как определяется ссылка на конструктор?
Ссылка на конструктор создается путем указания имени класса, после которого
вслед за символами : : указывается оператор new. Например: MyClass: : new.
18. В каком пакете Java содержатся определения встроенных функциональных интерфейсов?
java.util.function
Приложение А Ответы на вопросы и решения упражнений... 683
Глава 15. Аплеты, события и другие вопросы
1. Какой метод вызывается первым в начале выполнения аплета? Какой метод вызывается,
когда аплет должен быть удален из системы?
Выполнение аплета начинается с вызова метода ini t () . Перед удалением аплета
вызывается метод destroy () .
2. Почему в аплете, который должен работать непрерывно, следует использовать
мноrопоточный режим?
Мноrопоточный режим необходим в непрерывно выполняющемся аплете, потому
что аплет - это управляемая событиями прикладная программа, в которой не
предусмотрены длительные операции. Например, метод paint () не будет вызван
до тех пор, пока метод start () не возвратит управление.
3. Видоизмените аплет, созданный в упражнении 15.l, таким образом, чтобы в нем
отображалась строка, переданная ему в качестве параметра. Добавьте еще один
параметр, позволяющий задавать время задержки (в миллисекундах) между последовательными
сдвигами строки.
/* Простой аплет, отображающий баннер с использованием параметров.
*/
import java.awt.*;
import java.applet.*;
/*
<applet code="ParamBanner" width=ЗOO height=SO>
<param name=message value=" Мне нравится Java! ">
<param name=delay value=SOO>
</applet>
*/
puЬlic class ParamBanner extends Applet implements RunnaЫe {
String msg;
int delay;
Thread t;
boolean stopFlag;
// Инициализировать переменную t значением null
puЫic void init() {
String temp;
msg = getParameter("message");
if (msg = = null) msg = " Java правит Интернетом ";
temp = getParameter("delay");
try {
if(temp != null)
delay Integer.parseint(temp);
else
delay 250; // если параметр не задан,
// используется значение по умолчанию
catch(NumЬerFormatException ехс) {
684 Java 8: руководство для начинающих. 6-е издание
delay = 250 ; // если допущена ошибка, используется
// значение по умолчанию
t null;
// Запустить поток
puЬlic void start()
t = new Thread(this);
stopFlag = false;
t.start();
// Точка входа в поток, манипулирующий крупным заголовком
puЬlic void run() {
char ch;
// Повторное отображение баннера
for ( ; ; ) {
try {
repaint();
Thread.sleep(delay);
ch = msg.charAt(O);
msg = msg.substring(l, msg.length());
msg += ch;
if(stopFlag)
break;
catch(InterruptedException ехс) {)
// Приостановить баннер
puЬlic void stop() {
stopFlag = true;
t = null;
// Отобразить баннер
puЬlic void paint(Graphics g)
g.drawString(msg, 50, 30);
4. Задание повышенной сложности. Создайте аплет, который отображает текущее
время, обновляя содержимое окна каждую секунду. Для того чтобы справиться
с этим заданием, вам придется провести дополнительное исследование. Вот
подсказка: получить текущее время можно, воспользовавшись объектом класса
Calendar, входящего в пакет java. util. (Напомним, что компания Oracle предоставляет
онлайновую документацию по всем стандартным классам Java.) Приобретенных
вами к этому моменту знаний должно быть достаточно для того, чтобы
самостоятельно изучить класс Calendar и использовать его методы для выполнения
задания.
Приложение А. Ответы на вопросы и решения упражнений... 685
// Простой аплет, отображающий текущее время
import java.util.*;
import java.awt.*;
import java.applet.*;
/*
<object code="Clock" width= 200 height= 50>
</object>
*/
puЫic class Clock extends Applet implements RunnaЫe {
String msg;
Thread t;
Calendar clock;
boolean stopFlag;
// Инициализировать аплет
puЫic void init() {
t = null;
msg = "";
// Запустить поток
puЫic void start()
t = new Thread(this);
stopFlag = false;
t.start();
// Точка входа в поток, отображающий время
puЫic void run() {
// Повторно отобразить время
for ( ; ; ) {
try {
repaint ();
Thread.sleep(lOOO);
if (stopFlag)
break;
catch(InterruptedException ехс) {}
// Приостановить поток, отображающий время
puЫic void stop() {
stopFlag = true;
t = null;
// Отобразить время
puЫic void paint(Graphics g) {
clock = Calendar.getinstance();
686 Java 8: руководство для начинающих. 6-е издание
msg "Текущее время: " +
Integer.toString(clock.get(Calendar.HOUR));
msg msg + ":" +
Integer.toString(clock.get(Calendar.MINUTE));
msg msg + ":" +
Integer.toString(clock.get(Calendar.SECOND));
g.drawString(msg, 30, 30);)
5. Кратко опишите модель делегирования событий в Java.
В модели делегирования событий источник формирует событие и передает его
одному или нескольким слушателям, которые лишь ожидают наступления события.
Получив уведомление, слушатель обрабатывает событие, а затем возвращает
управление.
6. Должен ли слушатель событий регистрироваться в источнике?
Должен. Для того чтобы слушатель получал уведомления о событиях, он должен
быть зарегистрирован в источнике.
7. Задание повышенной сложности. Среди языковых средств Java, предназначенных
для отображения информации, имеется метод drawLine (). Метод определен
в классе Graphics и позволяет отобразить отрезок прямой линии между
двумя заданными точками с использованием текущего цвета. Используя метод
drawLine (), создайте аплет, отслеживающий перемещение мыши. Если кнопка
мыши нажата, аплет должен рисовать на экране сплошную линию до тех пор,
пока кнопка не будет отпущена.
/* Отслеживание перемещения мыши путем рисования линии.
Признаками начала и конца линии являются нажатие
и отпускание кнопки мьnпи. */
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="TrackM" width= 300 height= lOO>
</applet>
*/
puЫic class TrackМ extends Applet
implements MouseListener, MouseMotionListener
int curX = О, curY
int oldX = О, oldY
boolean draw;
О; // текущие координаты
О; // предыдущие координаты
puЫic void init()
addMouseListener(this);
addMouseMotionListener(this);
draw = false;
/* Следующие три метода не используются, но их пустые
реализации нужны, так как эти методы объявлены
Приложение А. Ответы на вопросы и решения упражнений... 687
в интерфейсе MouseListener. */
// Обработать наведение указателя МЬШIИ на элемент
// пользовательского интерфейса
puЫic void mouseEntered(MouseEvent me) {
}
// Обработать отведение указателя МЬШIИ от элемента
// пользовательского интерфейса
puЫic void mouseExited(MouseEvent me)
}
// Обработать щелчок кнопкой МЬШIИ
puЫic void mouseClicked(MouseEvent me) {
}
// Обработать нажатие кнопки МЬШIИ
puЫic void mousePressed(MouseEvent me) {
// сохранить координаты
oldX me.getX();
oldY rne.getY();
draw true;
// Обработать отпускание кнопки мьШIИ
puЫic void mouseReleased(MouseEvent me) {
draw = false;
// Обработать перетаскивание МЬШIИ
puЫic void mouseDragged(MouseEvent me) {
// сохранить координаты
curX = me.getX();
curY = me.getY();
repaint();
// Обработать перемещение МЬШIИ
puЬlic void mouseMoved(MouseEvent me) {
// отобразить состояние
showSta tus ( "Перемещение МЬШIИ: " + те. getX () +
// Отобразить линию в окне аплета
puЫic void paint(Graphics g) {
if (draw)
g.drawLine(oldX, oldY, curX, curY);
8. Объясните назначение ключевого слова assert.
" + me.getY());
Ключевое слово assert создает утверждение, т.е. условие, которое должно быть
истинным при выполнении программы. Если же утверждение ложно, генерируется
исключение AssertionError.
688 Java 8: руководство для начинающих. 6-е издание
9. Приведите хотя бы одну причину, по которой может возникнуть потребность в
использовании машинно-зависимого метода в некоторых программах.
Машинно-зависимый метод может понадобиться для сопряжения с подпрограммами,
написанными на других языках программирования, или для оптимизации
кода с учетом конкретной среды исполнения.
Глава 16. Введение в Swing
1. Компоненты АWТ являются тяжеловесными, а компоненты Swing - ___ _
легковесными
2. Можно ли изменить стиль оформления компонента Swing? Если да, то какое
средство позволяет это сделать?
Да, можно. Это позволяют сделать подключаемые стили оформления Swing.
3. Какой контейнер верхнего уровня чаще всего используется в приложениях?
Контейнер JFrame.
4. Контейнер верхнего уровня содержит несколько панелей. На какой панели размещаются
компоненты?
На панели содержимого.
5. Как создать ссылку, отображающую сообщение "Выберите элемент списка"?
JLаЬеl("Выберите элемент списка")
6. В каком потоке должно осуществляться любое взаимодействие с компонентами
графического пользовательского интерфейса?
В потоке диспетчеризации событий.
7. Какая команда действия связывается по умолчанию с компонентом JВutton'? Как
изменить команду действия?
По умолчанию строка команды действия содержит текст надписи на кнопке. Команду
действия можно изменить, вызвав метод setActionCommand ().
8. Какое событие генерируется при нажатии кнопки?
Событие ActionEvent.
9. Как создать текстовое поле шириной до 32 символов?
JTextField(32)
10. Можно ли задать команду действия для компонента JТextField? Если можно, то
как это сделать?
Да, можно. Для этого достаточно вызвать метод setActionCommand () .
11. С помощью какого компонента Swing можно создать флажок? Какое событие генерируется
при установке или сбросе флажка?
Флажок создается с помощью компонента JCheckBox. При установке или сбросе
флажка генерируется событие ItemEvent.
12. Компонент JList отображает список элементов, которые может выбирать пользователь.
Верно или неверно?
Верно.
Приложение А Ответы на вопросы и решения упражнений... 689
13. Какое событие генерируется при выборе пользователем элемента из списка типа
JList или отмене выбора?
Событие ListSelectionEvent.
14. В каком методе задается режим выбора элементов списка типа JList? С помощью
какого метода можно получить индекс первого выбранного элемента?
Режим выбора элементов списка задается в методе setSelectionМode (). Метод
getSelected!ndex () возвращает индекс первого выбранного элемента.
15. Подкласс какого класса нужно создать при разработке аплета Swing?
Подкласс JApplet.
16. Обычно при создании исходного пользовательского интерфейса в аплетах Swing
используется метод invokeAndWai t (). Верно или неверно?
Верно.
17. Добавьте в утилиту сравнения файлов, созданную в упражнении 16.1, флажок со
следующей пояснительной надписью: Show position of mismatch (Показывать
позицию расхождения). Если этот флажок установлен, программа должна отображать
позицию, в которой обнаружено первое расхождение в содержимом сравниваемых
файлов.
/*
Упражнение 16.1.
Утилита сравнения файлов на основе Swing.
В этой версии предусмотрен флажок, установка которого задает
отображение позиции первого расхождения в содержимом
сравниваемых файлов.
Для компиляции этой утилиты требуется JDK 7
или более поздняя версия данного комплекта.
*/
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
class SwingFC implements ActionListener {
JTextField jtfFirst; // хранит имя первого файла
JTextField jtfSecond; // хранит имя второго файла
JButton jbtnComp; // кнопка запуска операции сравнения файлов
JLabel jlabFirst, jlabSecond; // метки, отображающие
// подсказки для пользователя
JLabel jlabResult; // метка для отображения результата
// сравнения и сообщений об ошибках
JCheckBox jcbLoc; // установить для отображения позиции
// первого несовпадения файлов
690 Java 8: руководство для начинающих. 6-е издание
SwingFC () {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("Compare files");
// Задать объект FlowLayout для менеджера компоновки
jfrm.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrm. setSize (200, 190);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// Создать поля для ввода имен файлов
jtfFirst = new JTextField(l4);
jtfSecond = new JTextField(l4);
// Задать команды действия для текстовых полей
jtfFirst.setActionCommand("fileA");
jtfSecond.setActionCommand("fileB");
// Создать кнопку Compare
JButton jЬtnComp = new JButton("Compare");
// Добавить слушатель событий для кнопки Compare
jЬtnComp.addActionListener(this);
// Создать метки
jlabFirst = new JLabel("First file ");
jlabSecond new JLabel("Second file: ");
jlabResult = new JLabel("");
// Создать флажок
jcbLoc = new JCheckBox("Show position of mismatch");
// Добавить компоненты в панель содержимого
jfrm.add(jlabFirst);
jfrm.add(jtfFirst);
jfrm.add(jlabSecond);
jfrm.add(jtfSecond);
jfrm.add(jcbLoc);
jfrm.add(jЬtnComp);
jfrm.add(jlabResult);
// Отобразить фрейм
jfrm.setVisiЫe(true);
}
// Сравнить файлы после нажатия кнопки Compare
puЫic void actionPerformed(ActionEvent ае) {
int i=O, j=O;
Приложение А Ответы на вопросы и решения упражнений... 691
int count = О;
// Сначала убедиться в том, что введены имена обоих файлов
if(jtfFirst.getText() .equals("")) (
jlabResult.setText("First file narne rnissing.");
return;
if(jtfSecond.getText() .equals(""))
jlabResult.setText("Second file narne rnissing.");
return;
// Сравнить файлы, используя оператор try с ресурсами
try (FileinputStrearn fl new FileinputStrearn(jtfFirst.getText());
FileinputStrearn f2 = new FileinputStrearn(jtfSecond.getText()))
// Сравнить содержимое обоих файлов
do {
i = f1 . read () ;
j = f2. read () ;
if(i != j) break;
count++;
while(i != -1 && j != -1);
if(i != j) (
if(jcbLoc.isSelected())
jlabResult.setText("Files differ at location " + count);
else
jlabResult.setText("Files are not the sarne.");
else
jlabResult.setText("Files cornpare equal.");
catch(IOException ехс) {
jlabResult.setText("File Error");
puЫic static void rnain(String args(]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЫe()
puЫic void run{) {
}
} ) ;
new SwingFC () ;
18. Измените программу ListDemo таким образом, чтобы она допускала выбор нескольких
элементов списка.
// Демонстрация выбора нескольких элементов из списка
// с помощью компонента Jlist
692 Java 8: руководство для начинающих, 6-е издание
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
class ListDemo implements ListSelectionListener {
JList<String> jlst;
JLabel jlab;
JScrollPane jscrlp;
// Создать массив имен
String names[J = { "Sherry", "Jon", "Rachel",
"Sasha", "Josselyn", "Randy",
"Тот", "Mary", "Ken",
"Andrew", "Matt", "Todd" };
ListDemo () {
// Создать новый контейнер JFrame
JFrame jfrm = new JFrame("JList Demo");
// Задать объект FlowLayout для менеджера компоновки
jfrm.setLayout(new FlowLayout());
// Задать исходные размеры фрейма
jfrm. setSize (200, 160);
// Прекратить работу программы, если
// пользователь закрывает приложение
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
// Создать компонент JList
jlst = new JList<String>(names);
// Удаление следующей строки кода задаст режим группового
// выбора элементов из списка (этот режим
// устанавливается для компонента JList по умолчанию)
// jlst.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
// Добавить список в панель прокрутки
jscrlp = new JScrollPane(jlst);
// Задать предпочтительные размеры панели прокрутки
jscrlp.setPreferredSize(new Dimension(l20, 90));
// Создать метку для отображения результатов выбора из списка
jlab = new JLabel("Please choose а name");
// Добавить обработчик событий, связанных с выбором из списка
jlst.addListSelectionListener(this);
// Добавить список и метку в панель содержимого
jfrm.add(jscrlp);
jfrm.add(jlab);
Приложение А Ответы на вопросы и решения упражнений... 693
// Отобразить фрейм
jfrm.setVisiЬle(true);
// Обработать события, связанные с выбором элементов из списка
puЬlic void valueChanged(ListSelectionEvent le) {
// Получить индексы тех элементов, выбор которых был сделан
// или отменен в списке
int indices[] = jlst.getSelectedindices();
// Отобразить результат выбора, если был выбран один
// или несколько элементов из списка
if(indices.length != 0) {
String who = "";
// Создать строку из выбранных имен
for(int i : indices)
who += names[i] + " ";
jlab.setText("Current selections: " + who);
else // иначе еще раз предложить сделать выбор
jlab.setText("Please choose а name");
puЫic static void main(String args[]) {
// Создать фрейм в потоке диспетчеризации событий
SwingUtilities.invokeLater(new RunnaЬle()
puЫic void run() {
}
}) ;
new ListDemo ();
Глава 17. Введение в JavaFX
1. Назовите имя пакета верхнего уровня библиотеки JavaFX.
javafx
2. Двумя центральными понятиями в JavaFX являются понятия платформы и сцены.
Какие классы их инкапсулируют?
Stage и Scene
3. Граф сцены состоит из----------------узлов
4. Базовым классом для всех узлов служит класс -------Node
5. Какой класс должны расширять все приложения JavaFX?
Applicatioп
6. Какие три метода управляют жизненным циклом приложения JavaFX?
iпit (), start () и stop ()
694 Java 8: руководство для начинающих. 6-е издание
7. В каком из методов, управляющих жизненным циклом, возможно создание платформы
приложения?
start (}
8. Метод launch (} вызывается для запуска автономного приложения JavaFX. Верно
или неверно?
Верно.
9. Назовите имена классов JavaFX, которые поддерживают метку и кнопку.
Label и Button
10. Одним из способов прекращения работы автономного приложения JavaFX является
вызов метода Platfoпn.exit (}. Класс Platfoпn находится в пакете javafx.
Application. При вызове метода exi t (} работа программы немедленно прекращается.
Учитывая это, измените программу JavaFXEventDemo, представ.ленную в
этой главе, таким образом, чтобы она отображала две кнопки: Run и Exit. При
нажатии кнопки Run программа должна отобразить соответствующее сообщение
в метке. При нажатии кнопки Exit приложение должно завершить свою работу. В
обработчиках событий используйте лямбда-выражения.
// Демонстрация использования метода Platform.exit()
import javafx.application.*;
import javafx.scene.*;
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.event.*;
import javafx.geometry.*;
puЫic class JavaFXEventDemo extends Application {
Label response;
puЬlic static void main(String[] args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод start()
puЬlic void start(Stage myStage)
// Присвоить название платформе
myStage.setTitle("Use Platform.exit() .");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального
// зазоров составляет 10.
FlowPane rootNode = new FlowPane(lO, 10);
// Центрировать элементы управления на сцене
rootNode.setAlignment(Pos.CENTER);
Приложение А Ответы на вопросы и решения упражнений ... 695
// Создать сцену
Scene myScene = new Scene{rootNode, 300, 100);
// Установить сцену на платформе
myStage.setScene{myScene};
// Создать метку
response = new LаЬеl{"Нажмите кнопку"};
// Создать две кнопки
Button btnRun = new Button("Run"};
Button btnExit = new Button("Exit"};
// Обработать события действий для кнопки Run
btnRun.setOnAction{{ae} -> response.
setText("You pressed Run.")};
// Обработать события действий для кнопки Exit
btnExit.setOnAction{{ae) -> Platform.exit{)};
// Добавить метку и кнопки в граф сцены
rootNode.getChildren{} .addAll{btnRun, btnExit, response);
// Отобразить платформу и ее сцену
myStage.show{};
ll. Какой элемент управления JavaFX реализует флажок?
CheckВox
12. Класс ListView - это элемент управления, который отображает список файлов,
находящихся в некотором каталоге локальной файловой системы. Верно или неверно?
Неверно. Компонент ListView отображает список элементов, доступных для выбора
пользователем.
13. Преобразуйте Swing-пporpaммy для сравнения файлов из упражнения 16. l в приложение
JavaFX. При этом воспользуйтесь предоставляемой в JavaFX возможностью
запускать события действий для кнопки программными средствами. Это
делается путем вызова метода fire () для экземпляра кнопки. К примеру, если
имеется экземпляр класса Button, который вы назвали myButton, то для запуска
событий необходимо использовать вызов myButton. fire (). Воспользуйтесь этим
при реализации обработчиков событий для текстовых полей, в которых хранятся
имена сравниваемых файлов. В тех случаях, когда пользователь нажимает клавишу
<Enter> и при этом фокус ввода находится в одном из указанных текстовых
полей, запускайте событие действия для кнопки Compare. После этого код обработчика
событий для кнопки Compare должен выполнить сравнение файлов.
// Реализация средствами JavaFX версии утилиты сравнения файлов,
// представленной в упражнении 16.1.
import javafx.application.*;
import javafx.scene.*;
696 Java 8: руководство для начинающих. 6-е издание
import javafx.stage.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.event.*;
import javafx.geometry.*;
import java.io.*;
puЫic class JavaFXFileComp extends Application {
TextField tfFirst; // хранит имя первого файла
TextField tfSecond; // хранит имя второго файла
Button btnComp; // кнопка запуска операции сравнения файлов
Label labFirst, labSecond; // метки, отображающие
// подсказки для пользователя
Label labResult; // метка для отображения результата
// сравнения и сообщений об ошибках
puЫic static void main(String[] args) {
// Запустить приложение JavaFX, вызвав метод launch()
launch(args);
// Переопределить метод start()
puЫic void start(Stage myStage)
// Задать заголовок окна приложения
myStage.setTitle("Compare Files");
// Использовать FlowPane для корневого узла. В данном
// случае значение вертикального и горизонтального зазоров
// составляет 10.
FlowPane rootNode = new FlowPane(lO, 10);
// Центрировать элементы управления на сцене
rootNode.setAlignment(Pos.CENTER);
// Создать сцену
Scene myScene = new Scene(rootNode, 180, 180);
// Установить сцену на платформе
myStage.setScene(myScene);
// Создать текстовые поля для имен файлов
tfFirst = new TextField();
tfSecond = new TextField();
// Задать предпочтительные размеры столбцов
tfFirst.setPrefColumnCount(12);
tfSecond.setPrefColumnCount(l2);
Приложение А Ответы на вопросы и решения упражнений... 697
// Задать подсказки для имен файлов
tfFirst.setPromptText("Enter file name.");
tfSecond.setPromptText("Enter file name.");
// Создать кнопку Compare
btnComp = new Button("Compare");
// Создать метки
labFirst = new Label("First file: ");
labSecond new Label("Second file: ");
labResult = new Label("");
// Использовать лямбда-выражения для обработки событий
// действий, связанных с текстовыми полями Эти обработчики
// просто запускают событие для кнопки Compare.
tfFirst.setOnAction( (ае) -> btnComp.fire());
tfSecond.setOnAction( (ае) -> btnComp.fire());
// Обработать события действий для кнопки Compare
btnComp.setOnAction(new EventHandler<ActionEvent>()
puЫic void handle(ActionEvent ае) {
int i=O, j=O;
// Прежде всего убедиться в том, что введены
// имена обоих файлов
if(tfFirst.getText() .equals(""))
labResult.setText("First file name missing.");
return;
if(tfSecond.getText() .equals(""))
labResult.setText("Second file name missing.");
return;
// Сравнить содержимое файлов. Для обработки файлов
// использовать оператор trу-с-ресурсами.
try (FileinputStream fl =
new FileinputStream(tfFirst.getText());
FileinputStream f2 =
new FileinputStream(tfSecond.getText()))
// Сравнить содержимое файлов
do {
i = fl.read();
j = f2. read () ;
if(i != j) break;
while(i != -1 && j != -1);
if(i != j)
labResult.setText("Files are not the same.");
else
labResult.setText("Files compare equal.");
698 Java 8: руководство для начинающих. 6-е издание
}
}) ;
catch(IOException ехс) {
labResult.setText("File Error Encountered");
!/ Добавить элементы управления в граф сцены
rootNode.getChildren().
addAll(labFirst, tfFirst, labSecond, tfSecond,A
btnComp, labResult);
// Отобразить платформу и ее сцену
myStage.show();
14. Видоизмените программу EffectsAndTransforrnsDemo таким образом, чтобы размытие
изображения применялось также к кнопке Rotate. Задайте для ширины и
высоты области размытия значение 5, а для счетчика итераций - значение 2.
Чтобы добавить эффект размытия в кнопку Rotate, прежде всего создайте экземпляр
класса BoxВlur:
BoxBlur rotateBlur = new BoxBlur{5.0, 5.0, 2);
Затем добавьте следующую строку кода:
btnRotate.setEffect(rotateBlur);
После внесения указанных изменений изображение кнопки будет размываться, и
ее можно будет поворачивать на заданный угол.
Приложение Б
Применение
документирующих
комментариев в Java
700 Java 8: руководство для начинающих. 6-е издание
Как было отмечено в главе 1, в Java поддерживаются три вида комментариев. Первым
двум соответствуют символы / / и / * * /, а третий вид называется документирующими
комментариями. Такие комментарии начинаются символами /** и заканчиваются
символами * /. Документирующие комментарии позволяют включать сведения о программе
в исходный код самой программы. Для извлечения этих сведений и их последующего
преобразования в формат НТМL-документа служит утилита javadoc, входящая
в состав JDК. Документирующие комментарии - удобный способ документирования
прикладных программ. Вам, вероятно, уже встречалась документация, сформированная
утилитой j avadoc, поскольку именно такой способ применяется для составления документации
на библиотеку Java API.
Дескрипторы iavadoc
Утилита j avadoc распознает и обрабатывает в документирующих комментариях следующие
дескрипторы.
Дескриптор Описание
@author Указывает автора программы
{ @code} Отображает данные шрифтом, предназначенным для вывода исходного кода, не
выполняя преобразований в формат НТМL-документа
@deprecated Указывает на то, что элемент программы не рекомендован к применению
{ @docRoot} Указывает путь к корневому каталогу документации
@exception Обозначает исключение, генерируемое методом
{ @inher i tDoc} Наследует комментарии от ближайшего супер класса
{ @link} Вставляет встроенную ссылку на другую тему
{@linkplain} Вставляет встроенную ссылку на другую тему, но ссылка отображается тем же
шрифтом, что и простой текст
{@li teral} Отображает данные, не выполняя преобразований в формат НТМL-документа
@param Документирует параметр метода
@return Документирует значение, возвращаемое методом
@see Определяет ссылку на другую тему
@serial Документирует сериализуемое по умолчанию поле
@serialData Документирует данные, записываемые методом wri teObj ect () или
wri teExternal ()
@serialField Документирует компонент ObjectStreamF ield
@since Обозначает версию, в которой были внесены определенные изменения
@throws То же, что и дескриптор @exception
{@value} Отображает значение константы, которая должна быть определена как поле типа
static
@version Обозначает версию класса
Приложение Б. Применение документирующих комментариев в Java 701
Дескрипторы, начинающиеся с символа@, называются автономными и помечают
строку комментариев, тогда как дескрипторы, заключенные в фигурные скобки, называются
встраиваемыми и могут быть использованы в других дескрипторах. В документирующих
комментариях также можно использовать стандартные НТМL-дескрипторы.
Но некоторые НТМL-дескрипторы, например дескрипторы заголовков, применять не
следует, поскольку они могут испортить внешний вид НТМL-документа, составляемого
с ПОМОЩЬЮ утилиты j avadoc.
Что касается документирования исходного кода, то документирующие комментарии
можно использовать для описания классов, интерфейсов, полей, конструкторов и методов.
Но в любом случае документирующие комментарии должны предшествовать непосредственно
описываемому элементу исходного кода. Одни дескрипторы, в том числе @see,@
since и@ deprecated, могут быть использованы для документирования любых элементов
исходного кода, а другие - только для документирования определенных элементов. Каждый
дескриптор документирующих комментариев рассматривается далее по отдельности.
ПРИМЕЧАНИЕ
Документирующие комментарии также можно использовать для составления документации и
краткого обзора разрабатываемого пакета, но делается это иначе, чем документирование исходного
кода. Подробнее об этом можно узнать из документации по утилите j avadoc.
Дескриптор @author
Описывает автора класса или интерфейса и имеет следующий синтаксис:
@author описание
где описание, как правило, обозначает имя автора. Для того чтобы сведения, указываемые
в поле @author, были включены в результирующий НТМL-документ, при вызове
утилиты javadoc из командной строки следует указать параметр -author.
Дескриптор { @code}
Позволяет включать в комментарии текст, в том числе и отдельные фрагменты
кода. Такой текст будет выводиться специальным шрифтом, используемым для форматирования
кода, и не подлежит дальнейшей обработке по правилам форматирования
НТМL-документов. Этот дескриптор имеет следующий синтаксис:
{ @code фрагмент_ кода}
Дескриптор @deprecated
Указывает на то, что класс, интерфейс или метод не рекомендован к применению.
В описание рекомендуется включать дескриптор @see или {@link}, чтобы уведомить
программиста о других возможных решениях. У этого дескриптора имеется следующий
синтаксис:
@deprecated описание
где описание обозначает сообщение, описывающее причины, по которым данное языковое
средство Java не рекомендуется к применению. Дескриптор@ deprecated можно применять
для документирования полей, методов, конструкторов, классов и интерфейсов.
702 Java 8: руководство для начинающих, 6-е издание
Дескриптор {@docRoot}
Указывает путь к корневому каталогу документации.
Дескриптор @exception
Описывает исключение, которое может возникнуть при выполнении метода. Он
имеет следующий синтаксис:
@exception имя_исключения пояснение
где имя_исключения обозначает полностью определенное имя исключения, а пояснение
- строку, в которой поясняется, при каких условиях исключение может возникнуть.
Дескриптор @exception можно применять только для документирования методов.
Дескриптор { @inheri tDoc}
Наследует комментарии от ближайшего суперкласса.
Дескриптор { @link}
Предоставляет встраиваемую ссылку на дополнительные сведения. Он имеет следующий
синтаксис:
{@link пакет. класс#член текст}
где пакет. класс#член обозначает имя класса или метода, на который делается встраиваемая
ссьmка, а текст - строку, отображаемую в виде встраиваемой ссылки.
Дескриптор { @linkplain}
Вставляет встраиваемую ссылку на другую тему. Эта ссьmка отображается обычным
шрифтом. В остальном же данный дескриптор подобен дескриптору {@link}.
Дескриптор { @li teral}
Позволяет включать текст в комментарии. Этот текст отображается без дополнительной
обработки по правилам форматирования НТМL-документов. У него имеется следующий
синтаксис:
@literal описание
где описание обозначает текст, включаемый в комментарии.
Дескриптор @param
Описывает параметр и имеет следующий синтаксис:
@parameter имя_ параметра пояснение
где имя_ параметра обозначает конкретное наименование параметра, а пояснение -
поясняемое назначение параметра. Дескриптор @param можно применять для документирования
метода, конструктора, а также обобщенного класса или интерфейса.
Приложение Б. Применение документирующих комментариев в Java 703
Дескриптор @return
Описывает значение, возвращаемое методом. Он имеет следующий синтаксис:
@return пояснение
где пояснение обозначает тип и назначение возвращаемого значения. Дескриптор@
return применяется только для документирования методов.
Дескриптор @see
Предоставляет ссылку на дополнительные сведения. Ниже приведены две наиболее
часто используемые формы этого дескриптора.
@see ссылка
@see пакет.класс#член текст
В первой форме ссылк а обозначает абсолютный или относительный URL-aдpec.
Во второй форме пакет. класс#член обозначает имя элемента, тогда как текст -
отображаемые сведения об этом элементе. Параметр текст указывать необязательно, а
в его отсутствие отображается элемент, определяемый параметром пакет. класс#член.
Имя члена также может быть опущено. Этот дескриптор дает возможность указать ссылку
не только на метод или поле, но и на класс или интерфейс. Имя элемента может быть
указано полностью или частично. Но если имени члена предшествует точка, она должна
быть заменена знаком#.
Дескриптор @serial
Определяет комментарии к полю, упорядочиваемому по умолчанию. Он имеет следующий
синтаксис:
@serial описание
где описание обозначает комментарии к данному полю.
Дескриптор @serialData
Предназначен для документирования данных, которые бьши записаны с помощью
методов writeObject () и writeExternal (). Синтаксис этого дескриптора приведен
ниже.
@serialData описание
где описание обозначает комментарии к записанным данным.
Дескриптор @serialField
Предназначен д л я документирования классов, реализующих инт ерфейс
SerializaЬle. Он предоставляет комментарии к компоненту ObjectStreamField и
имеет следующий синтаксис:
@serialField имя тип описание
где имя и тип обозначают конкретное наименование и тип поля соответственно, а
описание - комментарии к этому полю.
704 Java 8: руководство для начинающих, 6-е издание
Дескриптор @since
Устанавливает, что данный элемент был внедрен, начиная с указанной версии программы.
Синтаксис этого дескриптора приведен ниже.
@since версия
Здесь версия обозначает строку, указывающую версию или выпуск программы, где
был внедрен данный элемент.
Дескриптор @throws
Выполняет те же функции, что и дескриптор @exception.
Дескриптор @value
Применяется в двух основных формах. В первой форме отображается значение константы,
которой предшествует этот дескриптор. Константа должна быть полем типа
static. Ниже приведена первая форма этого дескриптора.
{@value}
Во второй форме отображается значение указываемого статического поля. Эта форма
выглядит следующим образом:
{@value пакет.класс#член}
где пакет. класс#член обозначает имя статического поля.
Дескриптор @version
Описывает версию класса. Ниже приведен синтаксис этого дескриптора.
@version информация
Здесь информация обозначает строку, содержащую сведения о версии программы.
Как правило, это номер версии, например 2.2. Для того чтобы сведения в поле дескриптора
@version были включены в результирующий НТМL-документ, при вызове
утилиты j avadoc из командной строки следует указать параметр -version.
Общая форма документирующих комментариев
После символов/** следуют одна или несколько строк с общим описанием класса,
интерфейса, переменной или метода. Далее можно ввести любое количество дескрипторов,
начинающихся со знака @. Каждый такой дескриптор должен начинаться с новой
строки или следовать после одной или нескольких звездочек(*) в начале строки. Несколько
однотипных дескрипторов должны быть объединены вместе. Так, если требуется
использовать три дескриптора @see, их следует расположить друт за другом. Встраиваемые
дескрипторы (начинающиеся с фигурной скобки) можно использовать в любом
описании.
Ниже приведен пример, демонстрирующий использование документирующих комментариев
для описания класса.
Приложение Б. Применение документирующих комментариев в Java 705
/**
* К.ласе для отображения гистограммы.
* @author Herbert Schildt
* @version 3.2
*/
Результат, выводимый утилитой javadoc
Утилита javadoc читает данные из исходного файла программы на Java и генерирует
несколько НТМL-файлов, содержащих документацию к этой программе. Сведения о каждом
классе помещаются в отдельный файл. В результате выполнения утилиты javadoc
составляется также предметный указатель и дерево иерархии. Кроме того, могут быть
сгенерированы и другие НТМL-файлы.
Пример применения документирующих
комментариев
Ниже приведен пример программы, в исходном тексте которой имеются документирующие
комментарии. Обратите внимание на то, что каждый такой комментарий непосредственно
предшествует описываемому элементу программы. После обработки утилитой
javadoc документация по классу SquareNum помещается в файл SquareNum. html.
irnport java.io.*;
/**
* К.ласе, демонстрирующий использование
* документирующих комментариев.
* @author Herbert Schildt
* @version 1.2
*/
puЫic class SquareNum {
/**
* Этот метод возвращает квадрат значения параметра nurn.
* Это описание состоит из нескольких строк. Число строк
* не ограничивается.
* @pararn nurn Значение, которое требуется возвести в квадрат.
* @return Квадрат числового значения параметра num.
*/
puЫic douЫe square{douЫe nurn) {
return num * nurn;
/**
* Этот метод получает значение, введенное пользователем.
* @return Введенное значение типа douЫe.
* @exception IOException Исключение при ошибке ввода.
* @see IOException
*/
puЫic douЫe getNurnber{) throws IOException {
706 Java 8: руководство для начинающих. 6-е издание
// создать поток BufferedReader из стандартного потока Systern.in.
InputStrearnReader isr new InputStrearnReader{Systern.in);
BufferedReader inData = new BufferedReader{isr);
String str;
str = inData.readLine{);
return {new DouЫe(str)) .douЫeValue();
/**
* В этом методе демонстрируется применение метода square().
* @pararn args Не используется.
* @exception IOException Исключение при ошибке ввода.
* @see IOException
*/
puЫic static void rnain(String args[J)
throws IOException
SquareNurn оЬ = new SquareNurn();
douЫe val;
Systern.out.
println{"Bвeдитe значение для возведение в квадрат: ");
val ob.getNurnЬer{);
val = ob.square(val);
Systern.out.println{"Kвaдpaт введенного значения " + val);
Предметный указатель
А
ASCII 62
AWT 538,569
с
CLASSPATH 292
1
IDE 36
J
Java API 300
JavaFX 569, 606
JavaFX Script 606
JDK 36
JFC 569, 578
JIТ-компилятор 32
JVM 30
м
MVC 570
N
NIO 384
s
SAM 505
Swing 568
u
компоненты 572
контейнеры 572
менеджер компоновки 573
Unicode 63
А
Автоматическое управление ресурсами 153,
367
Автоупаковка 450,452
в выражениях 454
в методах 453
Аннотация 460
Анонимный внутренний класс 599
Аплет 29, 538
архитектура 542
безопасность 30
инициализация и завершение 544
методы 543, 544
на основе AWT 544, 546
на основе Swing 601
обработка событий 558
ограничения 545
окно состояния 549
передача параметров 550
переносимость 30
перерисовка окна 544
свойства 541
Аргумент 135, 140
командной строки 189
передача по значению 212
передача по ссылке 213
Арность 238
Б
Базовый тип 492
Байт-код 30
Байтовый поток 355
консольный ввод 358
КОНСОЛЬНЫЙ ВЫВОД 360
файловый ввод 361
файловый вывод 365
Безопасность типов 467
Библиотеки Java 55
Блок 50
finally 338
try/catch 326
вложенный 333
синхронизированный 419
статический 231
Блокировка 416
Буфер 91
8
Ввод 355
консольный 90, 378
файловый 383
Взаимоблокировка 427
708 Предметный указатель
Виртуальная машина 30
Вывод 41, 355
консольный 381
файловый 382
Выражение 85
д
Декремент 50, 74
Делегирование событий 554, 557
Деструктор 153
Динамическая диспетчеризация методов 274
Динамическая компиляция 31
Е
Единица компиляции 38
з
Заглушка 553
Замыкание 505
Захват переменной 521
и
Идентификатор 54
Именованный блок 115
Инициализация массива 163, 168
Инкапсуляция 34, 204
Инкремент 49, 74
Интегрированная среда разработки 36
Интерпретатор байт-кода 30
Интерфейс 290, 300
ActionListener 580
Annotation 460
AutoCloseaЫe 367
CharSequence 378
CloseaЫe 367
ComparaЬle<T> 483
Containment 486
Datalntput 371
DataOutput 370
EventНandler 620
ItemListener 587
LayoutManager 573
ListSelectionListener 591
ListSelectionModel 591
MouseListener 557
MouseMotionListener 557
RunnaЫe 399
WindowConstants 576
наследование 313
обобщенный 485
объявление 301
реализация 301
функциональный 505, 506
Исключение 324
ArithmeticException 345
ArrayindexOutOfВoundsException 164
FileNotFoundException 364
IOException 358
генерирование 325,334
повторное 335,342
групповой перехват 341
иерархия классов 325
необработанное 329
непроверяемое 343
обработка 327,330
перехват 332
проверяемое 343
Источник событий 554
к
Класс 34, 128
ActionEvent 580
Applet 552
Application 608, 609
BorderPane 608
BufferReader 378
Class 470
Console 376
Control 614
DatalnputStream 370
DataOutputStream 370
Enum 443
Error 325
ErrorMsg 214
EventObject 555
Exception 325,344
FilelnputStream 361
FileOutputStream 361
FileReader 383
FileWriter 382
FlowPane 608
GridPane 608
InputStream 355
InputStreamReader 378
JApplet 601
JButton 580
JCheckВox 587
JComponent 571
JList 590
JScrol!Pane 590
JТextComponent 583
JTextField 583
Label 614
Node 608
Number 451
Object 287
OutputStream 355
PrintWriter 381
RandomAccessFile 374
Reader 356
Scanner 393
Scene 608
Stage 608
String 182, 183
StringBuffer 187
System 41
Thread 399
ThrowaЫe 325, 337, 500
Writer 356
абстрактный 281
анонимный 237
внутренний 599
вложенный 234
внутренний 235,601
обобщенный 466
определение 39
Ключевое слово 54
assert 561, 562
catch 326
class 129
default 504
douЫe 44
enum 437
extends 248, 313, 474, 481
final 284, 437
finally 338
float 44
implements 301
import 457
instanceof 561, 562
int 43
interface 300, 460
native 561, 564
private 34, 40, 204
protected 153
puЬlic 34, 40, 204
static 40, 228
strictfp 561, 562
super 255, 259
synchronized 416
Предметный указатель 709
this 156, 521, 564
throws 340
transient 561
try 326
void 40, 136
volatile 561
Кнопка 617
Коллекция 177
Команда действия 580
Комментарии 39
документирующие 700
Компаранд 232
Компонент 571
Конвейер 534
Конкатенация 185
Константа 65
восьмеричная 66, 67
двоичная 66
именованная 285
перечисления 437
шестнадцатеричная 66, 67
Конструктор 148
наследование 254
обобщенный 484
очередность вызова 266
параметризованный 149
перегрузка 221
Контейнер 572
Контроллер 570
Корневая панель 573
л
Литерал 65
символьный 68
строковый 67
Ложная активизация 422
Лямбда-выражение 504
блочное 513
захват переменной 521
контексты 520
обработка исключений 522
тело 505
целевой тип 505
Лямбда-оператор 505
м
I\11ассив 40, 160, 169
двумерный 166
инициализация 163, 168
многомерный 168, 180
71 О ПредМетный указатель
нерегулярный 167
одномерный 161
строковый 186
Машинно-зависимый метод 564
Менеджер компоновки 573
Метаданные 460
Метка 116
Метод 35, 134
charAt() 187
finalize() 153
getErrorMsg() 214
init() 609
launch() 609
main() 40, 129
notify() 422
notify All() 422
print() 44
println() 41
setCharAt() 187
setPriority() 413
sleep() 402
start() 609
stop() 609
substring() 186
wait() 422
абстрактный 281
аргументы 135
обобщенный 466, 482
параметры 135
переменное число аргументов 238, 242
переопределение 272,276
предотвращение переопределения 284
рекурсивный 226
сигнатура 220
синхронизированный 419
статический 230
Многозадачность 398
вытесняющая 415
Мноrопоточная обработка 398
Многослойная панель 573
Модель 570
Модификатор 40, 205
final 285, 342
protected 153, 296
strictfp 562
synchronized 425, 562
transient 561
volatile 561
Монитор 416
н
Набор символов 384
Наследование 35, 248
доступ к членам класса 251
интерфейсов 313
множественное 318
предотвращение 285
Непроверенное предупреждение 494
о
Область действия 69
Обобщения 466
обобщенный интерфейс 485
обобщенный конструктор 484
обобщенный метод 482
общая форма объявления 473
ограничения 498
ограниченные типы 474
ограниченные шаблоны 479
очистка 496
параметр типа 469
Оболочки типов 214, 385, 451
Обработчик исключений 324
Объект 34, 128, 133
Объектно-ориентированное
программирование 33
Ограниченный тип 473
Окно состояния 549
ооп 33
Операнд 72
Оператор 72
? 200
break 97, 113, 115
catch 331
continue 119
goto 115, 119
if 47, 91
вложенный 93
if-else 94, 101
import 298
instaпceof 562
new 133, 151
package 291
return 137
switch 95, 101, 187
вложенный 98
throw 334
try с ресурсами 367
присваивания 79
сдвига 195
тернарный 200
управляющий 90
Операция 72
арифметическая 72
логическая 75
укороченная 76
поразрядная 190,197
приоритет 83
сравнения 75
Опорный элемент 232
Очередь 173
динамическая 307
кольцевая 307
линейная 307
Очистка 496
Ошибка неоднозначности 497
п
Пакет 205, 290
java.awt 555, 582
java.awt.event 554, 555, 582
javafx.application 607
javafx.scene 607
javafx.scene.control 614
javafx.scene.layout 607
javafx.stage 607
java.io 355
java.lang 300,343
java.lang.annotation 460
java.nio 384
java.util 555
java.util.concurrent 421
java.util.function 532
javax.swing 572
иерархия 291
импорт 298
по умолчанию 291
Панель содержимого 573
Параллельное программирование 421
Параметр 40, 135, 140
объектный 211
Параметризованный тип 466
Перегрузка метода 216, 241
Переключатель 95
Переменная 42
инициализация 68, 71
динамическая 69
область действия 69
объявление 68
Предметный указатель 711
правила именования 54
ссылочного типа 133
статическая 228
цикла 49, 102
Переменная среды 292
Перечисление 436
методы 439
ограничения 442
порядковое значение 443
Повышение типов 85
Подкласс 248
Полиморфизм 35, 219, 276
Поразрядные операции 190, 197
Порядковое значение 443
Поток
диспетчеризации событий 578
приложения 613
Поток ввода-вывода 355
ДВОИЧНЫХ данных 370
имвольный 3 77
символьный 382
стандартный 357
Поток выполнения 398
завершение 410
основной 400
остановка 428
приоритет 412
синхронизация 399,415
создание 400,405,407
состояния 399
Представление 570
Преобразование 635
Преобразование типов 85
Приведение типов 81
Присваивание 79
Пространство имен 290
Процесс 398
Пустой оператор 105
р
Равноправные компоненты 569
Распаковка 451
Расширение типа 80
Рекурсия 226
с
Самотипизированная константа 437
Сборка мусора 152
Сервлет 31
Сигнатура 220
712 Предметный указатель
Символьная строка 67
Символьный поток 355, 377
Синтаксическая ошибка 41
Синхронизация 399, 415
Слушатель событий 554, 555
интерфейсы 556
регистрация 554
Событие 580
в JavaFX 616
делегирование 554
источник 554
класс 555
мыши 557
обработка 554
Сортировка
быстрая 232
пузырьковая 164
Состояние гонки 428
Спецификатор 205
Список 625
Ссылка на метод 524
Стартовый поток 613
Статический импорт 457
Стек 173
Стеклянная панель 573
Строка 182
Строковый литерал 183
Сужение типа 82
Суперкласс 248
т
Текстовое поле 630
Тип 43, 44, 58
Ьооlеап 63
byte 60
char 60, 61
douЫe 61
float 61
int 60
long 60
short 61
String 182, 186
базовый 492
логический 63
ограниченный 473
параметризованный 467
приведение 81
расширение 80
символьный 61
с плавающей точкой 61
сужение 82
целочисленный 59
элементарный 59
явное преобразование 81
Точечная нотация 130
у
Указатель 33
Указатель файла 374
Упаковка 451
Управляющая последовательность 66
Управляющий оператор 90
У тверждение 562
ф
Финализатор 153
Флажок 621
Функциональный интерфейс 505, 506
обобщенный 514
предопределенный 532
Функция 35
ц
Цепочечные исключения 345
Цикл 90
do-while 109
ч
for 48, 101, 103, 104, 106
бесконечный 105
расширенный 107, 177
for-each 177, 181
while 107
без тела 105
вложенный 124
прерывание 113
Член класса 129
закрытый 204
защищенный 296
открытый 204
статический 228
уровни доступа 294
ш
Шаблон аргумента 478
э
Экземпляр класса 34, 128
Экранирование символов 66
Элементарный тип 59
Эффект 634
